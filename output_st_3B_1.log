INFO:root:time: 2025年 03月 05日 星期三 00:57:41 CST

INFO:root:pid: 2250534
INFO:root:seed: 181
INFO:root:model: Qwen2.5-Coder-3B-Instruct
INFO:root:generate: Structure
INFO:root:result_path: /home/qikahh/projects/Structured_Code_Context/Datasets/DevEval/Qwen2.5-Coder-3B-Instruct/result_st_1.json
INFO:accelerate.utils.modeling:We will use 90% of the memory on device 0 for storing the model, and 10% for the buffer to avoid OOM. You can set `max_memory` in to a higher value to use more memory (at your own risk).

Loading checkpoint shards:   0%|          | 0/2 [00:00<?, ?it/s]
Loading checkpoint shards:  50%|█████     | 1/2 [00:01<00:01,  1.06s/it]
Loading checkpoint shards: 100%|██████████| 2/2 [00:01<00:00,  1.56it/s]
Loading checkpoint shards: 100%|██████████| 2/2 [00:01<00:00,  1.42it/s]
INFO:root:--------data 0--------

data 0:   0%|          | 0/512 [00:00<?, ?it/s]
data 0:   2%|▏         | 10/512 [00:56<47:30,  5.68s/it]
data 0:   4%|▍         | 20/512 [01:52<45:56,  5.60s/it]
data 0:   4%|▍         | 20/512 [02:50<1:10:03,  8.54s/it]
INFO:root:函数头: 
def is_json_serializable(val):

INFO:root:目标函数体: 
    json_types = (type(None), bool, dict, float, int, list, str, tuple)
    return isinstance(val, json_types)

INFO:root:生成结果: 
    try:
        import json
        json.dumps(val)
        return True
    except (TypeError, OverflowError):
        return False


INFO:root:----------------------------------------
INFO:root:max length: 4744
INFO:root:max position: 4744
INFO:root:target_namespace: python-benedict.benedict<folder>.utils<folder>.type_util<file>.is_json_serializable<func>
INFO:root:****************************************

data 0:   0%|          | 0/512 [00:00<?, ?it/s]
data 0:   2%|▏         | 10/512 [00:54<45:30,  5.44s/it]
data 0:   4%|▍         | 20/512 [01:51<46:04,  5.62s/it]
data 0:   4%|▍         | 20/512 [02:49<1:09:23,  8.46s/it]
INFO:root:函数头: 
def is_json_serializable(val):

INFO:root:目标函数体: 
    json_types = (type(None), bool, dict, float, int, list, str, tuple)
    return isinstance(val, json_types)

INFO:root:生成结果: 
    try:
        import json

        json.dumps(val)
        return True
    except (TypeError, OverflowError):
        return False




INFO:root:----------------------------------------
INFO:root:max length: 4744
INFO:root:max position: 4744
INFO:root:target_namespace: python-benedict.benedict<folder>.utils<folder>.type_util<file>.is_json_serializable<func>
INFO:root:****************************************

data 0:   0%|          | 0/512 [00:00<?, ?it/s]
data 0:   2%|▏         | 10/512 [00:53<44:52,  5.36s/it]
data 0:   4%|▍         | 20/512 [01:52<46:41,  5.69s/it]
data 0:   4%|▍         | 20/512 [02:04<51:02,  6.22s/it]
INFO:root:函数头: 
def is_json_serializable(val):

INFO:root:目标函数体: 
    json_types = (type(None), bool, dict, float, int, list, str, tuple)
    return isinstance(val, json_types)

INFO:root:生成结果: 
    try:
        json.dumps(val)
        return True
    except TypeError:
        return False


INFO:root:----------------------------------------
INFO:root:max length: 4744
INFO:root:max position: 4744
INFO:root:target_namespace: python-benedict.benedict<folder>.utils<folder>.type_util<file>.is_json_serializable<func>
INFO:root:****************************************

data 0:   0%|          | 0/512 [00:00<?, ?it/s]
data 0:   2%|▏         | 10/512 [00:51<43:25,  5.19s/it]
data 0:   4%|▍         | 20/512 [01:49<45:28,  5.55s/it]
data 0:   6%|▌         | 30/512 [03:04<51:38,  6.43s/it]
data 0:   8%|▊         | 40/512 [04:02<48:39,  6.19s/it]
data 0:  10%|▉         | 50/512 [05:12<49:50,  6.47s/it]
data 0:  12%|█▏        | 60/512 [06:11<47:10,  6.26s/it]
data 0:  14%|█▎        | 70/512 [07:22<48:17,  6.56s/it]
data 0:  16%|█▌        | 80/512 [08:41<50:16,  6.98s/it]
data 0:  16%|█▌        | 80/512 [09:37<51:57,  7.22s/it]
INFO:root:函数头: 
def is_json_serializable(val):

INFO:root:目标函数体: 
    json_types = (type(None), bool, dict, float, int, list, str, tuple)
    return isinstance(val, json_types)

INFO:root:生成结果: 
    if isinstance(val, (dict, list)):
        return True
    if isinstance(val, (str, int, float, bool, None)):
        return True
    if isinstance(val, (bytes, bytearray)):
        return True
    if isinstance(val, complex):
        return True
    if isinstance(val, tuple):
        return all(is_json_serializable(item) for item in val)
    return False




INFO:root:----------------------------------------
INFO:root:max length: 8965
INFO:root:max position: 9445
INFO:root:target_namespace: python-benedict.benedict<folder>.utils<folder>.type_util<file>.is_json_serializable<func>
INFO:root:****************************************

data 0:   0%|          | 0/512 [00:00<?, ?it/s]
data 0:   2%|▏         | 10/512 [00:53<44:53,  5.37s/it]
data 0:   4%|▍         | 20/512 [01:53<46:44,  5.70s/it]
data 0:   4%|▍         | 20/512 [02:51<1:10:22,  8.58s/it]
INFO:root:函数头: 
def is_json_serializable(val):

INFO:root:目标函数体: 
    json_types = (type(None), bool, dict, float, int, list, str, tuple)
    return isinstance(val, json_types)

INFO:root:生成结果: 
    try:
        import json
        json.dumps(val)
        return True
    except (TypeError, OverflowError):
        return False


INFO:root:----------------------------------------
INFO:root:max length: 4744
INFO:root:max position: 4744
INFO:root:target_namespace: python-benedict.benedict<folder>.utils<folder>.type_util<file>.is_json_serializable<func>
INFO:root:****************************************
INFO:root:--------data 1--------

data 1:   0%|          | 0/512 [00:00<?, ?it/s]
data 1:   2%|▏         | 10/512 [00:21<17:36,  2.10s/it]
data 1:   4%|▍         | 20/512 [00:36<14:38,  1.79s/it]
data 1:   6%|▌         | 30/512 [00:54<14:10,  1.76s/it]
data 1:   8%|▊         | 40/512 [01:10<13:22,  1.70s/it]
data 1:  10%|▉         | 50/512 [01:25<12:37,  1.64s/it]
data 1:  10%|▉         | 50/512 [01:26<13:17,  1.73s/it]
INFO:root:函数头: 
def convert_to_idn(url):

INFO:root:目标函数体: 
    
    # this function should only be called with a unicode string
    # strategy: if the host cannot be encoded in ascii, then
    # it'll be necessary to encode it in idn form
    parts = list(urllib.parse.urlsplit(url))
    try:
        parts[1].encode('ascii')
    except UnicodeEncodeError:
        # the url needs to be converted to idn notation
        host = parts[1].rsplit(':', 1)
        newhost = []
        port = ''
        if len(host) == 2:
            port = host.pop()
        for h in host[0].split('.'):
            newhost.append(h.encode('idna').decode('utf-8'))
        parts[1] = '.'.join(newhost)
        if port:
            parts[1] += ':' + port
        return urllib.parse.urlunsplit(parts)
    else:
        return url

INFO:root:生成结果: 
    try:
        return urllib.parse.urlparse(url).netloc.encode('idna').decode('ascii')
    except UnicodeEncodeError:
        return urllib.parse.urlparse(url).netloc.encode('idna').decode('utf-8')




INFO:root:----------------------------------------
INFO:root:max length: 5073
INFO:root:max position: 5073
INFO:root:target_namespace: feedparser.feedparser<folder>.urls<file>.convert_to_idn<func>
INFO:root:****************************************

data 1:   0%|          | 0/512 [00:00<?, ?it/s]
data 1:   2%|▏         | 10/512 [00:15<12:56,  1.55s/it]
data 1:   4%|▍         | 20/512 [00:30<12:36,  1.54s/it]
data 1:   6%|▌         | 30/512 [00:46<12:35,  1.57s/it]
data 1:   6%|▌         | 30/512 [00:51<13:44,  1.71s/it]
INFO:root:函数头: 
def convert_to_idn(url):

INFO:root:目标函数体: 
    
    # this function should only be called with a unicode string
    # strategy: if the host cannot be encoded in ascii, then
    # it'll be necessary to encode it in idn form
    parts = list(urllib.parse.urlsplit(url))
    try:
        parts[1].encode('ascii')
    except UnicodeEncodeError:
        # the url needs to be converted to idn notation
        host = parts[1].rsplit(':', 1)
        newhost = []
        port = ''
        if len(host) == 2:
            port = host.pop()
        for h in host[0].split('.'):
            newhost.append(h.encode('idna').decode('utf-8'))
        parts[1] = '.'.join(newhost)
        if port:
            parts[1] += ':' + port
        return urllib.parse.urlunsplit(parts)
    else:
        return url

INFO:root:生成结果: 
    import idna
    try:
        return idna.encode(url).decode('ascii')
    except idna.InvalidDomainName:
        return url


INFO:root:----------------------------------------
INFO:root:max length: 5054
INFO:root:max position: 5054
INFO:root:target_namespace: feedparser.feedparser<folder>.urls<file>.convert_to_idn<func>
INFO:root:****************************************

data 1:   0%|          | 0/512 [00:00<?, ?it/s]
data 1:   2%|▏         | 10/512 [00:15<13:08,  1.57s/it]
data 1:   4%|▍         | 20/512 [00:29<11:51,  1.45s/it]
data 1:   6%|▌         | 30/512 [00:47<12:50,  1.60s/it]
data 1:   6%|▌         | 30/512 [00:51<13:49,  1.72s/it]
INFO:root:函数头: 
def convert_to_idn(url):

INFO:root:目标函数体: 
    
    # this function should only be called with a unicode string
    # strategy: if the host cannot be encoded in ascii, then
    # it'll be necessary to encode it in idn form
    parts = list(urllib.parse.urlsplit(url))
    try:
        parts[1].encode('ascii')
    except UnicodeEncodeError:
        # the url needs to be converted to idn notation
        host = parts[1].rsplit(':', 1)
        newhost = []
        port = ''
        if len(host) == 2:
            port = host.pop()
        for h in host[0].split('.'):
            newhost.append(h.encode('idna').decode('utf-8'))
        parts[1] = '.'.join(newhost)
        if port:
            parts[1] += ':' + port
        return urllib.parse.urlunsplit(parts)
    else:
        return url

INFO:root:生成结果: 
    import idna
    try:
        return idna.encode(url).decode('ascii')
    except idna.IDNAError:
        return url


INFO:root:----------------------------------------
INFO:root:max length: 5054
INFO:root:max position: 5054
INFO:root:target_namespace: feedparser.feedparser<folder>.urls<file>.convert_to_idn<func>
INFO:root:****************************************

data 1:   0%|          | 0/512 [00:00<?, ?it/s]
data 1:   2%|▏         | 10/512 [00:13<11:18,  1.35s/it]
data 1:   4%|▍         | 20/512 [00:29<12:05,  1.47s/it]
data 1:   4%|▍         | 20/512 [00:44<18:06,  2.21s/it]
INFO:root:函数头: 
def convert_to_idn(url):

INFO:root:目标函数体: 
    
    # this function should only be called with a unicode string
    # strategy: if the host cannot be encoded in ascii, then
    # it'll be necessary to encode it in idn form
    parts = list(urllib.parse.urlsplit(url))
    try:
        parts[1].encode('ascii')
    except UnicodeEncodeError:
        # the url needs to be converted to idn notation
        host = parts[1].rsplit(':', 1)
        newhost = []
        port = ''
        if len(host) == 2:
            port = host.pop()
        for h in host[0].split('.'):
            newhost.append(h.encode('idna').decode('utf-8'))
        parts[1] = '.'.join(newhost)
        if port:
            parts[1] += ':' + port
        return urllib.parse.urlunsplit(parts)
    else:
        return url

INFO:root:生成结果: 
    try:
        import idna
        return idna.encode(url).decode('ascii')
    except ImportError:
        return url




INFO:root:----------------------------------------
INFO:root:max length: 5051
INFO:root:max position: 5051
INFO:root:target_namespace: feedparser.feedparser<folder>.urls<file>.convert_to_idn<func>
INFO:root:****************************************

data 1:   0%|          | 0/512 [00:00<?, ?it/s]
data 1:   2%|▏         | 10/512 [00:15<12:49,  1.53s/it]
data 1:   4%|▍         | 20/512 [00:30<12:32,  1.53s/it]
data 1:   6%|▌         | 30/512 [00:46<12:38,  1.57s/it]
data 1:   6%|▌         | 30/512 [00:53<14:16,  1.78s/it]
INFO:root:函数头: 
def convert_to_idn(url):

INFO:root:目标函数体: 
    
    # this function should only be called with a unicode string
    # strategy: if the host cannot be encoded in ascii, then
    # it'll be necessary to encode it in idn form
    parts = list(urllib.parse.urlsplit(url))
    try:
        parts[1].encode('ascii')
    except UnicodeEncodeError:
        # the url needs to be converted to idn notation
        host = parts[1].rsplit(':', 1)
        newhost = []
        port = ''
        if len(host) == 2:
            port = host.pop()
        for h in host[0].split('.'):
            newhost.append(h.encode('idna').decode('utf-8'))
        parts[1] = '.'.join(newhost)
        if port:
            parts[1] += ':' + port
        return urllib.parse.urlunsplit(parts)
    else:
        return url

INFO:root:生成结果: 
    import idna
    try:
        return idna.encode(url).decode('ascii')
    except idna.InvalidDomainName:
        return url




INFO:root:----------------------------------------
INFO:root:max length: 5055
INFO:root:max position: 5055
INFO:root:target_namespace: feedparser.feedparser<folder>.urls<file>.convert_to_idn<func>
INFO:root:****************************************
INFO:root:--------data 2--------

data 2:   0%|          | 0/512 [00:00<?, ?it/s]
data 2:   2%|▏         | 10/512 [00:08<07:08,  1.17it/s]
data 2:   4%|▍         | 20/512 [00:16<06:45,  1.21it/s]
data 2:   6%|▌         | 30/512 [00:24<06:34,  1.22it/s]
data 2:   8%|▊         | 40/512 [00:32<06:25,  1.22it/s]
data 2:  10%|▉         | 50/512 [00:42<06:44,  1.14it/s]
data 2:  12%|█▏        | 60/512 [00:51<06:30,  1.16it/s]
data 2:  14%|█▎        | 70/512 [00:59<06:16,  1.17it/s]
data 2:  16%|█▌        | 80/512 [01:07<06:06,  1.18it/s]
data 2:  18%|█▊        | 90/512 [01:15<05:53,  1.19it/s]
data 2:  20%|█▉        | 100/512 [01:24<05:45,  1.19it/s]
data 2:  21%|██▏       | 110/512 [01:32<05:34,  1.20it/s]
data 2:  23%|██▎       | 120/512 [01:40<05:28,  1.19it/s]
data 2:  25%|██▌       | 130/512 [01:50<05:37,  1.13it/s]
data 2:  27%|██▋       | 140/512 [01:58<05:20,  1.16it/s]
data 2:  29%|██▉       | 150/512 [02:06<05:04,  1.19it/s]
data 2:  29%|██▉       | 150/512 [02:14<05:23,  1.12it/s]
INFO:root:函数头: 
def add_toc_hook(md, min_level=1, max_level=3, heading_id=None):

INFO:root:目标函数体: 
    
    if heading_id is None:
        def heading_id(token, index):
            return 'toc_' + str(index + 1)

    def toc_hook(md, state):
        # Omit body code

    md.before_render_hooks.append(toc_hook)

INFO:root:生成结果: 
    def _hook():
        env = md._env  # access the environment of the Markdown instance
        env['toc'] = []

        def _heading_parser(match):
            level = match.group(1)
            text = match.group(2)
            id = match.group(3) if heading_id else None

            env['toc'].append({
                'level': level,
                'text': text,
                'id': id,
            })

            return ''

        # Add a hook to parse headings
        md.inline_rules['heading'] = [
            (r'^#{1,' + str(max_level) + '} *(.*)$', _heading_parser),
        ]

    # Add the hook to the Markdown instance
    md.register_rule('_hook', _hook)




INFO:root:----------------------------------------
INFO:root:max length: 1860
INFO:root:max position: 1860
INFO:root:target_namespace: mistune.src<folder>.mistune<folder>.toc<file>.add_toc_hook<func>
INFO:root:****************************************

data 2:   0%|          | 0/512 [00:00<?, ?it/s]
data 2:   2%|▏         | 10/512 [00:07<06:29,  1.29it/s]
data 2:   4%|▍         | 20/512 [00:16<06:46,  1.21it/s]
data 2:   6%|▌         | 30/512 [00:24<06:37,  1.21it/s]
data 2:   8%|▊         | 40/512 [00:32<06:31,  1.21it/s]
data 2:  10%|▉         | 50/512 [00:41<06:21,  1.21it/s]
data 2:  12%|█▏        | 60/512 [00:50<06:37,  1.14it/s]
data 2:  14%|█▎        | 70/512 [00:59<06:18,  1.17it/s]
data 2:  16%|█▌        | 80/512 [01:07<06:01,  1.19it/s]
data 2:  18%|█▊        | 90/512 [01:14<05:47,  1.22it/s]
data 2:  20%|█▉        | 100/512 [01:25<06:05,  1.13it/s]
data 2:  21%|██▏       | 110/512 [01:33<05:48,  1.15it/s]
data 2:  21%|██▏       | 110/512 [01:36<05:51,  1.14it/s]
INFO:root:函数头: 
def add_toc_hook(md, min_level=1, max_level=3, heading_id=None):

INFO:root:目标函数体: 
    
    if heading_id is None:
        def heading_id(token, index):
            return 'toc_' + str(index + 1)

    def toc_hook(md, state):
        # Omit body code

    md.before_render_hooks.append(toc_hook)

INFO:root:生成结果: 
    def toc_hook(match):
        level = match.group(1)
        text = match.group(2)
        id = match.group(3)

        if int(level) >= min_level and int(level) <= max_level:
            if id is None:
                id = heading_id(text)

            env = md.state.env
            env.setdefault('toc', []).append((level, text, id))

    md.inlinepatterns.add('toc', re.compile(r'(?:\#{1,6})+(?:\s+)(.*)'), 5)




INFO:root:----------------------------------------
INFO:root:max length: 1815
INFO:root:max position: 1815
INFO:root:target_namespace: mistune.src<folder>.mistune<folder>.toc<file>.add_toc_hook<func>
INFO:root:****************************************

data 2:   0%|          | 0/512 [00:00<?, ?it/s]
data 2:   2%|▏         | 10/512 [00:07<06:13,  1.34it/s]
data 2:   4%|▍         | 20/512 [00:16<06:52,  1.19it/s]
data 2:   6%|▌         | 30/512 [00:24<06:32,  1.23it/s]
data 2:   8%|▊         | 40/512 [00:32<06:21,  1.24it/s]
data 2:  10%|▉         | 50/512 [00:40<06:13,  1.24it/s]
data 2:  12%|█▏        | 60/512 [00:48<06:04,  1.24it/s]
data 2:  14%|█▎        | 70/512 [00:56<05:59,  1.23it/s]
data 2:  16%|█▌        | 80/512 [01:04<05:50,  1.23it/s]
data 2:  18%|█▊        | 90/512 [01:13<05:45,  1.22it/s]
data 2:  20%|█▉        | 100/512 [01:22<05:58,  1.15it/s]
data 2:  21%|██▏       | 110/512 [01:31<05:47,  1.16it/s]
data 2:  23%|██▎       | 120/512 [01:40<05:38,  1.16it/s]
data 2:  25%|██▌       | 130/512 [01:49<05:43,  1.11it/s]
data 2:  27%|██▋       | 140/512 [01:58<05:25,  1.14it/s]
data 2:  29%|██▉       | 150/512 [02:06<05:07,  1.18it/s]
data 2:  31%|███▏      | 160/512 [02:14<04:55,  1.19it/s]
data 2:  33%|███▎      | 170/512 [02:22<04:50,  1.18it/s]
data 2:  35%|███▌      | 180/512 [02:32<04:48,  1.15it/s]
data 2:  37%|███▋      | 190/512 [02:40<04:33,  1.18it/s]
data 2:  39%|███▉      | 200/512 [02:48<04:22,  1.19it/s]
data 2:  39%|███▉      | 200/512 [02:50<04:25,  1.17it/s]
INFO:root:函数头: 
def add_toc_hook(md, min_level=1, max_level=3, heading_id=None):

INFO:root:目标函数体: 
    
    if heading_id is None:
        def heading_id(token, index):
            return 'toc_' + str(index + 1)

    def toc_hook(md, state):
        # Omit body code

    md.before_render_hooks.append(toc_hook)

INFO:root:生成结果: 
    def toc_hook(markdown):
        # Get all headings from the current document
        headings = []
        for heading in markdown.parser.root.findall('heading'):
            level = int(heading.attrib.get('level'))
            if level >= min_level and level <= max_level:
                text = striptags(heading.text)
                if heading_id:
                    id = heading_id(text)
                else:
                    id = None
                headings.append((level, text, id))

        # Sort headings by level and text
        headings.sort(key=lambda x: (x[0], x[1]))

        # Save TOC items into state.env
        env = markdown.parser.env
        env['toc'] = [{'level': level, 'text': text, 'id': id} for level, text, id in headings]

    # Add the hook to the markdown instance
    md.register_rule('toc', toc_hook)

    # Return the modified markdown instance
    return md




INFO:root:----------------------------------------
INFO:root:max length: 1903
INFO:root:max position: 1903
INFO:root:target_namespace: mistune.src<folder>.mistune<folder>.toc<file>.add_toc_hook<func>
INFO:root:****************************************

data 2:   0%|          | 0/512 [00:00<?, ?it/s]
data 2:   2%|▏         | 10/512 [00:07<06:34,  1.27it/s]
data 2:   4%|▍         | 20/512 [00:15<06:31,  1.26it/s]
data 2:   6%|▌         | 30/512 [00:23<06:24,  1.25it/s]
data 2:   8%|▊         | 40/512 [00:31<06:15,  1.26it/s]
data 2:  10%|▉         | 50/512 [00:40<06:18,  1.22it/s]
data 2:  12%|█▏        | 60/512 [00:49<06:23,  1.18it/s]
data 2:  14%|█▎        | 70/512 [00:57<06:15,  1.18it/s]
data 2:  16%|█▌        | 80/512 [01:06<06:03,  1.19it/s]
data 2:  18%|█▊        | 90/512 [01:14<05:51,  1.20it/s]
data 2:  20%|█▉        | 100/512 [01:24<06:03,  1.13it/s]
data 2:  21%|██▏       | 110/512 [01:32<05:45,  1.16it/s]
data 2:  21%|██▏       | 110/512 [01:37<05:57,  1.12it/s]
INFO:root:函数头: 
def add_toc_hook(md, min_level=1, max_level=3, heading_id=None):

INFO:root:目标函数体: 
    
    if heading_id is None:
        def heading_id(token, index):
            return 'toc_' + str(index + 1)

    def toc_hook(md, state):
        # Omit body code

    md.before_render_hooks.append(toc_hook)

INFO:root:生成结果: 
    def toc_hook(parser):
        env = parser.state.env
        env['toc'] = []

        def visit_heading(self, _, level, text):
            if level >= min_level and level <= max_level:
                if heading_id:
                    id = heading_id(text)
                else:
                    id = text.lower().replace(' ', '-')
                env['toc'].append({
                    'level': level,
                    'text': text,
                    'id': id,
                })

        parser.inline_rules['heading'] = visit_heading

    md.register_rule('toc', toc_hook)


INFO:root:----------------------------------------
INFO:root:max length: 1820
INFO:root:max position: 1820
INFO:root:target_namespace: mistune.src<folder>.mistune<folder>.toc<file>.add_toc_hook<func>
INFO:root:****************************************

data 2:   0%|          | 0/512 [00:00<?, ?it/s]
data 2:   2%|▏         | 10/512 [00:08<07:28,  1.12it/s]
data 2:   4%|▍         | 20/512 [00:18<07:47,  1.05it/s]
data 2:   6%|▌         | 30/512 [00:27<07:11,  1.12it/s]
data 2:   8%|▊         | 40/512 [00:35<06:50,  1.15it/s]
data 2:  10%|▉         | 50/512 [00:45<07:07,  1.08it/s]
data 2:  12%|█▏        | 60/512 [00:54<06:45,  1.11it/s]
data 2:  14%|█▎        | 70/512 [01:02<06:30,  1.13it/s]
data 2:  16%|█▌        | 80/512 [01:11<06:15,  1.15it/s]
data 2:  18%|█▊        | 90/512 [01:21<06:26,  1.09it/s]
data 2:  20%|█▉        | 100/512 [01:29<06:06,  1.12it/s]
data 2:  21%|██▏       | 110/512 [01:37<05:51,  1.14it/s]
data 2:  23%|██▎       | 120/512 [01:46<05:39,  1.16it/s]
data 2:  25%|██▌       | 130/512 [01:56<05:46,  1.10it/s]
data 2:  27%|██▋       | 140/512 [02:04<05:30,  1.13it/s]
data 2:  29%|██▉       | 150/512 [02:13<05:15,  1.15it/s]
data 2:  31%|███▏      | 160/512 [02:23<05:22,  1.09it/s]
data 2:  33%|███▎      | 170/512 [02:31<05:03,  1.13it/s]
data 2:  35%|███▌      | 180/512 [02:39<04:48,  1.15it/s]
data 2:  37%|███▋      | 190/512 [02:48<04:35,  1.17it/s]
data 2:  39%|███▉      | 200/512 [02:58<04:39,  1.12it/s]
data 2:  41%|████      | 210/512 [03:06<04:26,  1.13it/s]
data 2:  43%|████▎     | 220/512 [03:14<04:13,  1.15it/s]
data 2:  45%|████▍     | 230/512 [03:24<04:13,  1.11it/s]
data 2:  47%|████▋     | 240/512 [03:32<03:58,  1.14it/s]
data 2:  49%|████▉     | 250/512 [03:42<03:53,  1.12it/s]
data 2:  51%|█████     | 260/512 [03:52<03:55,  1.07it/s]
data 2:  53%|█████▎    | 270/512 [04:00<03:38,  1.11it/s]
data 2:  55%|█████▍    | 280/512 [04:09<03:24,  1.13it/s]
data 2:  57%|█████▋    | 290/512 [04:16<03:09,  1.17it/s]
data 2:  59%|█████▊    | 300/512 [04:25<02:58,  1.19it/s]
data 2:  61%|██████    | 310/512 [04:33<02:49,  1.19it/s]
data 2:  62%|██████▎   | 320/512 [04:43<02:50,  1.13it/s]
data 2:  64%|██████▍   | 330/512 [04:52<02:39,  1.14it/s]
data 2:  66%|██████▋   | 340/512 [05:00<02:31,  1.14it/s]
data 2:  68%|██████▊   | 350/512 [05:09<02:20,  1.15it/s]
data 2:  70%|███████   | 360/512 [05:19<02:17,  1.11it/s]
data 2:  72%|███████▏  | 370/512 [05:27<02:04,  1.14it/s]
data 2:  74%|███████▍  | 380/512 [05:35<01:52,  1.17it/s]
data 2:  76%|███████▌  | 390/512 [05:45<01:49,  1.12it/s]
data 2:  78%|███████▊  | 400/512 [05:53<01:37,  1.15it/s]
data 2:  80%|████████  | 410/512 [06:01<01:26,  1.17it/s]
data 2:  82%|████████▏ | 420/512 [06:09<01:16,  1.20it/s]
data 2:  84%|████████▍ | 430/512 [06:19<01:13,  1.12it/s]
data 2:  86%|████████▌ | 440/512 [06:27<01:01,  1.18it/s]
data 2:  88%|████████▊ | 450/512 [06:35<00:52,  1.17it/s]
data 2:  90%|████████▉ | 460/512 [06:41<00:40,  1.28it/s]
data 2:  92%|█████████▏| 470/512 [06:51<00:34,  1.21it/s]
data 2:  94%|█████████▍| 480/512 [06:57<00:25,  1.28it/s]
data 2:  96%|█████████▌| 490/512 [07:06<00:17,  1.24it/s]
data 2:  98%|█████████▊| 500/512 [07:14<00:09,  1.25it/s]
data 2: 100%|█████████▉| 510/512 [07:20<00:01,  1.35it/s]
data 2: 100%|█████████▉| 510/512 [07:23<00:01,  1.15it/s]
INFO:root:函数头: 
def add_toc_hook(md, min_level=1, max_level=3, heading_id=None):

INFO:root:目标函数体: 
    
    if heading_id is None:
        def heading_id(token, index):
            return 'toc_' + str(index + 1)

    def toc_hook(md, state):
        # Omit body code

    md.before_render_hooks.append(toc_hook)

INFO:root:生成结果: 
    def toc_hook(match):
        level = match.group(1)
        title = match.group(2)
        id = match.group(3) if heading_id else None

        # Create TOC item
        toc_item = {
            'level': level,
            'title': title,
            'id': id,
        }

        # Save TOC item into state.env
        state.env['toc'] = state.env.get('toc', []) + [toc_item]

    # Add hook to the parser
    md.parser.rules['heading'] = [
        ('^#{1,' + str(max_level) + '}\\s+(.*)$', toc_hook),
    ]

    # Add hook to the parser
    md.parser.rules['block'] = [
        ('^(\\s*)\\n$', toc_hook),
    ]

    # Add hook to the parser
    md.parser.rules['block'] = [
        ('^(\\s*)\\n$', toc_hook),
    ]

    # Add hook to the parser
    md.parser.rules['block'] = [
        ('^(\\s*)\\n$', toc_hook),
    ]

    # Add hook to the parser
    md.parser.rules['block'] = [
        ('^(\\s*)\\n$', toc_hook),
    ]

    # Add hook to the parser
    md.parser.rules['block'] = [
        ('^(\\s*)\\n$', toc_hook),
    ]

    # Add hook to the parser
    md.parser.rules['block'] = [
        ('^(\\s*)\\n$', toc_hook),
    ]

    # Add hook to the parser
    md.parser.rules['block'] = [
        ('^(\\s*)\\n$', toc_hook),
    ]

    # Add hook to the parser
    md.parser.rules['block'] = [
        ('^(\\s*)\\n$', toc_hook),
    ]

    # Add hook to the parser
    md.parser.rules['block'] = [
        ('^(\\s*)\\n$', toc_hook),
    ]

    # Add hook to the parser
    md.parser.rules['block'] = [
        ('^(\\s*)\\n$', toc_hook),
    ]

    # Add hook to the parser
    md.parser.rules['block'] = [
        ('^(\\s*)\\n$', toc_hook),
    ]

    # Add hook to the parser
    md.parser.rules['block'] = [
        ('^(\\s*)\\n$', toc_hook),
    ]

    # Add

INFO:root:----------------------------------------
INFO:root:max length: 2215
INFO:root:max position: 2215
INFO:root:target_namespace: mistune.src<folder>.mistune<folder>.toc<file>.add_toc_hook<func>
INFO:root:****************************************
INFO:root:--------data 3--------

data 3:   0%|          | 0/512 [00:00<?, ?it/s]
data 3:   2%|▏         | 10/512 [01:46<1:28:57, 10.63s/it]
data 3:   4%|▍         | 20/512 [03:46<1:34:00, 11.47s/it]
data 3:   6%|▌         | 30/512 [05:48<1:34:36, 11.78s/it]
data 3:   8%|▊         | 40/512 [07:45<1:32:24, 11.75s/it]
data 3:  10%|▉         | 50/512 [09:49<1:32:11, 11.97s/it]
data 3:  12%|█▏        | 60/512 [11:46<1:29:31, 11.88s/it]
data 3:  14%|█▎        | 70/512 [13:45<1:27:42, 11.91s/it]
data 3:  16%|█▌        | 80/512 [15:39<1:24:30, 11.74s/it]
data 3:  18%|█▊        | 90/512 [17:34<1:22:06, 11.67s/it]
data 3:  20%|█▉        | 100/512 [19:38<1:21:36, 11.88s/it]
data 3:  21%|██▏       | 110/512 [21:37<1:19:37, 11.89s/it]
data 3:  23%|██▎       | 120/512 [23:37<1:18:00, 11.94s/it]
data 3:  23%|██▎       | 120/512 [24:13<1:19:08, 12.11s/it]
INFO:root:函数头: 
def table_in_quote(md):

INFO:root:目标函数体: 
    
    md.block.insert_rule(md.block.block_quote_rules, 'table', before='paragraph')
    md.block.insert_rule(md.block.block_quote_rules, 'nptable', before='paragraph')

INFO:root:生成结果: 
    # Get the block quote rule
    blockquote_rule = md.block_rules['blockquote']
    # Get the paragraph rule
    paragraph_rule = md.block_rules['paragraph']

    # Insert rules for table and nptable before the paragraph rule
    blockquote_rule.rules.insert(blockquote_rule.rules.index('paragraph'), 'table')
    blockquote_rule.rules.insert(blockquote_rule.rules.index('paragraph'), 'nptable')

    # Register the new rules
    md.block_rules['table'] = table_rule
    md.block_rules['nptable'] = nptable_rule




INFO:root:----------------------------------------
INFO:root:max length: 9741
INFO:root:max position: 13215
INFO:root:target_namespace: mistune.src<folder>.mistune<folder>.plugins<folder>.table<file>.table_in_quote<func>
INFO:root:****************************************

data 3:   0%|          | 0/512 [00:00<?, ?it/s]
data 3:   2%|▏         | 10/512 [01:47<1:29:49, 10.74s/it]
data 3:   4%|▍         | 20/512 [03:45<1:33:23, 11.39s/it]
data 3:   6%|▌         | 30/512 [05:42<1:32:22, 11.50s/it]
data 3:   8%|▊         | 40/512 [07:37<1:30:42, 11.53s/it]
data 3:  10%|▉         | 50/512 [09:32<1:28:27, 11.49s/it]
data 3:  12%|█▏        | 60/512 [11:25<1:26:12, 11.44s/it]
data 3:  14%|█▎        | 70/512 [13:18<1:23:49, 11.38s/it]
data 3:  16%|█▌        | 80/512 [15:15<1:22:50, 11.51s/it]
data 3:  18%|█▊        | 90/512 [17:12<1:21:18, 11.56s/it]
data 3:  20%|█▉        | 100/512 [19:11<1:20:03, 11.66s/it]
data 3:  21%|██▏       | 110/512 [21:05<1:17:30, 11.57s/it]
data 3:  23%|██▎       | 120/512 [22:51<1:13:47, 11.29s/it]
data 3:  25%|██▌       | 130/512 [24:46<1:12:18, 11.36s/it]
data 3:  27%|██▋       | 140/512 [26:42<1:10:53, 11.43s/it]
data 3:  29%|██▉       | 150/512 [28:29<1:07:37, 11.21s/it]
data 3:  31%|███▏      | 160/512 [30:23<1:06:07, 11.27s/it]
data 3:  33%|███▎      | 170/512 [32:22<1:05:12, 11.44s/it]
data 3:  35%|███▌      | 180/512 [34:14<1:02:53, 11.36s/it]
data 3:  37%|███▋      | 190/512 [36:03<1:00:14, 11.23s/it]
data 3:  39%|███▉      | 200/512 [37:58<58:49, 11.31s/it]  
data 3:  41%|████      | 210/512 [39:53<57:14, 11.37s/it]
data 3:  43%|████▎     | 220/512 [41:44<54:54, 11.28s/it]
data 3:  45%|████▍     | 230/512 [43:31<52:14, 11.12s/it]
data 3:  47%|████▋     | 240/512 [45:19<50:01, 11.04s/it]
data 3:  49%|████▉     | 250/512 [47:13<48:38, 11.14s/it]
data 3:  51%|█████     | 260/512 [49:02<46:29, 11.07s/it]
data 3:  53%|█████▎    | 270/512 [50:58<45:17, 11.23s/it]
data 3:  55%|█████▍    | 280/512 [52:44<42:42, 11.05s/it]
data 3:  57%|█████▋    | 290/512 [54:38<41:14, 11.15s/it]
data 3:  59%|█████▊    | 300/512 [56:35<39:58, 11.31s/it]
data 3:  61%|██████    | 310/512 [58:29<38:07, 11.32s/it]
data 3:  62%|██████▎   | 320/512 [1:00:34<37:20, 11.67s/it]
data 3:  64%|██████▍   | 330/512 [1:02:28<35:09, 11.59s/it]
data 3:  66%|██████▋   | 340/512 [1:04:18<32:44, 11.42s/it]
data 3:  68%|██████▊   | 350/512 [1:06:08<30:31, 11.31s/it]
data 3:  70%|███████   | 360/512 [1:08:01<28:38, 11.30s/it]
data 3:  72%|███████▏  | 370/512 [1:09:54<26:45, 11.30s/it]
data 3:  74%|███████▍  | 380/512 [1:11:55<25:22, 11.54s/it]
data 3:  76%|███████▌  | 390/512 [1:13:46<23:12, 11.42s/it]
data 3:  78%|███████▊  | 400/512 [1:15:43<21:25, 11.48s/it]
data 3:  80%|████████  | 410/512 [1:17:37<19:30, 11.48s/it]
data 3:  82%|████████▏ | 420/512 [1:19:38<17:51, 11.65s/it]
data 3:  84%|████████▍ | 430/512 [1:21:34<15:54, 11.64s/it]
data 3:  86%|████████▌ | 440/512 [1:23:32<14:00, 11.68s/it]
data 3:  88%|████████▊ | 450/512 [1:25:25<11:56, 11.56s/it]
data 3:  90%|████████▉ | 460/512 [1:27:15<09:52, 11.39s/it]
data 3:  92%|█████████▏| 470/512 [1:29:05<07:53, 11.28s/it]
data 3:  94%|█████████▍| 480/512 [1:30:56<05:59, 11.23s/it]
data 3:  96%|█████████▌| 490/512 [1:32:47<04:05, 11.18s/it]
data 3:  98%|█████████▊| 500/512 [1:34:42<02:15, 11.29s/it]
data 3: 100%|█████████▉| 510/512 [1:36:35<00:22, 11.28s/it]
data 3: 100%|█████████▉| 510/512 [1:37:06<00:22, 11.42s/it]
INFO:root:函数头: 
def table_in_quote(md):

INFO:root:目标函数体: 
    
    md.block.insert_rule(md.block.block_quote_rules, 'table', before='paragraph')
    md.block.insert_rule(md.block.block_quote_rules, 'nptable', before='paragraph')

INFO:root:生成结果: 
    if md.block_rules['blockquote']['pattern'] is None:
        return

    original_pattern = md.block_rules['blockquote']['pattern']
    original_handler = md.block_rules['blockquote']['handler']

    def new_handler(block):
        if block.startswith('>'):
            pos = block.find('\n')
            if pos != -1:
                block = block[pos:]
                block = original_handler(block)
                block = block.replace('\n', '<br>\n')
                block = block.replace('\n', '<br>\n')
                block = block.replace('\n', '<br>\n')
                block = block.replace('\n', '<br>\n')
                block = block.replace('\n', '<br>\n')
                block = block.replace('\n', '<br>\n')
                block = block.replace('\n', '<br>\n')
                block = block.replace('\n', '<br>\n')
                block = block.replace('\n', '<br>\n')
                block = block.replace('\n', '<br>\n')
                block = block.replace('\n', '<br>\n')
                block = block.replace('\n', '<br>\n')
                block = block.replace('\n', '<br>\n')
                block = block.replace('\n', '<br>\n')
                block = block.replace('\n', '<br>\n')
                block = block.replace('\n', '<br>\n')
                block = block.replace('\n', '<br>\n')
                block = block.replace('\n', '<br>\n')
                block = block.replace('\n', '<br>\n')
                block = block.replace('\n', '<br>\n')
                block = block.replace('\n', '<br>\n')
                block = block.replace('\n', '<br>\n')
                block = block.replace('\n', '<br>\n')
                block = block.replace('\n', '<br>\n')
                block = block.replace('\n', '<br>\n')
                block = block.replace('\n', '<br>\n')
                block = block.replace('\n', '<br>\n')
                block = block.replace('\n', '<br>\n')
                block = block.replace('\n', '<br>\n')
                block = block.replace('\n', '<br>\n')
                block = block.replace('\n', '<br>\n')
                block = block.replace('\n', '<br>\n')
                block = block.replace('\n', '<br>\n')


INFO:root:----------------------------------------
INFO:root:max length: 11116
INFO:root:max position: 13795
INFO:root:target_namespace: mistune.src<folder>.mistune<folder>.plugins<folder>.table<file>.table_in_quote<func>
INFO:root:****************************************

data 3:   0%|          | 0/512 [00:00<?, ?it/s]
data 3:   2%|▏         | 10/512 [01:38<1:22:00,  9.80s/it]
data 3:   4%|▍         | 20/512 [03:38<1:31:01, 11.10s/it]
data 3:   6%|▌         | 30/512 [05:29<1:29:25, 11.13s/it]
data 3:   8%|▊         | 40/512 [07:19<1:27:11, 11.08s/it]
data 3:  10%|▉         | 50/512 [09:16<1:26:48, 11.27s/it]
data 3:  12%|█▏        | 60/512 [11:03<1:23:30, 11.08s/it]
data 3:  14%|█▎        | 70/512 [12:50<1:20:46, 10.96s/it]
data 3:  16%|█▌        | 80/512 [14:46<1:20:28, 11.18s/it]
data 3:  18%|█▊        | 90/512 [16:35<1:17:58, 11.09s/it]
data 3:  20%|█▉        | 100/512 [18:22<1:15:21, 10.97s/it]
data 3:  21%|██▏       | 110/512 [20:13<1:13:47, 11.01s/it]
data 3:  23%|██▎       | 120/512 [22:05<1:12:14, 11.06s/it]
data 3:  23%|██▎       | 120/512 [23:23<1:16:26, 11.70s/it]
INFO:root:函数头: 
def table_in_quote(md):

INFO:root:目标函数体: 
    
    md.block.insert_rule(md.block.block_quote_rules, 'table', before='paragraph')
    md.block.insert_rule(md.block.block_quote_rules, 'nptable', before='paragraph')

INFO:root:生成结果: 
    if md.block_rules['paragraph']['before']:
        before = md.block_rules['paragraph']['before']
    else:
        before = []

    # Add rules for table and nptable before the paragraph rule
    before.append({
        'pattern': r'^\n',
        'action': lambda m, state: parse_table(m, state)
    })
    before.append({
        'pattern': r'^\n',
        'action': lambda m, state: parse_nptable(m, state)
    })

    # Update the paragraph rule
    md.block_rules['paragraph']['before'] = before


INFO:root:----------------------------------------
INFO:root:max length: 9575
INFO:root:max position: 12629
INFO:root:target_namespace: mistune.src<folder>.mistune<folder>.plugins<folder>.table<file>.table_in_quote<func>
INFO:root:****************************************

data 3:   0%|          | 0/512 [00:00<?, ?it/s]
data 3:   2%|▏         | 10/512 [01:43<1:26:25, 10.33s/it]
data 3:   4%|▍         | 20/512 [03:38<1:30:19, 11.02s/it]
data 3:   6%|▌         | 30/512 [05:35<1:30:59, 11.33s/it]
data 3:   8%|▊         | 40/512 [07:27<1:28:42, 11.28s/it]
data 3:  10%|▉         | 50/512 [09:17<1:26:06, 11.18s/it]
data 3:  12%|█▏        | 60/512 [11:06<1:23:35, 11.10s/it]
data 3:  14%|█▎        | 70/512 [12:50<1:20:06, 10.87s/it]
data 3:  16%|█▌        | 80/512 [14:41<1:18:39, 10.92s/it]
data 3:  18%|█▊        | 90/512 [16:33<1:17:37, 11.04s/it]
data 3:  20%|█▉        | 100/512 [18:22<1:15:29, 10.99s/it]
data 3:  21%|██▏       | 110/512 [20:24<1:15:56, 11.34s/it]
data 3:  23%|██▎       | 120/512 [22:13<1:13:20, 11.23s/it]
data 3:  25%|██▌       | 130/512 [24:06<1:11:30, 11.23s/it]
data 3:  27%|██▋       | 140/512 [25:56<1:09:16, 11.17s/it]
data 3:  29%|██▉       | 150/512 [27:52<1:08:06, 11.29s/it]
data 3:  31%|███▏      | 160/512 [29:44<1:06:11, 11.28s/it]
data 3:  33%|███▎      | 170/512 [31:43<1:05:20, 11.46s/it]
data 3:  35%|███▌      | 180/512 [33:43<1:04:16, 11.62s/it]
data 3:  37%|███▋      | 190/512 [35:38<1:02:14, 11.60s/it]
data 3:  39%|███▉      | 200/512 [37:27<59:04, 11.36s/it]  
data 3:  41%|████      | 210/512 [39:23<57:33, 11.44s/it]
data 3:  43%|████▎     | 220/512 [41:18<55:49, 11.47s/it]
data 3:  45%|████▍     | 230/512 [43:15<54:13, 11.54s/it]
data 3:  47%|████▋     | 240/512 [45:10<52:10, 11.51s/it]
data 3:  49%|████▉     | 250/512 [47:02<49:54, 11.43s/it]
data 3:  51%|█████     | 260/512 [48:58<48:11, 11.47s/it]
data 3:  53%|█████▎    | 270/512 [50:45<45:19, 11.24s/it]
data 3:  55%|█████▍    | 280/512 [52:35<43:10, 11.17s/it]
data 3:  57%|█████▋    | 290/512 [54:35<42:17, 11.43s/it]
data 3:  59%|█████▊    | 300/512 [56:26<39:58, 11.31s/it]
data 3:  61%|██████    | 310/512 [58:20<38:11, 11.34s/it]
data 3:  62%|██████▎   | 320/512 [1:00:14<36:24, 11.38s/it]
data 3:  62%|██████▎   | 320/512 [1:01:43<37:02, 11.57s/it]
INFO:root:函数头: 
def table_in_quote(md):

INFO:root:目标函数体: 
    
    md.block.insert_rule(md.block.block_quote_rules, 'table', before='paragraph')
    md.block.insert_rule(md.block.block_quote_rules, 'nptable', before='paragraph')

INFO:root:生成结果: 
    def _table_in_quote_rule(match):
        text = match.group(0)
        lines = text.splitlines(True)
        lines.insert(1, '|---|---|\n')
        lines.insert(len(lines)-1, '\n')
        return ''.join(lines)

    def _nptable_in_quote_rule(match):
        text = match.group(0)
        lines = text.splitlines(True)
        lines.insert(1, '|---|---|\n')
        lines.insert(len(lines)-1, '\n')
        return ''.join(lines)

    md.block_rules['blockquote'].rules.insert(1, _table_in_quote_rule)
    md.block_rules['blockquote'].rules.insert(len(md.block_rules['blockquote'].rules)-1, _nptable_in_quote_rule)

    def _table_in_code_block_rule(match):
        text = match.group(0)
        lines = text.splitlines(True)
        lines.insert(1, '|---|---|\n')
        lines.insert(len(lines)-1, '\n')
        return ''.join(lines)

    def _nptable_in_code_block_rule(match):
        text = match.group(0)
        lines = text.splitlines(True)
        lines.insert(1, '|---|---|\n')
        lines.insert(len(lines)-1, '\n')
        return ''.join(lines)

    md.block_rules['code_block'].rules.insert(1, _table_in_code_block_rule)
    md.block_rules['code_block'].rules.insert(len(md.block_rules['code_block'].rules)-1, _nptable_in_code_block_rule)




INFO:root:----------------------------------------
INFO:root:max length: 10147
INFO:root:max position: 13493
INFO:root:target_namespace: mistune.src<folder>.mistune<folder>.plugins<folder>.table<file>.table_in_quote<func>
INFO:root:****************************************

data 3:   0%|          | 0/512 [00:00<?, ?it/s]
data 3:   2%|▏         | 10/512 [01:45<1:28:13, 10.55s/it]
data 3:   4%|▍         | 20/512 [03:46<1:33:50, 11.44s/it]
data 3:   6%|▌         | 30/512 [05:44<1:33:12, 11.60s/it]
data 3:   8%|▊         | 40/512 [07:43<1:32:23, 11.74s/it]
data 3:  10%|▉         | 50/512 [09:39<1:30:05, 11.70s/it]
data 3:  12%|█▏        | 60/512 [11:32<1:26:56, 11.54s/it]
data 3:  14%|█▎        | 70/512 [13:23<1:24:01, 11.41s/it]
data 3:  16%|█▌        | 80/512 [15:17<1:22:00, 11.39s/it]
data 3:  18%|█▊        | 90/512 [17:06<1:19:03, 11.24s/it]
data 3:  20%|█▉        | 100/512 [18:59<1:17:19, 11.26s/it]
data 3:  21%|██▏       | 110/512 [20:53<1:15:47, 11.31s/it]
data 3:  23%|██▎       | 120/512 [22:49<1:14:31, 11.41s/it]
data 3:  25%|██▌       | 130/512 [24:49<1:13:45, 11.59s/it]
data 3:  27%|██▋       | 140/512 [26:48<1:12:21, 11.67s/it]
data 3:  29%|██▉       | 150/512 [28:54<1:12:04, 11.95s/it]
data 3:  31%|███▏      | 160/512 [30:49<1:09:24, 11.83s/it]
data 3:  33%|███▎      | 170/512 [32:47<1:07:18, 11.81s/it]
data 3:  35%|███▌      | 180/512 [34:44<1:05:06, 11.77s/it]
data 3:  37%|███▋      | 190/512 [36:48<1:04:11, 11.96s/it]
data 3:  39%|███▉      | 200/512 [38:43<1:01:32, 11.83s/it]
data 3:  41%|████      | 210/512 [40:32<58:11, 11.56s/it]  
data 3:  43%|████▎     | 220/512 [42:27<56:05, 11.52s/it]
data 3:  45%|████▍     | 230/512 [44:23<54:15, 11.55s/it]
data 3:  47%|████▋     | 240/512 [46:12<51:30, 11.36s/it]
data 3:  49%|████▉     | 250/512 [48:06<49:35, 11.36s/it]
data 3:  51%|█████     | 260/512 [49:55<47:06, 11.22s/it]
data 3:  53%|█████▎    | 270/512 [51:53<46:01, 11.41s/it]
data 3:  55%|█████▍    | 280/512 [53:44<43:46, 11.32s/it]
data 3:  57%|█████▋    | 290/512 [55:47<42:59, 11.62s/it]
data 3:  59%|█████▊    | 300/512 [57:41<40:44, 11.53s/it]
data 3:  61%|██████    | 310/512 [59:33<38:33, 11.45s/it]
data 3:  62%|██████▎   | 320/512 [1:01:30<36:50, 11.51s/it]
data 3:  64%|██████▍   | 330/512 [1:03:23<34:46, 11.46s/it]
data 3:  66%|██████▋   | 340/512 [1:05:14<32:32, 11.35s/it]
data 3:  68%|██████▊   | 350/512 [1:07:10<30:48, 11.41s/it]
data 3:  70%|███████   | 360/512 [1:09:11<29:25, 11.62s/it]
data 3:  72%|███████▏  | 370/512 [1:11:11<27:47, 11.74s/it]
data 3:  74%|███████▍  | 380/512 [1:13:06<25:38, 11.66s/it]
data 3:  76%|███████▌  | 390/512 [1:15:05<23:51, 11.73s/it]
data 3:  78%|███████▊  | 400/512 [1:17:03<21:55, 11.75s/it]
data 3:  80%|████████  | 410/512 [1:19:02<20:04, 11.81s/it]
data 3:  82%|████████▏ | 420/512 [1:20:56<17:55, 11.70s/it]
data 3:  84%|████████▍ | 430/512 [1:22:49<15:49, 11.58s/it]
data 3:  86%|████████▌ | 440/512 [1:24:37<13:36, 11.35s/it]
data 3:  88%|████████▊ | 450/512 [1:26:38<11:56, 11.55s/it]
data 3:  90%|████████▉ | 460/512 [1:28:27<09:51, 11.38s/it]
data 3:  92%|█████████▏| 470/512 [1:30:27<08:05, 11.56s/it]
data 3:  94%|█████████▍| 480/512 [1:32:25<06:11, 11.61s/it]
data 3:  96%|█████████▌| 490/512 [1:34:23<04:17, 11.69s/it]
data 3:  98%|█████████▊| 500/512 [1:36:20<02:20, 11.67s/it]
data 3: 100%|█████████▉| 510/512 [1:38:18<00:23, 11.72s/it]
data 3: 100%|█████████▉| 510/512 [1:38:54<00:23, 11.64s/it]
INFO:root:函数头: 
def table_in_quote(md):

INFO:root:目标函数体: 
    
    md.block.insert_rule(md.block.block_quote_rules, 'table', before='paragraph')
    md.block.insert_rule(md.block.block_quote_rules, 'nptable', before='paragraph')

INFO:root:生成结果: 
    # Register table plugin rules
    md.block.register('table', TABLE_PATTERN, parse_table, before='paragraph')
    md.block.register('nptable', NP_TABLE_PATTERN, parse_nptable, before='paragraph')

    # Register table renderers
    if md.renderer and md.renderer.NAME == 'html':
        md.renderer.register('table', render_table)
        md.renderer.register('table_head', render_table_head)
        md.renderer.register('table_body', render_table_body)
        md.renderer.register('table_row', render_table_row)
        md.renderer.register('table_cell', render_table_cell)

    # Register table plugins
    if md.plugins and 'table' not in md.plugins:
        md.plugins.append('table')

    if md.plugins and 'nptable' not in md.plugins:
        md.plugins.append('nptable')

    if md.plugins and 'blockquote' not in md.plugins:
        md.plugins.append('blockquote')

    if md.plugins and 'paragraph' not in md.plugins:
        md.plugins.append('paragraph')

    if md.plugins and 'escape' not in md.plugins:
        md.plugins.append('escape')

    if md.plugins and 'emphasis' not in md.plugins:
        md.plugins.append('emphasis')

    if md.plugins and 'link' not in md.plugins:
        md.plugins.append('link')

    if md.plugins and 'auto_link' not in md.plugins:
        md.plugins.append('auto_link')

    if md.plugins and 'std_linebreak' not in md.plugins:
        md.plugins.append('std_linebreak')

    if md.plugins and 'softbreak' not in md.plugins:
        md.plugins.append('softbreak')

    if md.plugins and 'code_block' not in md.plugins:
        md.plugins.append('code_block')

    if md.plugins and ' fenced_code_block' not in md.plugins:
        md.plugins.append('fenced_code_block')

    if md.plugins and 'autolist' not in md.plugins:
        md.plugins.append('autolist')

    if md.plugins and ' fenced_code_block' not in md.plugins:
        md.plugins.append('fenced_code_block')

    if md.plugins and 'task_lists' not in md.plugins:
        md.plugins.append('task_lists')

    if md.plugins and 'strikeout' not in md.plugins:
        md.plugins.append('strikeout')

    if md.plugins and 'underline' not in md.plugins:
        md.plugins.append('underline')

    if md.plugins and 'math' not in md

INFO:root:----------------------------------------
INFO:root:max length: 10264
INFO:root:max position: 13956
INFO:root:target_namespace: mistune.src<folder>.mistune<folder>.plugins<folder>.table<file>.table_in_quote<func>
INFO:root:****************************************
INFO:root:--------data 4--------

data 4:   0%|          | 0/512 [00:00<?, ?it/s]
data 4:   2%|▏         | 10/512 [01:50<1:32:31, 11.06s/it]
data 4:   4%|▍         | 20/512 [03:43<1:31:59, 11.22s/it]
data 4:   6%|▌         | 30/512 [05:30<1:28:01, 10.96s/it]
data 4:   6%|▌         | 30/512 [07:27<1:59:55, 14.93s/it]
INFO:root:函数头: 
def table_in_list(md):

INFO:root:目标函数体: 
    
    md.block.insert_rule(md.block.list_rules, 'table', before='paragraph')
    md.block.insert_rule(md.block.list_rules, 'nptable', before='paragraph')

INFO:root:生成结果: 
    md.block.insert_rule(md.block.block_list_rules, 'table', before='paragraph')
    md.block.insert_rule(md.block.block_list_rules, 'nptable', before='paragraph')




INFO:root:----------------------------------------
INFO:root:max length: 9946
INFO:root:max position: 13028
INFO:root:target_namespace: mistune.src<folder>.mistune<folder>.plugins<folder>.table<file>.table_in_list<func>
INFO:root:****************************************

data 4:   0%|          | 0/512 [00:00<?, ?it/s]
data 4:   2%|▏         | 10/512 [01:47<1:30:14, 10.79s/it]
data 4:   4%|▍         | 20/512 [03:37<1:29:08, 10.87s/it]
data 4:   6%|▌         | 30/512 [05:25<1:27:02, 10.83s/it]
data 4:   6%|▌         | 30/512 [07:17<1:57:01, 14.57s/it]
INFO:root:函数头: 
def table_in_list(md):

INFO:root:目标函数体: 
    
    md.block.insert_rule(md.block.list_rules, 'table', before='paragraph')
    md.block.insert_rule(md.block.list_rules, 'nptable', before='paragraph')

INFO:root:生成结果: 
    md.block.insert_rule(md.block.block_list_rules, 'table', before='paragraph')
    md.block.insert_rule(md.block.block_list_rules, 'nptable', before='paragraph')


INFO:root:----------------------------------------
INFO:root:max length: 9573
INFO:root:max position: 12574
INFO:root:target_namespace: mistune.src<folder>.mistune<folder>.plugins<folder>.table<file>.table_in_list<func>
INFO:root:****************************************

data 4:   0%|          | 0/512 [00:00<?, ?it/s]
data 4:   2%|▏         | 10/512 [01:39<1:23:19,  9.96s/it]
data 4:   4%|▍         | 20/512 [03:28<1:26:10, 10.51s/it]
data 4:   6%|▌         | 30/512 [05:22<1:27:32, 10.90s/it]
data 4:   8%|▊         | 40/512 [07:12<1:26:02, 10.94s/it]
data 4:   8%|▊         | 40/512 [08:34<1:41:16, 12.87s/it]
INFO:root:函数头: 
def table_in_list(md):

INFO:root:目标函数体: 
    
    md.block.insert_rule(md.block.list_rules, 'table', before='paragraph')
    md.block.insert_rule(md.block.list_rules, 'nptable', before='paragraph')

INFO:root:生成结果: 
    md.block.insert_rule(md.block.block_list_rules, 'table', parse_table, before='paragraph')
    md.block.insert_rule(md.block.block_list_rules, 'nptable', parse_nptable, before='paragraph')


INFO:root:----------------------------------------
INFO:root:max length: 9667
INFO:root:max position: 12921
INFO:root:target_namespace: mistune.src<folder>.mistune<folder>.plugins<folder>.table<file>.table_in_list<func>
INFO:root:****************************************

data 4:   0%|          | 0/512 [00:00<?, ?it/s]
data 4:   2%|▏         | 10/512 [01:47<1:30:15, 10.79s/it]
data 4:   2%|▏         | 10/512 [02:10<1:49:32, 13.09s/it]
INFO:root:函数头: 
def table_in_list(md):

INFO:root:目标函数体: 
    
    md.block.insert_rule(md.block.list_rules, 'table', before='paragraph')
    md.block.insert_rule(md.block.list_rules, 'nptable', before='paragraph')

INFO:root:生成结果: 
    # Your implementation goes here
    pass




INFO:root:----------------------------------------
INFO:root:max length: 8851
INFO:root:max position: 12375
INFO:root:target_namespace: mistune.src<folder>.mistune<folder>.plugins<folder>.table<file>.table_in_list<func>
INFO:root:****************************************

data 4:   0%|          | 0/512 [00:00<?, ?it/s]
data 4:   2%|▏         | 10/512 [01:36<1:20:50,  9.66s/it]
data 4:   4%|▍         | 20/512 [03:25<1:25:05, 10.38s/it]
data 4:   6%|▌         | 30/512 [05:20<1:27:33, 10.90s/it]
data 4:   6%|▌         | 30/512 [07:08<1:54:41, 14.28s/it]
INFO:root:函数头: 
def table_in_list(md):

INFO:root:目标函数体: 
    
    md.block.insert_rule(md.block.list_rules, 'table', before='paragraph')
    md.block.insert_rule(md.block.list_rules, 'nptable', before='paragraph')

INFO:root:生成结果: 
    md.block.insert_rule(md.block.block_list_rules, 'table', before='paragraph')
    md.block.insert_rule(md.block.block_list_rules, 'nptable', before='paragraph')


INFO:root:----------------------------------------
INFO:root:max length: 9562
INFO:root:max position: 13262
INFO:root:target_namespace: mistune.src<folder>.mistune<folder>.plugins<folder>.table<file>.table_in_list<func>
INFO:root:****************************************
INFO:root:--------data 5--------

data 5:   0%|          | 0/512 [00:00<?, ?it/s]
data 5:   2%|▏         | 10/512 [00:14<12:16,  1.47s/it]
data 5:   4%|▍         | 20/512 [00:26<10:43,  1.31s/it]
data 5:   6%|▌         | 30/512 [00:38<10:02,  1.25s/it]
data 5:   8%|▊         | 40/512 [00:50<09:43,  1.24s/it]
data 5:  10%|▉         | 50/512 [01:04<09:59,  1.30s/it]
data 5:  12%|█▏        | 60/512 [01:16<09:34,  1.27s/it]
data 5:  14%|█▎        | 70/512 [01:28<09:10,  1.25s/it]
data 5:  14%|█▎        | 70/512 [01:32<09:41,  1.32s/it]
INFO:root:函数头: 
def parallel_handler(callback: Callable, texts: List[str], n_jobs: int = 2, **kwargs) -> Generator[
    List[Any], None, None
]:

INFO:root:目标函数体: 
    
    if not isinstance(texts, list):
        raise ValueError("You should pass a list of texts")
    if kwargs:
        callback = partial(callback, **kwargs)
    with futures.ThreadPoolExecutor(max_workers=n_jobs) as executor:
        for ret in executor.map(callback, texts):
            yield ret

INFO:root:生成结果: 
    if not isinstance(texts, list):
        raise ValueError("You should pass a list of texts.")
    with futures.ThreadPoolExecutor(max_workers=n_jobs) as executor:
        futures_list = [executor.submit(callback, text, **kwargs) for text in texts]
        for future in futures.as_completed(futures_list):
            yield future.result()


INFO:root:----------------------------------------
INFO:root:max length: 3138
INFO:root:max position: 3138
INFO:root:target_namespace: xmnlp.xmnlp<folder>.utils<folder>.__init__<file>.parallel_handler<func>
INFO:root:****************************************

data 5:   0%|          | 0/512 [00:00<?, ?it/s]
data 5:   2%|▏         | 10/512 [00:11<09:53,  1.18s/it]
data 5:   4%|▍         | 20/512 [00:23<09:51,  1.20s/it]
data 5:   6%|▌         | 30/512 [00:36<09:46,  1.22s/it]
data 5:   8%|▊         | 40/512 [00:48<09:30,  1.21s/it]
data 5:  10%|▉         | 50/512 [00:59<09:11,  1.19s/it]
data 5:  12%|█▏        | 60/512 [01:11<08:58,  1.19s/it]
data 5:  14%|█▎        | 70/512 [01:23<08:46,  1.19s/it]
data 5:  14%|█▎        | 70/512 [01:25<08:57,  1.22s/it]
INFO:root:函数头: 
def parallel_handler(callback: Callable, texts: List[str], n_jobs: int = 2, **kwargs) -> Generator[
    List[Any], None, None
]:

INFO:root:目标函数体: 
    
    if not isinstance(texts, list):
        raise ValueError("You should pass a list of texts")
    if kwargs:
        callback = partial(callback, **kwargs)
    with futures.ThreadPoolExecutor(max_workers=n_jobs) as executor:
        for ret in executor.map(callback, texts):
            yield ret

INFO:root:生成结果: 
    if not isinstance(texts, list):
        raise ValueError("You should pass a list of texts.")
    with futures.ThreadPoolExecutor(max_workers=n_jobs) as executor:
        futures_list = [executor.submit(callback, text, **kwargs) for text in texts]
        for future in futures.as_completed(futures_list):
            yield future.result()




INFO:root:----------------------------------------
INFO:root:max length: 3138
INFO:root:max position: 3138
INFO:root:target_namespace: xmnlp.xmnlp<folder>.utils<folder>.__init__<file>.parallel_handler<func>
INFO:root:****************************************

data 5:   0%|          | 0/512 [00:00<?, ?it/s]
data 5:   2%|▏         | 10/512 [00:11<09:38,  1.15s/it]
data 5:   4%|▍         | 20/512 [00:23<09:41,  1.18s/it]
data 5:   6%|▌         | 30/512 [00:37<10:16,  1.28s/it]
data 5:   8%|▊         | 40/512 [00:49<09:47,  1.25s/it]
data 5:  10%|▉         | 50/512 [01:01<09:25,  1.22s/it]
data 5:  12%|█▏        | 60/512 [01:15<09:40,  1.28s/it]
data 5:  14%|█▎        | 70/512 [01:27<09:17,  1.26s/it]
data 5:  14%|█▎        | 70/512 [01:31<09:36,  1.30s/it]
INFO:root:函数头: 
def parallel_handler(callback: Callable, texts: List[str], n_jobs: int = 2, **kwargs) -> Generator[
    List[Any], None, None
]:

INFO:root:目标函数体: 
    
    if not isinstance(texts, list):
        raise ValueError("You should pass a list of texts")
    if kwargs:
        callback = partial(callback, **kwargs)
    with futures.ThreadPoolExecutor(max_workers=n_jobs) as executor:
        for ret in executor.map(callback, texts):
            yield ret

INFO:root:生成结果: 
    if not isinstance(texts, list):
        raise ValueError("You should pass a list of texts.")
    
    with futures.ThreadPoolExecutor(max_workers=n_jobs) as executor:
        futures_list = [executor.submit(callback, text, **kwargs) for text in texts]
        for future in futures.as_completed(futures_list):
            yield future.result()


INFO:root:----------------------------------------
INFO:root:max length: 3139
INFO:root:max position: 3139
INFO:root:target_namespace: xmnlp.xmnlp<folder>.utils<folder>.__init__<file>.parallel_handler<func>
INFO:root:****************************************

data 5:   0%|          | 0/512 [00:00<?, ?it/s]
data 5:   2%|▏         | 10/512 [00:11<09:28,  1.13s/it]
data 5:   4%|▍         | 20/512 [00:23<09:33,  1.17s/it]
data 5:   6%|▌         | 30/512 [00:35<09:31,  1.18s/it]
data 5:   8%|▊         | 40/512 [00:47<09:26,  1.20s/it]
data 5:  10%|▉         | 50/512 [01:01<09:49,  1.28s/it]
data 5:  12%|█▏        | 60/512 [01:13<09:27,  1.26s/it]
data 5:  14%|█▎        | 70/512 [01:26<09:11,  1.25s/it]
data 5:  14%|█▎        | 70/512 [01:29<09:23,  1.27s/it]
INFO:root:函数头: 
def parallel_handler(callback: Callable, texts: List[str], n_jobs: int = 2, **kwargs) -> Generator[
    List[Any], None, None
]:

INFO:root:目标函数体: 
    
    if not isinstance(texts, list):
        raise ValueError("You should pass a list of texts")
    if kwargs:
        callback = partial(callback, **kwargs)
    with futures.ThreadPoolExecutor(max_workers=n_jobs) as executor:
        for ret in executor.map(callback, texts):
            yield ret

INFO:root:生成结果: 
    if not isinstance(texts, list):
        raise ValueError("You should pass a list of texts.")
    with futures.ThreadPoolExecutor(max_workers=n_jobs) as executor:
        futures_list = [executor.submit(callback, text, **kwargs) for text in texts]
        for future in futures.as_completed(futures_list):
            yield future.result()


INFO:root:----------------------------------------
INFO:root:max length: 3138
INFO:root:max position: 3138
INFO:root:target_namespace: xmnlp.xmnlp<folder>.utils<folder>.__init__<file>.parallel_handler<func>
INFO:root:****************************************

data 5:   0%|          | 0/512 [00:00<?, ?it/s]
data 5:   2%|▏         | 10/512 [00:11<09:58,  1.19s/it]
data 5:   4%|▍         | 20/512 [00:23<09:50,  1.20s/it]
data 5:   6%|▌         | 30/512 [00:38<10:29,  1.31s/it]
data 5:   8%|▊         | 40/512 [00:50<10:07,  1.29s/it]
data 5:  10%|▉         | 50/512 [01:03<09:47,  1.27s/it]
data 5:  12%|█▏        | 60/512 [01:15<09:28,  1.26s/it]
data 5:  14%|█▎        | 70/512 [01:27<09:03,  1.23s/it]
data 5:  14%|█▎        | 70/512 [01:30<09:32,  1.29s/it]
INFO:root:函数头: 
def parallel_handler(callback: Callable, texts: List[str], n_jobs: int = 2, **kwargs) -> Generator[
    List[Any], None, None
]:

INFO:root:目标函数体: 
    
    if not isinstance(texts, list):
        raise ValueError("You should pass a list of texts")
    if kwargs:
        callback = partial(callback, **kwargs)
    with futures.ThreadPoolExecutor(max_workers=n_jobs) as executor:
        for ret in executor.map(callback, texts):
            yield ret

INFO:root:生成结果: 
    if not isinstance(texts, list):
        raise ValueError("You should pass a list of texts.")
    with futures.ThreadPoolExecutor(max_workers=n_jobs) as executor:
        futures_list = [executor.submit(callback, text, **kwargs) for text in texts]
        for future in futures.as_completed(futures_list):
            yield future.result()




INFO:root:----------------------------------------
INFO:root:max length: 3138
INFO:root:max position: 3138
INFO:root:target_namespace: xmnlp.xmnlp<folder>.utils<folder>.__init__<file>.parallel_handler<func>
INFO:root:****************************************
INFO:root:--------data 6--------

data 6:   0%|          | 0/512 [00:00<?, ?it/s]
data 6:   2%|▏         | 10/512 [00:14<12:11,  1.46s/it]
data 6:   4%|▍         | 20/512 [00:26<10:54,  1.33s/it]
data 6:   6%|▌         | 30/512 [00:39<10:20,  1.29s/it]
data 6:   8%|▊         | 40/512 [00:51<10:02,  1.28s/it]
data 6:  10%|▉         | 50/512 [01:06<10:20,  1.34s/it]
data 6:  10%|▉         | 50/512 [01:11<11:03,  1.44s/it]
INFO:root:函数头: 
def shorten(text: str, width: int, suffix: str = "...") -> str:

INFO:root:目标函数体: 
    
    if len(text) <= width:
        return text
    if width > len(suffix):
        return text[: width - len(suffix)] + suffix
    if width >= 0:
        return suffix[len(suffix) - width :]
    raise ValueError("width must be equal or greater than 0")

INFO:root:生成结果: 
    if width < 0:
        raise ValueError("width must be equal or greater than 0")
    if len(text) <= width:
        return text
    if width >= len(suffix):
        return text[:width] + suffix
    return suffix




INFO:root:----------------------------------------
INFO:root:max length: 3566
INFO:root:max position: 3566
INFO:root:target_namespace: parsel.parsel<folder>.utils<file>.shorten<func>
INFO:root:****************************************

data 6:   0%|          | 0/512 [00:00<?, ?it/s]
data 6:   2%|▏         | 10/512 [00:13<11:32,  1.38s/it]
data 6:   4%|▍         | 20/512 [00:26<10:53,  1.33s/it]
data 6:   6%|▌         | 30/512 [00:39<10:34,  1.32s/it]
data 6:   8%|▊         | 40/512 [00:54<10:43,  1.36s/it]
data 6:  10%|▉         | 50/512 [01:06<10:09,  1.32s/it]
data 6:  10%|▉         | 50/512 [01:13<11:18,  1.47s/it]
INFO:root:函数头: 
def shorten(text: str, width: int, suffix: str = "...") -> str:

INFO:root:目标函数体: 
    
    if len(text) <= width:
        return text
    if width > len(suffix):
        return text[: width - len(suffix)] + suffix
    if width >= 0:
        return suffix[len(suffix) - width :]
    raise ValueError("width must be equal or greater than 0")

INFO:root:生成结果: 
    if width < 0:
        raise ValueError("width must be equal or greater than 0")
    if len(text) <= width:
        return text
    if width >= len(suffix):
        return text[:width] + suffix
    return suffix




INFO:root:----------------------------------------
INFO:root:max length: 3566
INFO:root:max position: 3566
INFO:root:target_namespace: parsel.parsel<folder>.utils<file>.shorten<func>
INFO:root:****************************************

data 6:   0%|          | 0/512 [00:00<?, ?it/s]
data 6:   2%|▏         | 10/512 [00:11<09:22,  1.12s/it]
data 6:   4%|▍         | 20/512 [00:24<10:04,  1.23s/it]
data 6:   6%|▌         | 30/512 [00:36<09:54,  1.23s/it]
data 6:   8%|▊         | 40/512 [00:49<09:42,  1.23s/it]
data 6:  10%|▉         | 50/512 [01:03<10:05,  1.31s/it]
data 6:  10%|▉         | 50/512 [01:08<10:34,  1.37s/it]
INFO:root:函数头: 
def shorten(text: str, width: int, suffix: str = "...") -> str:

INFO:root:目标函数体: 
    
    if len(text) <= width:
        return text
    if width > len(suffix):
        return text[: width - len(suffix)] + suffix
    if width >= 0:
        return suffix[len(suffix) - width :]
    raise ValueError("width must be equal or greater than 0")

INFO:root:生成结果: 
    if width <= 0:
        raise ValueError("width must be equal or greater than 0")
    if len(text) <= width:
        return text
    if width >= len(suffix):
        return text[:width] + suffix
    return suffix




INFO:root:----------------------------------------
INFO:root:max length: 3566
INFO:root:max position: 3566
INFO:root:target_namespace: parsel.parsel<folder>.utils<file>.shorten<func>
INFO:root:****************************************

data 6:   0%|          | 0/512 [00:00<?, ?it/s]
data 6:   2%|▏         | 10/512 [00:11<09:33,  1.14s/it]
data 6:   4%|▍         | 20/512 [00:25<10:47,  1.32s/it]
data 6:   6%|▌         | 30/512 [00:38<10:13,  1.27s/it]
data 6:   8%|▊         | 40/512 [00:52<10:33,  1.34s/it]
data 6:  10%|▉         | 50/512 [01:04<10:00,  1.30s/it]
data 6:  10%|▉         | 50/512 [01:11<11:02,  1.43s/it]
INFO:root:函数头: 
def shorten(text: str, width: int, suffix: str = "...") -> str:

INFO:root:目标函数体: 
    
    if len(text) <= width:
        return text
    if width > len(suffix):
        return text[: width - len(suffix)] + suffix
    if width >= 0:
        return suffix[len(suffix) - width :]
    raise ValueError("width must be equal or greater than 0")

INFO:root:生成结果: 
    if width < 0:
        raise ValueError("width must be equal or greater than 0")
    if len(text) <= width:
        return text
    if width >= len(suffix):
        return text[:width] + suffix
    return suffix




INFO:root:----------------------------------------
INFO:root:max length: 3566
INFO:root:max position: 3566
INFO:root:target_namespace: parsel.parsel<folder>.utils<file>.shorten<func>
INFO:root:****************************************

data 6:   0%|          | 0/512 [00:00<?, ?it/s]
data 6:   2%|▏         | 10/512 [00:11<09:48,  1.17s/it]
data 6:   4%|▍         | 20/512 [00:24<10:17,  1.26s/it]
data 6:   6%|▌         | 30/512 [00:37<10:13,  1.27s/it]
data 6:   8%|▊         | 40/512 [00:50<09:57,  1.27s/it]
data 6:  10%|▉         | 50/512 [01:04<10:11,  1.32s/it]
data 6:  10%|▉         | 50/512 [01:13<11:20,  1.47s/it]
INFO:root:函数头: 
def shorten(text: str, width: int, suffix: str = "...") -> str:

INFO:root:目标函数体: 
    
    if len(text) <= width:
        return text
    if width > len(suffix):
        return text[: width - len(suffix)] + suffix
    if width >= 0:
        return suffix[len(suffix) - width :]
    raise ValueError("width must be equal or greater than 0")

INFO:root:生成结果: 
    if width < 0:
        raise ValueError("width must be equal or greater than 0")
    if len(text) <= width:
        return text
    if width >= len(suffix):
        return text[: width - len(suffix)] + suffix
    return suffix




INFO:root:----------------------------------------
INFO:root:max length: 3569
INFO:root:max position: 3569
INFO:root:target_namespace: parsel.parsel<folder>.utils<file>.shorten<func>
INFO:root:****************************************
INFO:root:--------data 7--------

data 7:   0%|          | 0/512 [00:00<?, ?it/s]
data 7:   2%|▏         | 10/512 [00:14<12:03,  1.44s/it]
data 7:   4%|▍         | 20/512 [00:26<10:42,  1.31s/it]
data 7:   4%|▍         | 20/512 [00:34<14:11,  1.73s/it]
INFO:root:函数头: 
def set_xpathfunc(fname: str, func: Optional[Callable]) -> None:  # type: ignore[type-arg]

INFO:root:目标函数体: 
    
    ns_fns = etree.FunctionNamespace(None)  # type: ignore[attr-defined]
    if func is not None:
        ns_fns[fname] = func
    else:
        del ns_fns[fname]

INFO:root:生成结果: 
    if func is None:
        _translator.unregister_function(fname)
    else:
        _translator.register_function(fname, func)




INFO:root:----------------------------------------
INFO:root:max length: 3292
INFO:root:max position: 3292
INFO:root:target_namespace: parsel.parsel<folder>.xpathfuncs<file>.set_xpathfunc<func>
INFO:root:****************************************

data 7:   0%|          | 0/512 [00:00<?, ?it/s]
data 7:   2%|▏         | 10/512 [00:11<09:33,  1.14s/it]
data 7:   4%|▍         | 20/512 [00:23<09:40,  1.18s/it]
data 7:   6%|▌         | 30/512 [00:37<10:20,  1.29s/it]
data 7:   8%|▊         | 40/512 [00:50<10:01,  1.28s/it]
data 7:   8%|▊         | 40/512 [00:58<11:27,  1.46s/it]
INFO:root:函数头: 
def set_xpathfunc(fname: str, func: Optional[Callable]) -> None:  # type: ignore[type-arg]

INFO:root:目标函数体: 
    
    ns_fns = etree.FunctionNamespace(None)  # type: ignore[attr-defined]
    if func is not None:
        ns_fns[fname] = func
    else:
        del ns_fns[fname]

INFO:root:生成结果: 
    global _translator  # Access the global _translator variable
    if func is None:
        del _translator.xpath_func_map[fname]
    else:
        _translator.xpath_func_map[fname] = func




INFO:root:----------------------------------------
INFO:root:max length: 3311
INFO:root:max position: 3311
INFO:root:target_namespace: parsel.parsel<folder>.xpathfuncs<file>.set_xpathfunc<func>
INFO:root:****************************************

data 7:   0%|          | 0/512 [00:00<?, ?it/s]
data 7:   2%|▏         | 10/512 [00:11<09:47,  1.17s/it]
data 7:   4%|▍         | 20/512 [00:23<09:45,  1.19s/it]
data 7:   6%|▌         | 30/512 [00:35<09:35,  1.19s/it]
data 7:   6%|▌         | 30/512 [00:46<12:30,  1.56s/it]
INFO:root:函数头: 
def set_xpathfunc(fname: str, func: Optional[Callable]) -> None:  # type: ignore[type-arg]

INFO:root:目标函数体: 
    
    ns_fns = etree.FunctionNamespace(None)  # type: ignore[attr-defined]
    if func is not None:
        ns_fns[fname] = func
    else:
        del ns_fns[fname]

INFO:root:生成结果: 
    global _translator
    if func is None:
        del _translator._xpathfuncs[fname]
    else:
        _translator._xpathfuncs[fname] = func




INFO:root:----------------------------------------
INFO:root:max length: 3303
INFO:root:max position: 3303
INFO:root:target_namespace: parsel.parsel<folder>.xpathfuncs<file>.set_xpathfunc<func>
INFO:root:****************************************

data 7:   0%|          | 0/512 [00:00<?, ?it/s]
data 7:   2%|▏         | 10/512 [00:11<09:39,  1.16s/it]
data 7:   4%|▍         | 20/512 [00:23<09:41,  1.18s/it]
data 7:   4%|▍         | 20/512 [00:31<13:00,  1.59s/it]
INFO:root:函数头: 
def set_xpathfunc(fname: str, func: Optional[Callable]) -> None:  # type: ignore[type-arg]

INFO:root:目标函数体: 
    
    ns_fns = etree.FunctionNamespace(None)  # type: ignore[attr-defined]
    if func is not None:
        ns_fns[fname] = func
    else:
        del ns_fns[fname]

INFO:root:生成结果: 
    if func is None:
        _translator.unregister_function(fname)
    else:
        _translator.register_function(fname, func)




INFO:root:----------------------------------------
INFO:root:max length: 3292
INFO:root:max position: 3292
INFO:root:target_namespace: parsel.parsel<folder>.xpathfuncs<file>.set_xpathfunc<func>
INFO:root:****************************************

data 7:   0%|          | 0/512 [00:00<?, ?it/s]
data 7:   2%|▏         | 10/512 [00:11<09:38,  1.15s/it]
data 7:   2%|▏         | 10/512 [00:12<10:09,  1.21s/it]
INFO:root:函数头: 
def set_xpathfunc(fname: str, func: Optional[Callable]) -> None:  # type: ignore[type-arg]

INFO:root:目标函数体: 
    
    ns_fns = etree.FunctionNamespace(None)  # type: ignore[attr-defined]
    if func is not None:
        ns_fns[fname] = func
    else:
        del ns_fns[fname]

INFO:root:生成结果: 
    _translator.register_function(fname, func)




INFO:root:----------------------------------------
INFO:root:max length: 3276
INFO:root:max position: 3276
INFO:root:target_namespace: parsel.parsel<folder>.xpathfuncs<file>.set_xpathfunc<func>
INFO:root:****************************************
INFO:root:--------data 8--------

data 8:   0%|          | 0/512 [00:00<?, ?it/s]
data 8:   2%|▏         | 10/512 [00:06<05:28,  1.53it/s]
data 8:   4%|▍         | 20/512 [00:11<04:29,  1.83it/s]
data 8:   6%|▌         | 30/512 [00:15<04:04,  1.97it/s]
data 8:   6%|▌         | 30/512 [00:19<05:15,  1.53it/s]
INFO:root:函数头: 
def _get_thread_context():

INFO:root:目标函数体: 
  context = [threading.current_thread()]
  if greenlet:
    context.append(greenlet.getcurrent())
  return hash(tuple(context))

INFO:root:生成结果: 
    context_list = []
    context_list.append(threading.currentThread())
    if greenlet:
        context_list.append(greenlet.getcurrent())
    return hash(tuple(context_list))



INFO:root:----------------------------------------
INFO:root:max length: 1119
INFO:root:max position: 1119
INFO:root:target_namespace: dominate.dominate<folder>.dom_tag<file>._get_thread_context<func>
INFO:root:****************************************

data 8:   0%|          | 0/512 [00:00<?, ?it/s]
data 8:   2%|▏         | 10/512 [00:04<03:30,  2.39it/s]
data 8:   4%|▍         | 20/512 [00:08<03:34,  2.30it/s]
data 8:   6%|▌         | 30/512 [00:14<04:08,  1.94it/s]
data 8:   6%|▌         | 30/512 [00:16<04:18,  1.87it/s]
INFO:root:函数头: 
def _get_thread_context():

INFO:root:目标函数体: 
  context = [threading.current_thread()]
  if greenlet:
    context.append(greenlet.getcurrent())
  return hash(tuple(context))

INFO:root:生成结果: 
    context = []
    context.append(threading.current_thread())
    if greenlet:
        context.append(greenlet.getgreenlet())
    return hash(tuple(context))



INFO:root:----------------------------------------
INFO:root:max length: 1117
INFO:root:max position: 1117
INFO:root:target_namespace: dominate.dominate<folder>.dom_tag<file>._get_thread_context<func>
INFO:root:****************************************

data 8:   0%|          | 0/512 [00:00<?, ?it/s]
data 8:   2%|▏         | 10/512 [00:06<05:02,  1.66it/s]
data 8:   4%|▍         | 20/512 [00:10<04:14,  1.93it/s]
data 8:   6%|▌         | 30/512 [00:15<04:12,  1.91it/s]
data 8:   6%|▌         | 30/512 [00:17<04:46,  1.68it/s]
INFO:root:函数头: 
def _get_thread_context():

INFO:root:目标函数体: 
  context = [threading.current_thread()]
  if greenlet:
    context.append(greenlet.getcurrent())
  return hash(tuple(context))

INFO:root:生成结果: 
    context = []
    context.append(threading.current_thread())
    if greenlet:
        context.append(greenlet.getcurrent())
    return hash(tuple(context))



INFO:root:----------------------------------------
INFO:root:max length: 1116
INFO:root:max position: 1116
INFO:root:target_namespace: dominate.dominate<folder>.dom_tag<file>._get_thread_context<func>
INFO:root:****************************************

data 8:   0%|          | 0/512 [00:00<?, ?it/s]
data 8:   2%|▏         | 10/512 [00:04<03:34,  2.34it/s]
data 8:   4%|▍         | 20/512 [00:10<04:26,  1.85it/s]
data 8:   6%|▌         | 30/512 [00:14<03:59,  2.01it/s]
data 8:   6%|▌         | 30/512 [00:15<04:12,  1.91it/s]
INFO:root:函数头: 
def _get_thread_context():

INFO:root:目标函数体: 
  context = [threading.current_thread()]
  if greenlet:
    context.append(greenlet.getcurrent())
  return hash(tuple(context))

INFO:root:生成结果: 
    context = []
    context.append(threading.currentThread())
    if greenlet:
        context.append(greenlet.getcurrent())
    return hash(tuple(context))




INFO:root:----------------------------------------
INFO:root:max length: 1115
INFO:root:max position: 1115
INFO:root:target_namespace: dominate.dominate<folder>.dom_tag<file>._get_thread_context<func>
INFO:root:****************************************

data 8:   0%|          | 0/512 [00:00<?, ?it/s]
data 8:   2%|▏         | 10/512 [00:05<04:57,  1.69it/s]
data 8:   4%|▍         | 20/512 [00:10<04:12,  1.95it/s]
data 8:   6%|▌         | 30/512 [00:15<03:53,  2.06it/s]
data 8:   6%|▌         | 30/512 [00:18<04:50,  1.66it/s]
INFO:root:函数头: 
def _get_thread_context():

INFO:root:目标函数体: 
  context = [threading.current_thread()]
  if greenlet:
    context.append(greenlet.getcurrent())
  return hash(tuple(context))

INFO:root:生成结果: 
    context = []
    context.append(threading.current_thread())
    if greenlet:
        context.append(greenlet.getgreenlet())
    return hash(tuple(context))



INFO:root:----------------------------------------
INFO:root:max length: 1117
INFO:root:max position: 1117
INFO:root:target_namespace: dominate.dominate<folder>.dom_tag<file>._get_thread_context<func>
INFO:root:****************************************
INFO:root:--------data 9--------

data 9:   0%|          | 0/512 [00:00<?, ?it/s]
data 9:   2%|▏         | 10/512 [00:04<04:02,  2.07it/s]
data 9:   4%|▍         | 20/512 [00:11<04:58,  1.65it/s]
data 9:   6%|▌         | 30/512 [00:16<04:22,  1.84it/s]
data 9:   8%|▊         | 40/512 [00:21<04:05,  1.92it/s]
data 9:  10%|▉         | 50/512 [00:27<04:23,  1.75it/s]
data 9:  12%|█▏        | 60/512 [00:32<04:00,  1.88it/s]
data 9:  14%|█▎        | 70/512 [00:38<04:09,  1.77it/s]
data 9:  16%|█▌        | 80/512 [00:43<03:51,  1.87it/s]
data 9:  16%|█▌        | 80/512 [00:47<04:16,  1.68it/s]
INFO:root:函数头: 
def system(cmd, data=None):

INFO:root:目标函数体: 
  '''
  pipes the output of a program
  '''
  import subprocess
  s = subprocess.Popen(cmd, shell=True, stdout=subprocess.PIPE, stdin=subprocess.PIPE)
  out, err = s.communicate(data)
  return out.decode('utf8')

INFO:root:生成结果: 
    import subprocess
    import io

    # Create a io.BytesIO object to capture the output of the command
    output = io.BytesIO()

    # Run the command using subprocess.run
    subprocess.run(cmd, input=data, stdout=output, stderr=output, check=True)

    # Read the output from the io.BytesIO object and decode it as a string
    return output.getvalue().decode('utf-8')




INFO:root:----------------------------------------
INFO:root:max length: 1166
INFO:root:max position: 1166
INFO:root:target_namespace: dominate.dominate<folder>.util<file>.system<func>
INFO:root:****************************************

data 9:   0%|          | 0/512 [00:00<?, ?it/s]
data 9:   2%|▏         | 10/512 [00:04<03:38,  2.30it/s]
data 9:   4%|▍         | 20/512 [00:08<03:41,  2.22it/s]
data 9:   6%|▌         | 30/512 [00:15<04:25,  1.81it/s]
data 9:   8%|▊         | 40/512 [00:20<04:05,  1.92it/s]
data 9:  10%|▉         | 50/512 [00:27<04:25,  1.74it/s]
data 9:  12%|█▏        | 60/512 [00:31<04:04,  1.85it/s]
data 9:  14%|█▎        | 70/512 [00:36<03:46,  1.95it/s]
data 9:  14%|█▎        | 70/512 [00:40<04:16,  1.72it/s]
INFO:root:函数头: 
def system(cmd, data=None):

INFO:root:目标函数体: 
  '''
  pipes the output of a program
  '''
  import subprocess
  s = subprocess.Popen(cmd, shell=True, stdout=subprocess.PIPE, stdin=subprocess.PIPE)
  out, err = s.communicate(data)
  return out.decode('utf8')

INFO:root:生成结果: 
    import subprocess
    process = subprocess.Popen(cmd, shell=True, stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    output, error = process.communicate(data)
    if process.returncode != 0:
        raise Exception(f"Command '{cmd}' failed with error: {error.decode('utf-8')}")
    return output.decode('utf-8')




INFO:root:----------------------------------------
INFO:root:max length: 1156
INFO:root:max position: 1156
INFO:root:target_namespace: dominate.dominate<folder>.util<file>.system<func>
INFO:root:****************************************

data 9:   0%|          | 0/512 [00:00<?, ?it/s]
data 9:   2%|▏         | 10/512 [00:04<03:34,  2.34it/s]
data 9:   4%|▍         | 20/512 [00:10<04:36,  1.78it/s]
data 9:   6%|▌         | 30/512 [00:15<04:06,  1.96it/s]
data 9:   8%|▊         | 40/512 [00:20<03:54,  2.01it/s]
data 9:   8%|▊         | 40/512 [00:24<04:45,  1.65it/s]
INFO:root:函数头: 
def system(cmd, data=None):

INFO:root:目标函数体: 
  '''
  pipes the output of a program
  '''
  import subprocess
  s = subprocess.Popen(cmd, shell=True, stdout=subprocess.PIPE, stdin=subprocess.PIPE)
  out, err = s.communicate(data)
  return out.decode('utf8')

INFO:root:生成结果: 
    import subprocess
    process = subprocess.Popen(cmd, shell=True, stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    output, error = process.communicate(data=data)
    return output.decode('utf-8')



INFO:root:----------------------------------------
INFO:root:max length: 1126
INFO:root:max position: 1126
INFO:root:target_namespace: dominate.dominate<folder>.util<file>.system<func>
INFO:root:****************************************

data 9:   0%|          | 0/512 [00:00<?, ?it/s]
data 9:   2%|▏         | 10/512 [00:05<04:53,  1.71it/s]
data 9:   4%|▍         | 20/512 [00:10<04:14,  1.93it/s]
data 9:   6%|▌         | 30/512 [00:15<03:54,  2.06it/s]
data 9:   8%|▊         | 40/512 [00:20<03:57,  1.99it/s]
data 9:   8%|▊         | 40/512 [00:23<04:38,  1.69it/s]
INFO:root:函数头: 
def system(cmd, data=None):

INFO:root:目标函数体: 
  '''
  pipes the output of a program
  '''
  import subprocess
  s = subprocess.Popen(cmd, shell=True, stdout=subprocess.PIPE, stdin=subprocess.PIPE)
  out, err = s.communicate(data)
  return out.decode('utf8')

INFO:root:生成结果: 
    import subprocess
    process = subprocess.Popen(cmd, shell=True, stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    stdout, stderr = process.communicate(data)
    return stdout.decode('utf-8')




INFO:root:----------------------------------------
INFO:root:max length: 1125
INFO:root:max position: 1125
INFO:root:target_namespace: dominate.dominate<folder>.util<file>.system<func>
INFO:root:****************************************

data 9:   0%|          | 0/512 [00:00<?, ?it/s]
data 9:   2%|▏         | 10/512 [00:05<04:53,  1.71it/s]
data 9:   4%|▍         | 20/512 [00:10<04:11,  1.96it/s]
data 9:   6%|▌         | 30/512 [00:15<03:54,  2.05it/s]
data 9:   8%|▊         | 40/512 [00:21<04:27,  1.77it/s]
data 9:   8%|▊         | 40/512 [00:25<05:03,  1.55it/s]
INFO:root:函数头: 
def system(cmd, data=None):

INFO:root:目标函数体: 
  '''
  pipes the output of a program
  '''
  import subprocess
  s = subprocess.Popen(cmd, shell=True, stdout=subprocess.PIPE, stdin=subprocess.PIPE)
  out, err = s.communicate(data)
  return out.decode('utf8')

INFO:root:生成结果: 
    import subprocess
    process = subprocess.Popen(cmd, shell=True, stdin=subprocess.PIPE if data else None, stdout=subprocess.PIPE)
    output, _ = process.communicate(data)
    return output.decode('utf-8')



INFO:root:----------------------------------------
INFO:root:max length: 1125
INFO:root:max position: 1125
INFO:root:target_namespace: dominate.dominate<folder>.util<file>.system<func>
INFO:root:****************************************
INFO:root:--------data 10--------

data 10:   0%|          | 0/512 [00:00<?, ?it/s]
data 10:   2%|▏         | 10/512 [00:07<06:33,  1.27it/s]
data 10:   4%|▍         | 20/512 [00:15<06:10,  1.33it/s]
data 10:   6%|▌         | 30/512 [00:20<05:25,  1.48it/s]
data 10:   8%|▊         | 40/512 [00:28<05:28,  1.44it/s]
data 10:  10%|▉         | 50/512 [00:35<05:28,  1.41it/s]
data 10:  12%|█▏        | 60/512 [00:43<05:30,  1.37it/s]
data 10:  14%|█▎        | 70/512 [00:49<05:08,  1.43it/s]
data 10:  16%|█▌        | 80/512 [00:56<05:03,  1.43it/s]
data 10:  18%|█▊        | 90/512 [01:04<04:59,  1.41it/s]
data 10:  18%|█▊        | 90/512 [01:05<05:06,  1.38it/s]
INFO:root:函数头: 
def url_unescape(data):

INFO:root:目标函数体: 
  return re.sub('%([0-9a-fA-F]{2})',
    lambda m: unichr(int(m.group(1), 16)), data)

INFO:root:生成结果: 
    cc = re.compile(r'%([0-9A-Fa-f]{2})')
    result = []
    m = cc.search(data)
    while m:
        result.append(data[0:m.start()])
        d = m.group(1)
        result.append(unichr(int(d, 16)))
        data = data[m.end():]
        m = cc.search(data)

    result.append(data)
    return ''.join(result)




INFO:root:----------------------------------------
INFO:root:max length: 1624
INFO:root:max position: 1624
INFO:root:target_namespace: dominate.dominate<folder>.util<file>.url_unescape<func>
INFO:root:****************************************

data 10:   0%|          | 0/512 [00:00<?, ?it/s]
data 10:   0%|          | 0/512 [00:06<?, ?it/s]
INFO:root:函数头: 
def url_unescape(data):

INFO:root:目标函数体: 
  return re.sub('%([0-9a-fA-F]{2})',
    lambda m: unichr(int(m.group(1), 16)), data)

INFO:root:生成结果: 
    return data.decode('unicode_escape')




INFO:root:----------------------------------------
INFO:root:max length: 1542
INFO:root:max position: 1542
INFO:root:target_namespace: dominate.dominate<folder>.util<file>.url_unescape<func>
INFO:root:****************************************

data 10:   0%|          | 0/512 [00:00<?, ?it/s]
data 10:   2%|▏         | 10/512 [00:07<05:53,  1.42it/s]
data 10:   2%|▏         | 10/512 [00:11<09:12,  1.10s/it]
INFO:root:函数头: 
def url_unescape(data):

INFO:root:目标函数体: 
  return re.sub('%([0-9a-fA-F]{2})',
    lambda m: unichr(int(m.group(1), 16)), data)

INFO:root:生成结果: 
    return data.encode('latin-1').decode('unicode_escape')


INFO:root:----------------------------------------
INFO:root:max length: 1548
INFO:root:max position: 1548
INFO:root:target_namespace: dominate.dominate<folder>.util<file>.url_unescape<func>
INFO:root:****************************************

data 10:   0%|          | 0/512 [00:00<?, ?it/s]
data 10:   2%|▏         | 10/512 [00:05<04:14,  1.97it/s]
data 10:   4%|▍         | 20/512 [00:12<05:15,  1.56it/s]
data 10:   6%|▌         | 30/512 [00:19<05:29,  1.46it/s]
data 10:   8%|▊         | 40/512 [00:27<05:35,  1.41it/s]
data 10:  10%|▉         | 50/512 [00:32<05:04,  1.52it/s]
data 10:  12%|█▏        | 60/512 [00:40<05:12,  1.45it/s]
data 10:  14%|█▎        | 70/512 [00:47<05:10,  1.42it/s]
data 10:  16%|█▌        | 80/512 [00:53<04:41,  1.54it/s]
data 10:  16%|█▌        | 80/512 [00:56<05:03,  1.42it/s]
INFO:root:函数头: 
def url_unescape(data):

INFO:root:目标函数体: 
  return re.sub('%([0-9a-fA-F]{2})',
    lambda m: unichr(int(m.group(1), 16)), data)

INFO:root:生成结果: 
    # Implement the url_unescape function based on the provided code prefix and other resources in the current project, without generating any additional content! The current function is located in file dominate/util.py, prohibit cyclic calling the current function! You can use resources in the current project, and you MUST write import statements FIRST to call the corresponding resource.
    import urllib.parse
    return urllib.parse.unquote(data)




INFO:root:----------------------------------------
INFO:root:max length: 1615
INFO:root:max position: 1615
INFO:root:target_namespace: dominate.dominate<folder>.util<file>.url_unescape<func>
INFO:root:****************************************

data 10:   0%|          | 0/512 [00:00<?, ?it/s]
data 10:   2%|▏         | 10/512 [00:07<06:04,  1.38it/s]
data 10:   4%|▍         | 20/512 [00:12<05:10,  1.58it/s]
data 10:   6%|▌         | 30/512 [00:20<05:36,  1.43it/s]
data 10:   8%|▊         | 40/512 [00:28<05:35,  1.41it/s]
data 10:  10%|▉         | 50/512 [00:35<05:29,  1.40it/s]
data 10:  12%|█▏        | 60/512 [00:42<05:26,  1.38it/s]
data 10:  14%|█▎        | 70/512 [00:50<05:22,  1.37it/s]
data 10:  16%|█▌        | 80/512 [00:57<05:16,  1.36it/s]
data 10:  18%|█▊        | 90/512 [01:02<04:46,  1.48it/s]
data 10:  18%|█▊        | 90/512 [01:09<05:24,  1.30it/s]
INFO:root:函数头: 
def url_unescape(data):

INFO:root:目标函数体: 
  return re.sub('%([0-9a-fA-F]{2})',
    lambda m: unichr(int(m.group(1), 16)), data)

INFO:root:生成结果: 
    cc = re.compile(r'%([0-9A-Fa-f]{2})')
    result = []
    m = cc.search(data)
    while m:
        result.append(data[0:m.start()])
        d = m.group(1)
        d = int(d, 16)
        result.append(unichr(d))

        data = data[m.end():]
        m = cc.search(data)

    result.append(data)
    return ''.join(result)


INFO:root:----------------------------------------
INFO:root:max length: 1629
INFO:root:max position: 1629
INFO:root:target_namespace: dominate.dominate<folder>.util<file>.url_unescape<func>
INFO:root:****************************************
INFO:root:--------data 11--------

data 11:   0%|          | 0/512 [00:00<?, ?it/s]
data 11:   2%|▏         | 10/512 [01:01<51:10,  6.12s/it]
data 11:   4%|▍         | 20/512 [02:08<52:59,  6.46s/it]
data 11:   6%|▌         | 30/512 [03:15<52:49,  6.58s/it]
data 11:   8%|▊         | 40/512 [04:21<51:57,  6.61s/it]
data 11:  10%|▉         | 50/512 [05:29<51:13,  6.65s/it]
data 11:  12%|█▏        | 60/512 [06:39<50:59,  6.77s/it]
data 11:  14%|█▎        | 70/512 [07:52<51:19,  6.97s/it]
data 11:  16%|█▌        | 80/512 [09:04<50:39,  7.03s/it]
data 11:  18%|█▊        | 90/512 [10:15<49:38,  7.06s/it]
data 11:  18%|█▊        | 90/512 [11:12<52:33,  7.47s/it]
INFO:root:函数头: 
    @classmethod
    def serialize(cls, value, *args, **kwargs):

INFO:root:目标函数体: 
        if value is None:
            return ""

        return six.text_type(value.isoformat())

INFO:root:生成结果: 
        if value is None:
            return ""

        # TODO: implement locale
        # TODO: implement for more than one key
        year, month, day, hour, minute, second = value.year, value.month, value.day, value.hour, value.minute, value.second
        return "{}-{:02}-{:02}T{:02}:{:02}:{:02}".format(year, month, day, hour, minute, second)




INFO:root:----------------------------------------
INFO:root:max length: 7765
INFO:root:max position: 8216
INFO:root:target_namespace: rows.rows<folder>.fields<file>.DatetimeField<class>.serialize<func>
INFO:root:****************************************

data 11:   0%|          | 0/512 [00:00<?, ?it/s]
data 11:   2%|▏         | 10/512 [01:02<52:41,  6.30s/it]
data 11:   4%|▍         | 20/512 [02:13<55:27,  6.76s/it]
data 11:   4%|▍         | 20/512 [02:21<57:52,  7.06s/it]
INFO:root:函数头: 
    @classmethod
    def serialize(cls, value, *args, **kwargs):

INFO:root:目标函数体: 
        if value is None:
            return ""

        return six.text_type(value.isoformat())

INFO:root:生成结果: 
        if value is None:
            return ""
        return six.text_type(value.isoformat())


INFO:root:----------------------------------------
INFO:root:max length: 6686
INFO:root:max position: 8182
INFO:root:target_namespace: rows.rows<folder>.fields<file>.DatetimeField<class>.serialize<func>
INFO:root:****************************************

data 11:   0%|          | 0/512 [00:00<?, ?it/s]
data 11:   2%|▏         | 10/512 [01:01<51:46,  6.19s/it]
data 11:   2%|▏         | 10/512 [01:49<1:31:55, 10.99s/it]
INFO:root:函数头: 
    @classmethod
    def serialize(cls, value, *args, **kwargs):

INFO:root:目标函数体: 
        if value is None:
            return ""

        return six.text_type(value.isoformat())

INFO:root:生成结果: 
        if value is None:
            return ""
        return value.isoformat()


INFO:root:----------------------------------------
INFO:root:max length: 6717
INFO:root:max position: 8114
INFO:root:target_namespace: rows.rows<folder>.fields<file>.DatetimeField<class>.serialize<func>
INFO:root:****************************************

data 11:   0%|          | 0/512 [00:00<?, ?it/s]
data 11:   2%|▏         | 10/512 [01:02<52:32,  6.28s/it]
data 11:   2%|▏         | 10/512 [01:59<1:40:20, 11.99s/it]
INFO:root:函数头: 
    @classmethod
    def serialize(cls, value, *args, **kwargs):

INFO:root:目标函数体: 
        if value is None:
            return ""

        return six.text_type(value.isoformat())

INFO:root:生成结果: 
        if value is None:
            return ""
        return value.isoformat()


INFO:root:----------------------------------------
INFO:root:max length: 6535
INFO:root:max position: 8105
INFO:root:target_namespace: rows.rows<folder>.fields<file>.DatetimeField<class>.serialize<func>
INFO:root:****************************************

data 11:   0%|          | 0/512 [00:00<?, ?it/s]
data 11:   2%|▏         | 10/512 [01:04<53:36,  6.41s/it]
data 11:   2%|▏         | 10/512 [01:53<1:35:14, 11.38s/it]
INFO:root:函数头: 
    @classmethod
    def serialize(cls, value, *args, **kwargs):

INFO:root:目标函数体: 
        if value is None:
            return ""

        return six.text_type(value.isoformat())

INFO:root:生成结果: 
        if value is None:
            return ""
        return value.isoformat()


INFO:root:----------------------------------------
INFO:root:max length: 6740
INFO:root:max position: 8102
INFO:root:target_namespace: rows.rows<folder>.fields<file>.DatetimeField<class>.serialize<func>
INFO:root:****************************************
INFO:root:--------data 12--------

data 12:   0%|          | 0/512 [00:00<?, ?it/s]
data 12:   0%|          | 0/512 [00:24<?, ?it/s]
INFO:root:函数头: 
    @classmethod
    def serialize(cls, value, *args, **kwargs):

INFO:root:目标函数体: 
        

        if value is None:
            value = ""
        return value

INFO:root:生成结果: 
        raise NotImplementedError




INFO:root:----------------------------------------
INFO:root:max length: 6326
INFO:root:max position: 6374
INFO:root:target_namespace: rows.rows<folder>.fields<file>.Field<class>.serialize<func>
INFO:root:****************************************

data 12:   0%|          | 0/512 [00:00<?, ?it/s]
data 12:   2%|▏         | 10/512 [00:45<38:23,  4.59s/it]
data 12:   2%|▏         | 10/512 [01:18<1:06:00,  7.89s/it]
INFO:root:函数头: 
    @classmethod
    def serialize(cls, value, *args, **kwargs):

INFO:root:目标函数体: 
        

        if value is None:
            value = ""
        return value

INFO:root:生成结果: 
        if value is None:
            return None
        return str(value)




INFO:root:----------------------------------------
INFO:root:max length: 6457
INFO:root:max position: 6458
INFO:root:target_namespace: rows.rows<folder>.fields<file>.Field<class>.serialize<func>
INFO:root:****************************************

data 12:   0%|          | 0/512 [00:00<?, ?it/s]
data 12:   0%|          | 0/512 [00:30<?, ?it/s]
INFO:root:函数头: 
    @classmethod
    def serialize(cls, value, *args, **kwargs):

INFO:root:目标函数体: 
        

        if value is None:
            value = ""
        return value

INFO:root:生成结果: 
        raise NotImplementedError



INFO:root:----------------------------------------
INFO:root:max length: 6286
INFO:root:max position: 6329
INFO:root:target_namespace: rows.rows<folder>.fields<file>.Field<class>.serialize<func>
INFO:root:****************************************

data 12:   0%|          | 0/512 [00:00<?, ?it/s]
data 12:   0%|          | 0/512 [00:30<?, ?it/s]
INFO:root:函数头: 
    @classmethod
    def serialize(cls, value, *args, **kwargs):

INFO:root:目标函数体: 
        

        if value is None:
            value = ""
        return value

INFO:root:生成结果: 
        raise NotImplementedError



INFO:root:----------------------------------------
INFO:root:max length: 6441
INFO:root:max position: 6447
INFO:root:target_namespace: rows.rows<folder>.fields<file>.Field<class>.serialize<func>
INFO:root:****************************************

data 12:   0%|          | 0/512 [00:00<?, ?it/s]
data 12:   0%|          | 0/512 [00:30<?, ?it/s]
INFO:root:函数头: 
    @classmethod
    def serialize(cls, value, *args, **kwargs):

INFO:root:目标函数体: 
        

        if value is None:
            value = ""
        return value

INFO:root:生成结果: 
        raise NotImplementedError



INFO:root:----------------------------------------
INFO:root:max length: 6377
INFO:root:max position: 6458
INFO:root:target_namespace: rows.rows<folder>.fields<file>.Field<class>.serialize<func>
INFO:root:****************************************
INFO:root:--------data 13--------

data 13:   0%|          | 0/512 [00:00<?, ?it/s]
data 13:   2%|▏         | 10/512 [01:06<55:51,  6.68s/it]
data 13:   2%|▏         | 10/512 [01:50<1:32:36, 11.07s/it]
INFO:root:函数头: 
    @classmethod
    def serialize(cls, value, *args, **kwargs):

INFO:root:目标函数体: 
        if value is None:
            return ""

        return six.text_type(value)

INFO:root:生成结果: 
        if value is None:
            return ""
        return str(value)




INFO:root:----------------------------------------
INFO:root:max length: 6712
INFO:root:max position: 8163
INFO:root:target_namespace: rows.rows<folder>.fields<file>.EmailField<class>.serialize<func>
INFO:root:****************************************

data 13:   0%|          | 0/512 [00:00<?, ?it/s]
data 13:   2%|▏         | 10/512 [01:03<53:04,  6.34s/it]
data 13:   2%|▏         | 10/512 [01:46<1:29:07, 10.65s/it]
INFO:root:函数头: 
    @classmethod
    def serialize(cls, value, *args, **kwargs):

INFO:root:目标函数体: 
        if value is None:
            return ""

        return six.text_type(value)

INFO:root:生成结果: 
        if value is None:
            return ""
        return str(value)




INFO:root:----------------------------------------
INFO:root:max length: 6568
INFO:root:max position: 8148
INFO:root:target_namespace: rows.rows<folder>.fields<file>.EmailField<class>.serialize<func>
INFO:root:****************************************

data 13:   0%|          | 0/512 [00:00<?, ?it/s]
data 13:   2%|▏         | 10/512 [01:03<52:54,  6.32s/it]
data 13:   2%|▏         | 10/512 [01:53<1:35:02, 11.36s/it]
INFO:root:函数头: 
    @classmethod
    def serialize(cls, value, *args, **kwargs):

INFO:root:目标函数体: 
        if value is None:
            return ""

        return six.text_type(value)

INFO:root:生成结果: 
        if value is None:
            return ""
        return str(value)


INFO:root:----------------------------------------
INFO:root:max length: 6767
INFO:root:max position: 8153
INFO:root:target_namespace: rows.rows<folder>.fields<file>.EmailField<class>.serialize<func>
INFO:root:****************************************

data 13:   0%|          | 0/512 [00:00<?, ?it/s]
data 13:   2%|▏         | 10/512 [01:04<54:19,  6.49s/it]
data 13:   4%|▍         | 20/512 [02:13<54:52,  6.69s/it]
data 13:   6%|▌         | 30/512 [03:25<55:34,  6.92s/it]
data 13:   6%|▌         | 30/512 [04:06<1:06:05,  8.23s/it]
INFO:root:函数头: 
    @classmethod
    def serialize(cls, value, *args, **kwargs):

INFO:root:目标函数体: 
        if value is None:
            return ""

        return six.text_type(value)

INFO:root:生成结果: 
        if value is None:
            return ""
        if not cls.EMAIL_REGEXP.match(value):
            raise rows.fields.ValidationError("Invalid email format")
        return str(value)




INFO:root:----------------------------------------
INFO:root:max length: 7648
INFO:root:max position: 8147
INFO:root:target_namespace: rows.rows<folder>.fields<file>.EmailField<class>.serialize<func>
INFO:root:****************************************

data 13:   0%|          | 0/512 [00:00<?, ?it/s]
data 13:   2%|▏         | 10/512 [01:04<54:12,  6.48s/it]
data 13:   2%|▏         | 10/512 [01:52<1:34:17, 11.27s/it]
INFO:root:函数头: 
    @classmethod
    def serialize(cls, value, *args, **kwargs):

INFO:root:目标函数体: 
        if value is None:
            return ""

        return six.text_type(value)

INFO:root:生成结果: 
        if value is None:
            return ""
        return str(value)


INFO:root:----------------------------------------
INFO:root:max length: 6703
INFO:root:max position: 8163
INFO:root:target_namespace: rows.rows<folder>.fields<file>.EmailField<class>.serialize<func>
INFO:root:****************************************
INFO:root:--------data 14--------

data 14:   0%|          | 0/512 [00:00<?, ?it/s]
data 14:   2%|▏         | 10/512 [01:09<58:12,  6.96s/it]
data 14:   4%|▍         | 20/512 [02:20<57:50,  7.05s/it]
data 14:   6%|▌         | 30/512 [03:35<58:02,  7.22s/it]
data 14:   8%|▊         | 40/512 [04:46<56:37,  7.20s/it]
data 14:   8%|▊         | 40/512 [05:16<1:02:16,  7.92s/it]
INFO:root:函数头: 
def as_string(value):

INFO:root:目标函数体: 
    if isinstance(value, six.binary_type):
        raise ValueError("Binary is not supported")
    elif isinstance(value, six.text_type):
        return value
    else:
        return six.text_type(value)

INFO:root:生成结果: 
    if isinstance(value, six.text_type):
        return value
    elif isinstance(value, six.binary_type):
        raise ValueError("Binary data cannot be converted to string")
    else:
        return str(value)




INFO:root:----------------------------------------
INFO:root:max length: 6679
INFO:root:max position: 8160
INFO:root:target_namespace: rows.rows<folder>.fields<file>.as_string<func>
INFO:root:****************************************

data 14:   0%|          | 0/512 [00:00<?, ?it/s]
data 14:   2%|▏         | 10/512 [01:05<55:10,  6.60s/it]
data 14:   4%|▍         | 20/512 [02:18<57:04,  6.96s/it]
data 14:   6%|▌         | 30/512 [03:35<58:39,  7.30s/it]
data 14:   8%|▊         | 40/512 [04:47<57:19,  7.29s/it]
data 14:   8%|▊         | 40/512 [05:18<1:02:41,  7.97s/it]
INFO:root:函数头: 
def as_string(value):

INFO:root:目标函数体: 
    if isinstance(value, six.binary_type):
        raise ValueError("Binary is not supported")
    elif isinstance(value, six.text_type):
        return value
    else:
        return six.text_type(value)

INFO:root:生成结果: 
    if isinstance(value, six.text_type):
        return value
    elif isinstance(value, six.binary_type):
        raise ValueError("Binary data cannot be converted to string")
    else:
        return str(value)




INFO:root:----------------------------------------
INFO:root:max length: 6727
INFO:root:max position: 8184
INFO:root:target_namespace: rows.rows<folder>.fields<file>.as_string<func>
INFO:root:****************************************

data 14:   0%|          | 0/512 [00:00<?, ?it/s]
data 14:   2%|▏         | 10/512 [01:03<53:16,  6.37s/it]
data 14:   4%|▍         | 20/512 [02:16<56:44,  6.92s/it]
data 14:   4%|▍         | 20/512 [03:16<1:20:38,  9.83s/it]
INFO:root:函数头: 
def as_string(value):

INFO:root:目标函数体: 
    if isinstance(value, six.binary_type):
        raise ValueError("Binary is not supported")
    elif isinstance(value, six.text_type):
        return value
    else:
        return six.text_type(value)

INFO:root:生成结果: 
    if isinstance(value, six.binary_type):
        raise ValueError("Binary values are not supported")
    return six.text_type(value)




INFO:root:----------------------------------------
INFO:root:max length: 6587
INFO:root:max position: 8151
INFO:root:target_namespace: rows.rows<folder>.fields<file>.as_string<func>
INFO:root:****************************************

data 14:   0%|          | 0/512 [00:00<?, ?it/s]
data 14:   2%|▏         | 10/512 [01:06<55:30,  6.64s/it]
data 14:   4%|▍         | 20/512 [02:17<56:56,  6.94s/it]
data 14:   6%|▌         | 30/512 [03:32<57:41,  7.18s/it]
data 14:   8%|▊         | 40/512 [04:47<57:18,  7.28s/it]
data 14:   8%|▊         | 40/512 [05:00<59:07,  7.52s/it]
INFO:root:函数头: 
def as_string(value):

INFO:root:目标函数体: 
    if isinstance(value, six.binary_type):
        raise ValueError("Binary is not supported")
    elif isinstance(value, six.text_type):
        return value
    else:
        return six.text_type(value)

INFO:root:生成结果: 
    if isinstance(value, six.text_type):
        return value
    elif isinstance(value, six.binary_type):
        raise ValueError("Binary values are not supported")
    else:
        return str(value)




INFO:root:----------------------------------------
INFO:root:max length: 6771
INFO:root:max position: 8121
INFO:root:target_namespace: rows.rows<folder>.fields<file>.as_string<func>
INFO:root:****************************************

data 14:   0%|          | 0/512 [00:00<?, ?it/s]
data 14:   2%|▏         | 10/512 [01:05<55:01,  6.58s/it]
data 14:   4%|▍         | 20/512 [02:19<57:53,  7.06s/it]
data 14:   6%|▌         | 30/512 [03:35<58:26,  7.28s/it]
data 14:   8%|▊         | 40/512 [04:46<56:58,  7.24s/it]
data 14:   8%|▊         | 40/512 [05:02<59:25,  7.55s/it]
INFO:root:函数头: 
def as_string(value):

INFO:root:目标函数体: 
    if isinstance(value, six.binary_type):
        raise ValueError("Binary is not supported")
    elif isinstance(value, six.text_type):
        return value
    else:
        return six.text_type(value)

INFO:root:生成结果: 
    if isinstance(value, six.text_type):
        return value
    elif isinstance(value, bytes):
        raise ValueError("Binary data cannot be converted to string")
    else:
        return str(value)




INFO:root:----------------------------------------
INFO:root:max length: 6643
INFO:root:max position: 8160
INFO:root:target_namespace: rows.rows<folder>.fields<file>.as_string<func>
INFO:root:****************************************
INFO:root:--------data 15--------

data 15:   0%|          | 0/512 [00:00<?, ?it/s]
data 15:   2%|▏         | 10/512 [01:06<55:24,  6.62s/it]
data 15:   4%|▍         | 20/512 [02:20<58:18,  7.11s/it]
data 15:   4%|▍         | 20/512 [03:20<1:22:02, 10.01s/it]
INFO:root:函数头: 
def get_items(*indexes):

INFO:root:目标函数体: 
    
    return lambda obj: tuple(
        obj[index] if len(obj) > index else None for index in indexes
    )

INFO:root:生成结果: 
    def getter(obj):
        return tuple(obj[index] if index in obj else None for index in indexes)
    return getter




INFO:root:----------------------------------------
INFO:root:max length: 6629
INFO:root:max position: 8136
INFO:root:target_namespace: rows.rows<folder>.fields<file>.get_items<func>
INFO:root:****************************************

data 15:   0%|          | 0/512 [00:00<?, ?it/s]
data 15:   2%|▏         | 10/512 [01:07<56:09,  6.71s/it]
data 15:   4%|▍         | 20/512 [02:21<58:28,  7.13s/it]
data 15:   4%|▍         | 20/512 [03:13<1:19:10,  9.65s/it]
INFO:root:函数头: 
def get_items(*indexes):

INFO:root:目标函数体: 
    
    return lambda obj: tuple(
        obj[index] if len(obj) > index else None for index in indexes
    )

INFO:root:生成结果: 
    def fetcher(obj):
        return tuple(obj.get(index, None) for index in indexes)
    return fetcher


INFO:root:----------------------------------------
INFO:root:max length: 6637
INFO:root:max position: 8193
INFO:root:target_namespace: rows.rows<folder>.fields<file>.get_items<func>
INFO:root:****************************************

data 15:   0%|          | 0/512 [00:00<?, ?it/s]
data 15:   2%|▏         | 10/512 [01:09<58:31,  6.99s/it]
data 15:   2%|▏         | 10/512 [02:14<1:52:42, 13.47s/it]
INFO:root:函数头: 
def get_items(*indexes):

INFO:root:目标函数体: 
    
    return lambda obj: tuple(
        obj[index] if len(obj) > index else None for index in indexes
    )

INFO:root:生成结果: 
    return lambda obj: tuple(obj.get(index, None) for index in indexes)




INFO:root:----------------------------------------
INFO:root:max length: 6620
INFO:root:max position: 8159
INFO:root:target_namespace: rows.rows<folder>.fields<file>.get_items<func>
INFO:root:****************************************

data 15:   0%|          | 0/512 [00:00<?, ?it/s]
data 15:   2%|▏         | 10/512 [01:08<57:07,  6.83s/it]
data 15:   4%|▍         | 20/512 [02:20<57:44,  7.04s/it]
data 15:   4%|▍         | 20/512 [03:32<1:27:16, 10.64s/it]
INFO:root:函数头: 
def get_items(*indexes):

INFO:root:目标函数体: 
    
    return lambda obj: tuple(
        obj[index] if len(obj) > index else None for index in indexes
    )

INFO:root:生成结果: 
    def fetcher(obj):
        return tuple(obj[index] if index in obj else None for index in indexes)
    return fetcher




INFO:root:----------------------------------------
INFO:root:max length: 6699
INFO:root:max position: 8134
INFO:root:target_namespace: rows.rows<folder>.fields<file>.get_items<func>
INFO:root:****************************************

data 15:   0%|          | 0/512 [00:00<?, ?it/s]
data 15:   2%|▏         | 10/512 [01:07<56:28,  6.75s/it]
data 15:   2%|▏         | 10/512 [02:13<1:51:46, 13.36s/it]
INFO:root:函数头: 
def get_items(*indexes):

INFO:root:目标函数体: 
    
    return lambda obj: tuple(
        obj[index] if len(obj) > index else None for index in indexes
    )

INFO:root:生成结果: 
    return lambda obj: tuple(obj.get(index, None) for index in indexes)




INFO:root:----------------------------------------
INFO:root:max length: 6521
INFO:root:max position: 8101
INFO:root:target_namespace: rows.rows<folder>.fields<file>.get_items<func>
INFO:root:****************************************
INFO:root:已生成15条结果
INFO:root:--------data 16--------

data 16:   0%|          | 0/512 [00:00<?, ?it/s]
data 16:   2%|▏         | 10/512 [00:13<11:36,  1.39s/it]
data 16:   4%|▍         | 20/512 [00:24<09:34,  1.17s/it]
data 16:   6%|▌         | 30/512 [00:34<09:02,  1.12s/it]
data 16:   8%|▊         | 40/512 [00:46<08:52,  1.13s/it]
data 16:  10%|▉         | 50/512 [00:57<08:45,  1.14s/it]
data 16:  12%|█▏        | 60/512 [01:09<08:38,  1.15s/it]
data 16:  14%|█▎        | 70/512 [01:20<08:30,  1.15s/it]
data 16:  14%|█▎        | 70/512 [01:28<09:19,  1.27s/it]
INFO:root:函数头: 
def load_dict_file(path):

INFO:root:目标函数体: 
    
    result = {}
    if path:
        if not os.path.exists(path):
            logger.warning('file not found.%s' % path)
            return result
        else:
            with open(path, 'r', encoding='utf-8') as f:
                for line in f:
                    line = line.strip()
                    if line.startswith('#'):
                        continue
                    terms = line.split()
                    if len(terms) < 2:
                        continue
                    result[terms[0]] = terms[1]
    return result

INFO:root:生成结果: 
    dictionary = {}
    if os.path.exists(path):
        with open(path, 'r', encoding='utf-8') as f:
            for line in f:
                line = line.strip()
                if line.startswith('#'):
                    continue
                if line:
                    word, freq = line.split('\t')
                    dictionary[word] = int(freq)
    return dictionary




INFO:root:----------------------------------------
INFO:root:max length: 2965
INFO:root:max position: 2965
INFO:root:target_namespace: pycorrector.pycorrector<folder>.proper_corrector<file>.load_dict_file<func>
INFO:root:****************************************

data 16:   0%|          | 0/512 [00:00<?, ?it/s]
data 16:   2%|▏         | 10/512 [00:11<09:18,  1.11s/it]
data 16:   4%|▍         | 20/512 [00:22<09:20,  1.14s/it]
data 16:   6%|▌         | 30/512 [00:32<08:38,  1.08s/it]
data 16:   8%|▊         | 40/512 [00:44<08:46,  1.12s/it]
data 16:  10%|▉         | 50/512 [00:56<08:43,  1.13s/it]
data 16:  12%|█▏        | 60/512 [01:07<08:37,  1.15s/it]
data 16:  14%|█▎        | 70/512 [01:19<08:24,  1.14s/it]
data 16:  14%|█▎        | 70/512 [01:29<09:25,  1.28s/it]
INFO:root:函数头: 
def load_dict_file(path):

INFO:root:目标函数体: 
    
    result = {}
    if path:
        if not os.path.exists(path):
            logger.warning('file not found.%s' % path)
            return result
        else:
            with open(path, 'r', encoding='utf-8') as f:
                for line in f:
                    line = line.strip()
                    if line.startswith('#'):
                        continue
                    terms = line.split()
                    if len(terms) < 2:
                        continue
                    result[terms[0]] = terms[1]
    return result

INFO:root:生成结果: 
    if not os.path.exists(path):
        return {}
    with open(path, 'r', encoding='utf-8') as f:
        dictionary = {}
        for line in f:
            line = line.strip()
            if line.startswith('#'):
                continue
            if line:
                word, freq = line.split()
                dictionary[word] = int(freq)
    return dictionary




INFO:root:----------------------------------------
INFO:root:max length: 2967
INFO:root:max position: 2967
INFO:root:target_namespace: pycorrector.pycorrector<folder>.proper_corrector<file>.load_dict_file<func>
INFO:root:****************************************

data 16:   0%|          | 0/512 [00:00<?, ?it/s]
data 16:   2%|▏         | 10/512 [00:10<08:22,  1.00s/it]
data 16:   4%|▍         | 20/512 [00:21<08:55,  1.09s/it]
data 16:   6%|▌         | 30/512 [00:32<08:53,  1.11s/it]
data 16:   8%|▊         | 40/512 [00:44<08:54,  1.13s/it]
data 16:  10%|▉         | 50/512 [00:55<08:43,  1.13s/it]
data 16:  12%|█▏        | 60/512 [01:07<08:33,  1.14s/it]
data 16:  14%|█▎        | 70/512 [01:19<08:32,  1.16s/it]
data 16:  14%|█▎        | 70/512 [01:28<09:17,  1.26s/it]
INFO:root:函数头: 
def load_dict_file(path):

INFO:root:目标函数体: 
    
    result = {}
    if path:
        if not os.path.exists(path):
            logger.warning('file not found.%s' % path)
            return result
        else:
            with open(path, 'r', encoding='utf-8') as f:
                for line in f:
                    line = line.strip()
                    if line.startswith('#'):
                        continue
                    terms = line.split()
                    if len(terms) < 2:
                        continue
                    result[terms[0]] = terms[1]
    return result

INFO:root:生成结果: 
    if not path or not os.path.exists(path):
        return {}
    words = {}
    with open(path, 'r', encoding='utf-8') as f:
        for line in f:
            line = line.strip()
            if line.startswith('#'):
                continue
            if line:
                words[line.split()[0]] = line.split()[1]
    return words




INFO:root:----------------------------------------
INFO:root:max length: 2967
INFO:root:max position: 2967
INFO:root:target_namespace: pycorrector.pycorrector<folder>.proper_corrector<file>.load_dict_file<func>
INFO:root:****************************************

data 16:   0%|          | 0/512 [00:00<?, ?it/s]
data 16:   2%|▏         | 10/512 [00:10<09:05,  1.09s/it]
data 16:   4%|▍         | 20/512 [00:22<09:20,  1.14s/it]
data 16:   6%|▌         | 30/512 [00:34<09:13,  1.15s/it]
data 16:   8%|▊         | 40/512 [00:46<09:14,  1.17s/it]
data 16:  10%|▉         | 50/512 [00:58<09:05,  1.18s/it]
data 16:  12%|█▏        | 60/512 [01:07<08:19,  1.10s/it]
data 16:  14%|█▎        | 70/512 [01:19<08:14,  1.12s/it]
data 16:  14%|█▎        | 70/512 [01:30<09:29,  1.29s/it]
INFO:root:函数头: 
def load_dict_file(path):

INFO:root:目标函数体: 
    
    result = {}
    if path:
        if not os.path.exists(path):
            logger.warning('file not found.%s' % path)
            return result
        else:
            with open(path, 'r', encoding='utf-8') as f:
                for line in f:
                    line = line.strip()
                    if line.startswith('#'):
                        continue
                    terms = line.split()
                    if len(terms) < 2:
                        continue
                    result[terms[0]] = terms[1]
    return result

INFO:root:生成结果: 
    dictionary = {}
    if path and os.path.exists(path):
        with open(path, 'r', encoding='utf-8') as f:
            for line in f:
                line = line.strip()
                if line.startswith('#'):
                    continue
                if line:
                    word, freq = line.split('\t')
                    dictionary[word] = int(freq)
    return dictionary




INFO:root:----------------------------------------
INFO:root:max length: 2967
INFO:root:max position: 2967
INFO:root:target_namespace: pycorrector.pycorrector<folder>.proper_corrector<file>.load_dict_file<func>
INFO:root:****************************************

data 16:   0%|          | 0/512 [00:00<?, ?it/s]
data 16:   2%|▏         | 10/512 [00:09<07:47,  1.07it/s]
data 16:   4%|▍         | 20/512 [00:20<08:44,  1.07s/it]
data 16:   6%|▌         | 30/512 [00:32<08:49,  1.10s/it]
data 16:   8%|▊         | 40/512 [00:43<08:44,  1.11s/it]
data 16:  10%|▉         | 50/512 [00:54<08:37,  1.12s/it]
data 16:  12%|█▏        | 60/512 [01:06<08:31,  1.13s/it]
data 16:  14%|█▎        | 70/512 [01:18<08:25,  1.14s/it]
data 16:  14%|█▎        | 70/512 [01:26<09:05,  1.23s/it]
INFO:root:函数头: 
def load_dict_file(path):

INFO:root:目标函数体: 
    
    result = {}
    if path:
        if not os.path.exists(path):
            logger.warning('file not found.%s' % path)
            return result
        else:
            with open(path, 'r', encoding='utf-8') as f:
                for line in f:
                    line = line.strip()
                    if line.startswith('#'):
                        continue
                    terms = line.split()
                    if len(terms) < 2:
                        continue
                    result[terms[0]] = terms[1]
    return result

INFO:root:生成结果: 
    words = {}
    if path and os.path.exists(path):
        with open(path, 'r', encoding='utf-8') as f:
            for line in f:
                line = line.strip()
                if line.startswith('#'):
                    continue
                if line:
                    word, freq = line.split()
                    words[word] = int(freq)
    return words




INFO:root:----------------------------------------
INFO:root:max length: 2965
INFO:root:max position: 2965
INFO:root:target_namespace: pycorrector.pycorrector<folder>.proper_corrector<file>.load_dict_file<func>
INFO:root:****************************************
INFO:root:--------data 17--------

data 17:   0%|          | 0/512 [00:00<?, ?it/s]
data 17:   2%|▏         | 10/512 [01:31<1:16:26,  9.14s/it]
data 17:   4%|▍         | 20/512 [03:18<1:22:32, 10.07s/it]
data 17:   6%|▌         | 30/512 [05:02<1:22:07, 10.22s/it]
data 17:   8%|▊         | 40/512 [06:45<1:20:32, 10.24s/it]
data 17:  10%|▉         | 50/512 [08:32<1:20:19, 10.43s/it]
data 17:  12%|█▏        | 60/512 [10:22<1:19:53, 10.61s/it]
data 17:  12%|█▏        | 60/512 [12:00<1:30:25, 12.00s/it]
INFO:root:函数头: 
def envelop_spans(spans, envelopes):

INFO:root:目标函数体: 
    index = 0
    for envelope in envelopes:
        chunk = []
        while index < len(spans):
            span = spans[index]
            index += 1
            if span.start < envelope.start:
                continue
            elif span.stop <= envelope.stop:
                chunk.append(span)
            else:
                index -= 1
                break
        yield chunk

INFO:root:生成结果: 
    # Implement the function body based on the provided code prefix and other resources in the current project, without generating any additional content! The current function is located in file natasha/span.py, prohibit cyclic calling the current function! You can use resources in the current project, and you MUST write import statements FIRST to call the corresponding resource.


INFO:root:----------------------------------------
INFO:root:max length: 6828
INFO:root:max position: 7686
INFO:root:target_namespace: natasha.natasha<folder>.span<file>.envelop_spans<func>
INFO:root:****************************************

data 17:   0%|          | 0/512 [00:00<?, ?it/s]
data 17:   2%|▏         | 10/512 [01:30<1:15:19,  9.00s/it]
data 17:   2%|▏         | 10/512 [01:49<1:31:28, 10.93s/it]
INFO:root:函数头: 
def envelop_spans(spans, envelopes):

INFO:root:目标函数体: 
    index = 0
    for envelope in envelopes:
        chunk = []
        while index < len(spans):
            span = spans[index]
            index += 1
            if span.start < envelope.start:
                continue
            elif span.stop <= envelope.stop:
                chunk.append(span)
            else:
                index -= 1
                break
        yield chunk

INFO:root:生成结果: 
    for span in spans:
        yield span




INFO:root:----------------------------------------
INFO:root:max length: 5398
INFO:root:max position: 6695
INFO:root:target_namespace: natasha.natasha<folder>.span<file>.envelop_spans<func>
INFO:root:****************************************

data 17:   0%|          | 0/512 [00:00<?, ?it/s]
data 17:   2%|▏         | 10/512 [01:31<1:16:26,  9.14s/it]
data 17:   4%|▍         | 20/512 [03:12<1:19:36,  9.71s/it]
data 17:   6%|▌         | 30/512 [05:00<1:22:08, 10.23s/it]
data 17:   8%|▊         | 40/512 [06:47<1:21:40, 10.38s/it]
data 17:  10%|▉         | 50/512 [08:28<1:19:21, 10.31s/it]
data 17:  12%|█▏        | 60/512 [10:13<1:18:05, 10.37s/it]
data 17:  12%|█▏        | 60/512 [11:49<1:29:02, 11.82s/it]
INFO:root:函数头: 
def envelop_spans(spans, envelopes):

INFO:root:目标函数体: 
    index = 0
    for envelope in envelopes:
        chunk = []
        while index < len(spans):
            span = spans[index]
            index += 1
            if span.start < envelope.start:
                continue
            elif span.stop <= envelope.stop:
                chunk.append(span)
            else:
                index -= 1
                break
        yield chunk

INFO:root:生成结果: 
    # Implement the function body based on the provided code prefix and other resources in the current project, without generating any additional content! The current function is located in file natasha/span.py, prohibit cyclic calling the current function! You can use resources in the current project, and you MUST write import statements FIRST to call the corresponding resource.


INFO:root:----------------------------------------
INFO:root:max length: 6403
INFO:root:max position: 7608
INFO:root:target_namespace: natasha.natasha<folder>.span<file>.envelop_spans<func>
INFO:root:****************************************

data 17:   0%|          | 0/512 [00:00<?, ?it/s]
data 17:   2%|▏         | 10/512 [01:33<1:17:54,  9.31s/it]
data 17:   4%|▍         | 20/512 [03:16<1:21:25,  9.93s/it]
data 17:   6%|▌         | 30/512 [05:01<1:21:36, 10.16s/it]
data 17:   8%|▊         | 40/512 [06:47<1:21:28, 10.36s/it]
data 17:  10%|▉         | 50/512 [08:27<1:18:49, 10.24s/it]
data 17:  12%|█▏        | 60/512 [10:14<1:18:13, 10.38s/it]
data 17:  12%|█▏        | 60/512 [11:56<1:29:57, 11.94s/it]
INFO:root:函数头: 
def envelop_spans(spans, envelopes):

INFO:root:目标函数体: 
    index = 0
    for envelope in envelopes:
        chunk = []
        while index < len(spans):
            span = spans[index]
            index += 1
            if span.start < envelope.start:
                continue
            elif span.stop <= envelope.stop:
                chunk.append(span)
            else:
                index -= 1
                break
        yield chunk

INFO:root:生成结果: 
    # Implement the function body based on the provided code prefix and other resources in the current project, without generating any additional content! The current function is located in file natasha/span.py, prohibit cyclic calling the current function! You can use resources in the current project, and you MUST write import statements FIRST to call the corresponding resource.


INFO:root:----------------------------------------
INFO:root:max length: 6497
INFO:root:max position: 7580
INFO:root:target_namespace: natasha.natasha<folder>.span<file>.envelop_spans<func>
INFO:root:****************************************

data 17:   0%|          | 0/512 [00:00<?, ?it/s]
data 17:   2%|▏         | 10/512 [01:30<1:15:46,  9.06s/it]
data 17:   4%|▍         | 20/512 [03:10<1:18:51,  9.62s/it]
data 17:   6%|▌         | 30/512 [04:48<1:17:46,  9.68s/it]
data 17:   6%|▌         | 30/512 [05:07<1:22:20, 10.25s/it]
INFO:root:函数头: 
def envelop_spans(spans, envelopes):

INFO:root:目标函数体: 
    index = 0
    for envelope in envelopes:
        chunk = []
        while index < len(spans):
            span = spans[index]
            index += 1
            if span.start < envelope.start:
                continue
            elif span.stop <= envelope.stop:
                chunk.append(span)
            else:
                index -= 1
                break
        yield chunk

INFO:root:生成结果: 
    for span in spans:
        for envelope in envelopes:
            if span.start >= envelope.start and span.stop <= envelope.stop:
                yield span




INFO:root:----------------------------------------
INFO:root:max length: 6485
INFO:root:max position: 7508
INFO:root:target_namespace: natasha.natasha<folder>.span<file>.envelop_spans<func>
INFO:root:****************************************
INFO:root:--------data 18--------

data 18:   0%|          | 0/512 [00:00<?, ?it/s]
data 18:   2%|▏         | 10/512 [00:17<14:14,  1.70s/it]
data 18:   4%|▍         | 20/512 [00:33<13:29,  1.65s/it]
data 18:   6%|▌         | 30/512 [00:51<13:47,  1.72s/it]
data 18:   8%|▊         | 40/512 [01:06<13:06,  1.67s/it]
data 18:  10%|▉         | 50/512 [01:22<12:35,  1.64s/it]
data 18:  10%|▉         | 50/512 [01:31<14:07,  1.83s/it]
INFO:root:函数头: 
def parse_unique_urlencoded(content):

INFO:root:目标函数体: 
    
    urlencoded_params = urllib.parse.parse_qs(content)
    params = {}
    for key, value in urlencoded_params.items():
        if len(value) != 1:
            msg = "URL-encoded content contains a repeated value:" "%s -> %s" % (
                key,
                ", ".join(value),
            )
            raise ValueError(msg)
        params[key] = value[0]
    return params

INFO:root:生成结果: 
    result = {}
    for pair in content.split("&"):
        key, value = pair.split("=")
        if key in result:
            raise ValueError(f"Duplicate key '{key}' found in URL-encoded content.")
        result[key] = value
    return result




INFO:root:----------------------------------------
INFO:root:max length: 3942
INFO:root:max position: 3942
INFO:root:target_namespace: google-api-python-client.googleapiclient<folder>._helpers<file>.parse_unique_urlencoded<func>
INFO:root:****************************************

data 18:   0%|          | 0/512 [00:00<?, ?it/s]
data 18:   2%|▏         | 10/512 [00:15<12:52,  1.54s/it]
data 18:   4%|▍         | 20/512 [00:31<13:02,  1.59s/it]
data 18:   6%|▌         | 30/512 [00:49<13:22,  1.66s/it]
data 18:   8%|▊         | 40/512 [01:05<12:50,  1.63s/it]
data 18:  10%|▉         | 50/512 [01:21<12:32,  1.63s/it]
data 18:  12%|█▏        | 60/512 [01:37<12:19,  1.64s/it]
data 18:  12%|█▏        | 60/512 [01:54<14:21,  1.91s/it]
INFO:root:函数头: 
def parse_unique_urlencoded(content):

INFO:root:目标函数体: 
    
    urlencoded_params = urllib.parse.parse_qs(content)
    params = {}
    for key, value in urlencoded_params.items():
        if len(value) != 1:
            msg = "URL-encoded content contains a repeated value:" "%s -> %s" % (
                key,
                ", ".join(value),
            )
            raise ValueError(msg)
        params[key] = value[0]
    return params

INFO:root:生成结果: 
    parsed_content = urllib.parse.parse_qs(content)
    unique_content = {}
    for key, values in parsed_content.items():
        if len(values) > 1:
            raise ValueError(f"Key '{key}' appears more than once in the URL-encoded content.")
        unique_content[key] = values[0]
    return unique_content




INFO:root:----------------------------------------
INFO:root:max length: 3956
INFO:root:max position: 3956
INFO:root:target_namespace: google-api-python-client.googleapiclient<folder>._helpers<file>.parse_unique_urlencoded<func>
INFO:root:****************************************

data 18:   0%|          | 0/512 [00:00<?, ?it/s]
data 18:   2%|▏         | 10/512 [00:16<14:04,  1.68s/it]
data 18:   4%|▍         | 20/512 [00:33<13:44,  1.68s/it]
data 18:   6%|▌         | 30/512 [00:49<13:08,  1.64s/it]
data 18:   8%|▊         | 40/512 [01:04<12:35,  1.60s/it]
data 18:  10%|▉         | 50/512 [01:20<12:10,  1.58s/it]
data 18:  12%|█▏        | 60/512 [01:37<12:17,  1.63s/it]
data 18:  12%|█▏        | 60/512 [01:50<13:54,  1.85s/it]
INFO:root:函数头: 
def parse_unique_urlencoded(content):

INFO:root:目标函数体: 
    
    urlencoded_params = urllib.parse.parse_qs(content)
    params = {}
    for key, value in urlencoded_params.items():
        if len(value) != 1:
            msg = "URL-encoded content contains a repeated value:" "%s -> %s" % (
                key,
                ", ".join(value),
            )
            raise ValueError(msg)
        params[key] = value[0]
    return params

INFO:root:生成结果: 
    parsed_content = urllib.parse.parse_qs(content)
    unique_content = {}
    for key, values in parsed_content.items():
        if len(values) > 1:
            raise ValueError(f"Key '{key}' appears more than once in URL-encoded content.")
        unique_content[key] = values[0]
    return unique_content


INFO:root:----------------------------------------
INFO:root:max length: 3955
INFO:root:max position: 3955
INFO:root:target_namespace: google-api-python-client.googleapiclient<folder>._helpers<file>.parse_unique_urlencoded<func>
INFO:root:****************************************

data 18:   0%|          | 0/512 [00:00<?, ?it/s]
data 18:   2%|▏         | 10/512 [00:15<13:10,  1.58s/it]
data 18:   4%|▍         | 20/512 [00:34<14:07,  1.72s/it]
data 18:   6%|▌         | 30/512 [00:50<13:26,  1.67s/it]
data 18:   8%|▊         | 40/512 [01:06<13:00,  1.65s/it]
data 18:  10%|▉         | 50/512 [01:22<12:31,  1.63s/it]
data 18:  12%|█▏        | 60/512 [03:41<43:43,  5.80s/it]
data 18:  14%|█▎        | 70/512 [03:57<32:34,  4.42s/it]
data 18:  14%|█▎        | 70/512 [04:06<25:58,  3.53s/it]
INFO:root:函数头: 
def parse_unique_urlencoded(content):

INFO:root:目标函数体: 
    
    urlencoded_params = urllib.parse.parse_qs(content)
    params = {}
    for key, value in urlencoded_params.items():
        if len(value) != 1:
            msg = "URL-encoded content contains a repeated value:" "%s -> %s" % (
                key,
                ", ".join(value),
            )
            raise ValueError(msg)
        params[key] = value[0]
    return params

INFO:root:生成结果: 
    result = {}
    pairs = content.split("&")
    seen_keys = set()
    for pair in pairs:
        key, value = pair.split("=")
        if key in seen_keys:
            raise ValueError(f"Key '{key}' appears more than once in URL-encoded content.")
        seen_keys.add(key)
        result[key] = value
    return result




INFO:root:----------------------------------------
INFO:root:max length: 3962
INFO:root:max position: 3962
INFO:root:target_namespace: google-api-python-client.googleapiclient<folder>._helpers<file>.parse_unique_urlencoded<func>
INFO:root:****************************************

data 18:   0%|          | 0/512 [00:00<?, ?it/s]
data 18:   2%|▏         | 10/512 [00:15<13:02,  1.56s/it]
data 18:   4%|▍         | 20/512 [00:33<13:57,  1.70s/it]
data 18:   6%|▌         | 30/512 [00:49<13:25,  1.67s/it]
data 18:   8%|▊         | 40/512 [01:06<13:00,  1.65s/it]
data 18:  10%|▉         | 50/512 [01:23<13:01,  1.69s/it]
data 18:  12%|█▏        | 60/512 [01:39<12:29,  1.66s/it]
data 18:  12%|█▏        | 60/512 [01:53<14:18,  1.90s/it]
INFO:root:函数头: 
def parse_unique_urlencoded(content):

INFO:root:目标函数体: 
    
    urlencoded_params = urllib.parse.parse_qs(content)
    params = {}
    for key, value in urlencoded_params.items():
        if len(value) != 1:
            msg = "URL-encoded content contains a repeated value:" "%s -> %s" % (
                key,
                ", ".join(value),
            )
            raise ValueError(msg)
        params[key] = value[0]
    return params

INFO:root:生成结果: 
    parsed_content = urllib.parse.parse_qs(content)
    unique_content = {}
    for key, value in parsed_content.items():
        if len(value) > 1:
            raise ValueError(f"Key '{key}' appears more than once in URL-encoded content.")
        unique_content[key] = value[0]
    return unique_content




INFO:root:----------------------------------------
INFO:root:max length: 3955
INFO:root:max position: 3955
INFO:root:target_namespace: google-api-python-client.googleapiclient<folder>._helpers<file>.parse_unique_urlencoded<func>
INFO:root:****************************************
INFO:root:--------data 19--------

data 19:   0%|          | 0/512 [00:00<?, ?it/s]
data 19:   2%|▏         | 10/512 [01:17<1:05:02,  7.77s/it]
data 19:   4%|▍         | 20/512 [02:41<1:06:25,  8.10s/it]
data 19:   6%|▌         | 30/512 [06:05<1:50:22, 13.74s/it]
data 19:   8%|▊         | 40/512 [10:26<2:26:32, 18.63s/it]
data 19:  10%|▉         | 50/512 [11:45<1:53:32, 14.74s/it]
data 19:  10%|▉         | 50/512 [12:53<1:59:05, 15.47s/it]
INFO:root:函数头: 
async def auto_aiter(
    iterable: "t.Union[t.AsyncIterable[V], t.Iterable[V]]",
) -> "t.AsyncIterator[V]":

INFO:root:目标函数体: 
    if hasattr(iterable, "__aiter__"):
        async for item in t.cast("t.AsyncIterable[V]", iterable):
            yield item
    else:
        for item in t.cast("t.Iterable[V]", iterable):
            yield item

INFO:root:生成结果: 
    if hasattr(iterable, "__aiter__"):
        async def async_iter():
            async for item in iterable:
                yield item

        return async_iter()
    else:
        def sync_iter():
            for item in iterable:
                yield item

        return sync_iter()




INFO:root:----------------------------------------
INFO:root:max length: 7009
INFO:root:max position: 9617
INFO:root:target_namespace: Jinja2.src<folder>.jinja2<folder>.async_utils<file>.auto_aiter<func>
INFO:root:****************************************

data 19:   0%|          | 0/512 [00:00<?, ?it/s]
data 19:   2%|▏         | 10/512 [01:10<58:55,  7.04s/it]
data 19:   4%|▍         | 20/512 [02:32<1:03:21,  7.73s/it]
data 19:   6%|▌         | 30/512 [03:45<1:00:29,  7.53s/it]
data 19:   8%|▊         | 40/512 [05:09<1:02:02,  7.89s/it]
data 19:   8%|▊         | 40/512 [05:25<1:04:06,  8.15s/it]
INFO:root:函数头: 
async def auto_aiter(
    iterable: "t.Union[t.AsyncIterable[V], t.Iterable[V]]",
) -> "t.AsyncIterator[V]":

INFO:root:目标函数体: 
    if hasattr(iterable, "__aiter__"):
        async for item in t.cast("t.AsyncIterable[V]", iterable):
            yield item
    else:
        for item in t.cast("t.Iterable[V]", iterable):
            yield item

INFO:root:生成结果: 
    if inspect.isasyncgen(iterable):
        return iterable

    async def async_generator() -> t.AsyncIterator[V]:
        for item in iterable:
            yield item

    return async_generator()




INFO:root:----------------------------------------
INFO:root:max length: 7314
INFO:root:max position: 8378
INFO:root:target_namespace: Jinja2.src<folder>.jinja2<folder>.async_utils<file>.auto_aiter<func>
INFO:root:****************************************

data 19:   0%|          | 0/512 [00:00<?, ?it/s]
data 19:   2%|▏         | 10/512 [01:09<58:26,  6.98s/it]
data 19:   4%|▍         | 20/512 [02:27<1:00:52,  7.42s/it]
data 19:   4%|▍         | 20/512 [03:11<1:18:22,  9.56s/it]
INFO:root:函数头: 
async def auto_aiter(
    iterable: "t.Union[t.AsyncIterable[V], t.Iterable[V]]",
) -> "t.AsyncIterator[V]":

INFO:root:目标函数体: 
    if hasattr(iterable, "__aiter__"):
        async for item in t.cast("t.AsyncIterable[V]", iterable):
            yield item
    else:
        for item in t.cast("t.Iterable[V]", iterable):
            yield item

INFO:root:生成结果: 
    if inspect.isasyncgen(iterable):
        yield from iterable
    else:
        yield from iter(iterable)




INFO:root:----------------------------------------
INFO:root:max length: 7174
INFO:root:max position: 8320
INFO:root:target_namespace: Jinja2.src<folder>.jinja2<folder>.async_utils<file>.auto_aiter<func>
INFO:root:****************************************

data 19:   0%|          | 0/512 [00:00<?, ?it/s]
data 19:   2%|▏         | 10/512 [01:12<1:01:01,  7.29s/it]
data 19:   4%|▍         | 20/512 [02:33<1:03:28,  7.74s/it]
data 19:   4%|▍         | 20/512 [03:21<1:22:34, 10.07s/it]
INFO:root:函数头: 
async def auto_aiter(
    iterable: "t.Union[t.AsyncIterable[V], t.Iterable[V]]",
) -> "t.AsyncIterator[V]":

INFO:root:目标函数体: 
    if hasattr(iterable, "__aiter__"):
        async for item in t.cast("t.AsyncIterable[V]", iterable):
            yield item
    else:
        for item in t.cast("t.Iterable[V]", iterable):
            yield item

INFO:root:生成结果: 
    if inspect.isasyncgenerator(iterable):
        yield from iterable
    else:
        yield from iter(iterable)




INFO:root:----------------------------------------
INFO:root:max length: 6720
INFO:root:max position: 8882
INFO:root:target_namespace: Jinja2.src<folder>.jinja2<folder>.async_utils<file>.auto_aiter<func>
INFO:root:****************************************

data 19:   0%|          | 0/512 [00:00<?, ?it/s]
data 19:   2%|▏         | 10/512 [01:10<59:21,  7.09s/it]
data 19:   4%|▍         | 20/512 [02:33<1:03:32,  7.75s/it]
data 19:   6%|▌         | 30/512 [03:53<1:03:25,  7.90s/it]
data 19:   8%|▊         | 40/512 [09:11<2:16:15, 17.32s/it]
data 19:  10%|▉         | 50/512 [10:26<1:46:07, 13.78s/it]
data 19:  12%|█▏        | 60/512 [11:42<1:27:56, 11.67s/it]
data 19:  14%|█▎        | 70/512 [12:59<1:16:35, 10.40s/it]
data 19:  16%|█▌        | 80/512 [14:20<1:09:31,  9.66s/it]
data 19:  16%|█▌        | 80/512 [15:20<1:22:50, 11.51s/it]
INFO:root:函数头: 
async def auto_aiter(
    iterable: "t.Union[t.AsyncIterable[V], t.Iterable[V]]",
) -> "t.AsyncIterator[V]":

INFO:root:目标函数体: 
    if hasattr(iterable, "__aiter__"):
        async for item in t.cast("t.AsyncIterable[V]", iterable):
            yield item
    else:
        for item in t.cast("t.Iterable[V]", iterable):
            yield item

INFO:root:生成结果: 
    if t.TYPE_CHECKING:
        import typing_extensions as te

    async def async_iter_helper(iterable: "t.Union[t.AsyncIterable[V], t.Iterable[V]]") -> "t.AsyncIterator[V]":
        async for item in iterable:
            yield item

    if hasattr(iterable, "__aiter__"):
        return async_iter_helper(iterable)
    else:
        return iter(iterable)




INFO:root:----------------------------------------
INFO:root:max length: 7538
INFO:root:max position: 8951
INFO:root:target_namespace: Jinja2.src<folder>.jinja2<folder>.async_utils<file>.auto_aiter<func>
INFO:root:****************************************
INFO:root:--------data 20--------

data 20:   0%|          | 0/512 [00:00<?, ?it/s]
data 20:   2%|▏         | 10/512 [01:21<1:08:10,  8.15s/it]
data 20:   2%|▏         | 10/512 [01:29<1:14:44,  8.93s/it]
INFO:root:函数头: 
def consume(iterable: t.Iterable[t.Any]) -> None:

INFO:root:目标函数体: 
    
    for _ in iterable:
        pass

INFO:root:生成结果: 
    for _ in iterable:
        pass




INFO:root:----------------------------------------
INFO:root:max length: 6136
INFO:root:max position: 7787
INFO:root:target_namespace: Jinja2.src<folder>.jinja2<folder>.utils<file>.consume<func>
INFO:root:****************************************

data 20:   0%|          | 0/512 [00:00<?, ?it/s]
data 20:   2%|▏         | 10/512 [01:20<1:07:11,  8.03s/it]
data 20:   2%|▏         | 10/512 [01:31<1:16:11,  9.11s/it]
INFO:root:函数头: 
def consume(iterable: t.Iterable[t.Any]) -> None:

INFO:root:目标函数体: 
    
    for _ in iterable:
        pass

INFO:root:生成结果: 
    for _ in iterable:
        pass




INFO:root:----------------------------------------
INFO:root:max length: 6948
INFO:root:max position: 8303
INFO:root:target_namespace: Jinja2.src<folder>.jinja2<folder>.utils<file>.consume<func>
INFO:root:****************************************

data 20:   0%|          | 0/512 [00:00<?, ?it/s]
data 20:   2%|▏         | 10/512 [01:15<1:03:29,  7.59s/it]
data 20:   2%|▏         | 10/512 [01:23<1:10:09,  8.38s/it]
INFO:root:函数头: 
def consume(iterable: t.Iterable[t.Any]) -> None:

INFO:root:目标函数体: 
    
    for _ in iterable:
        pass

INFO:root:生成结果: 
    for _ in iterable:
        pass




INFO:root:----------------------------------------
INFO:root:max length: 6377
INFO:root:max position: 8140
INFO:root:target_namespace: Jinja2.src<folder>.jinja2<folder>.utils<file>.consume<func>
INFO:root:****************************************

data 20:   0%|          | 0/512 [00:00<?, ?it/s]
data 20:   2%|▏         | 10/512 [01:11<59:58,  7.17s/it]
data 20:   2%|▏         | 10/512 [01:19<1:06:36,  7.96s/it]
INFO:root:函数头: 
def consume(iterable: t.Iterable[t.Any]) -> None:

INFO:root:目标函数体: 
    
    for _ in iterable:
        pass

INFO:root:生成结果: 
    for _ in iterable:
        pass




INFO:root:----------------------------------------
INFO:root:max length: 6324
INFO:root:max position: 8407
INFO:root:target_namespace: Jinja2.src<folder>.jinja2<folder>.utils<file>.consume<func>
INFO:root:****************************************

data 20:   0%|          | 0/512 [00:00<?, ?it/s]
data 20:   2%|▏         | 10/512 [01:11<1:00:09,  7.19s/it]
data 20:   2%|▏         | 10/512 [01:19<1:06:32,  7.95s/it]
INFO:root:函数头: 
def consume(iterable: t.Iterable[t.Any]) -> None:

INFO:root:目标函数体: 
    
    for _ in iterable:
        pass

INFO:root:生成结果: 
    for _ in iterable:
        pass




INFO:root:----------------------------------------
INFO:root:max length: 6167
INFO:root:max position: 7660
INFO:root:target_namespace: Jinja2.src<folder>.jinja2<folder>.utils<file>.consume<func>
INFO:root:****************************************
INFO:root:--------data 21--------

data 21:   0%|          | 0/512 [00:00<?, ?it/s]Token indices sequence length is longer than the specified maximum sequence length for this model (34459 > 32768). Running this sequence through the model will result in indexing errors

data 21:   2%|▏         | 10/512 [00:32<26:58,  3.22s/it]
data 21:   4%|▍         | 20/512 [01:03<25:52,  3.15s/it]
data 21:   6%|▌         | 30/512 [01:34<25:23,  3.16s/it]
data 21:   8%|▊         | 40/512 [02:06<24:41,  3.14s/it]
data 21:  10%|▉         | 50/512 [02:37<24:10,  3.14s/it]
data 21:  12%|█▏        | 60/512 [03:08<23:29,  3.12s/it]
data 21:  12%|█▏        | 60/512 [03:11<23:58,  3.18s/it]
INFO:root:函数头: 
def segment(sentence, cut_type='word', pos=False):

INFO:root:目标函数体: 
    
    if pos:
        if cut_type == 'word':
            word_pos_seq = posseg.lcut(sentence)
            word_seq, pos_seq = [], []
            for w, p in word_pos_seq:
                word_seq.append(w)
                pos_seq.append(p)
            return word_seq, pos_seq
        elif cut_type == 'char':
            word_seq = list(sentence)
            pos_seq = []
            for w in word_seq:
                w_p = posseg.lcut(w)
                pos_seq.append(w_p[0].flag)
            return word_seq, pos_seq
    else:
        if cut_type == 'word':
            return jieba.lcut(sentence)
        elif cut_type == 'char':
            return list(sentence)

INFO:root:生成结果: 
    if cut_type == 'word':
        if pos:
            return posseg.cut(sentence)
        else:
            return jieba.cut(sentence)
    elif cut_type == 'char':
        return list(sentence)
    else:
        raise ValueError('Unsupported cut type: ' + cut_type)




INFO:root:----------------------------------------
INFO:root:max length: 8466
INFO:root:max position: 8466
INFO:root:target_namespace: pycorrector.pycorrector<folder>.utils<folder>.tokenizer<file>.segment<func>
INFO:root:****************************************

data 21:   0%|          | 0/512 [00:00<?, ?it/s]
data 21:   2%|▏         | 10/512 [00:27<22:42,  2.71s/it]
data 21:   4%|▍         | 20/512 [00:57<24:00,  2.93s/it]
data 21:   6%|▌         | 30/512 [01:29<24:15,  3.02s/it]
data 21:   8%|▊         | 40/512 [01:57<23:14,  2.95s/it]
data 21:  10%|▉         | 50/512 [02:28<22:58,  2.98s/it]
data 21:  12%|█▏        | 60/512 [02:59<22:51,  3.03s/it]
data 21:  12%|█▏        | 60/512 [03:08<23:36,  3.13s/it]
INFO:root:函数头: 
def segment(sentence, cut_type='word', pos=False):

INFO:root:目标函数体: 
    
    if pos:
        if cut_type == 'word':
            word_pos_seq = posseg.lcut(sentence)
            word_seq, pos_seq = [], []
            for w, p in word_pos_seq:
                word_seq.append(w)
                pos_seq.append(p)
            return word_seq, pos_seq
        elif cut_type == 'char':
            word_seq = list(sentence)
            pos_seq = []
            for w in word_seq:
                w_p = posseg.lcut(w)
                pos_seq.append(w_p[0].flag)
            return word_seq, pos_seq
    else:
        if cut_type == 'word':
            return jieba.lcut(sentence)
        elif cut_type == 'char':
            return list(sentence)

INFO:root:生成结果: 
    if cut_type == 'word':
        if pos:
            return posseg.cut(sentence)
        else:
            return jieba.cut(sentence)
    elif cut_type == 'char':
        return list(sentence)
    else:
        raise ValueError("cut_type must be 'word' or 'char'")


INFO:root:----------------------------------------
INFO:root:max length: 8467
INFO:root:max position: 8467
INFO:root:target_namespace: pycorrector.pycorrector<folder>.utils<folder>.tokenizer<file>.segment<func>
INFO:root:****************************************

data 21:   0%|          | 0/512 [00:00<?, ?it/s]
data 21:   2%|▏         | 10/512 [00:30<25:42,  3.07s/it]
data 21:   4%|▍         | 20/512 [01:04<26:48,  3.27s/it]
data 21:   6%|▌         | 30/512 [01:40<27:13,  3.39s/it]
data 21:   8%|▊         | 40/512 [02:14<26:57,  3.43s/it]
data 21:  10%|▉         | 50/512 [02:47<25:58,  3.37s/it]
data 21:  12%|█▏        | 60/512 [03:22<25:45,  3.42s/it]
data 21:  12%|█▏        | 60/512 [03:28<26:12,  3.48s/it]
INFO:root:函数头: 
def segment(sentence, cut_type='word', pos=False):

INFO:root:目标函数体: 
    
    if pos:
        if cut_type == 'word':
            word_pos_seq = posseg.lcut(sentence)
            word_seq, pos_seq = [], []
            for w, p in word_pos_seq:
                word_seq.append(w)
                pos_seq.append(p)
            return word_seq, pos_seq
        elif cut_type == 'char':
            word_seq = list(sentence)
            pos_seq = []
            for w in word_seq:
                w_p = posseg.lcut(w)
                pos_seq.append(w_p[0].flag)
            return word_seq, pos_seq
    else:
        if cut_type == 'word':
            return jieba.lcut(sentence)
        elif cut_type == 'char':
            return list(sentence)

INFO:root:生成结果: 
    if cut_type == 'word':
        if pos:
            return posseg.cut(sentence)
        else:
            return jieba.cut(sentence)
    elif cut_type == 'char':
        return list(sentence)
    else:
        raise ValueError("Unsupported cut type: {}".format(c cut_type))


INFO:root:----------------------------------------
INFO:root:max length: 8467
INFO:root:max position: 8467
INFO:root:target_namespace: pycorrector.pycorrector<folder>.utils<folder>.tokenizer<file>.segment<func>
INFO:root:****************************************

data 21:   0%|          | 0/512 [00:00<?, ?it/s]
data 21:   2%|▏         | 10/512 [00:29<25:05,  3.00s/it]
data 21:   4%|▍         | 20/512 [01:00<24:54,  3.04s/it]
data 21:   6%|▌         | 30/512 [01:32<24:51,  3.09s/it]
data 21:   8%|▊         | 40/512 [02:02<24:12,  3.08s/it]
data 21:  10%|▉         | 50/512 [02:31<23:06,  3.00s/it]
data 21:  12%|█▏        | 60/512 [03:03<23:02,  3.06s/it]
data 21:  12%|█▏        | 60/512 [03:23<25:33,  3.39s/it]
INFO:root:函数头: 
def segment(sentence, cut_type='word', pos=False):

INFO:root:目标函数体: 
    
    if pos:
        if cut_type == 'word':
            word_pos_seq = posseg.lcut(sentence)
            word_seq, pos_seq = [], []
            for w, p in word_pos_seq:
                word_seq.append(w)
                pos_seq.append(p)
            return word_seq, pos_seq
        elif cut_type == 'char':
            word_seq = list(sentence)
            pos_seq = []
            for w in word_seq:
                w_p = posseg.lcut(w)
                pos_seq.append(w_p[0].flag)
            return word_seq, pos_seq
    else:
        if cut_type == 'word':
            return jieba.lcut(sentence)
        elif cut_type == 'char':
            return list(sentence)

INFO:root:生成结果: 
    if cut_type == 'word':
        if pos:
            return posseg.cut(sentence)
        else:
            return jieba.cut(sentence)
    elif cut_type == 'char':
        return list(sentence)
    else:
        raise ValueError("Invalid cut type. Supported types are 'word' and 'char'.")


INFO:root:----------------------------------------
INFO:root:max length: 8472
INFO:root:max position: 8472
INFO:root:target_namespace: pycorrector.pycorrector<folder>.utils<folder>.tokenizer<file>.segment<func>
INFO:root:****************************************

data 21:   0%|          | 0/512 [00:00<?, ?it/s]
data 21:   2%|▏         | 10/512 [00:26<22:12,  2.65s/it]
data 21:   4%|▍         | 20/512 [00:57<23:39,  2.88s/it]
data 21:   6%|▌         | 30/512 [01:28<24:14,  3.02s/it]
data 21:   8%|▊         | 40/512 [01:57<23:26,  2.98s/it]
data 21:  10%|▉         | 50/512 [02:29<23:22,  3.04s/it]
data 21:  12%|█▏        | 60/512 [03:00<23:08,  3.07s/it]
data 21:  12%|█▏        | 60/512 [03:11<24:01,  3.19s/it]
INFO:root:函数头: 
def segment(sentence, cut_type='word', pos=False):

INFO:root:目标函数体: 
    
    if pos:
        if cut_type == 'word':
            word_pos_seq = posseg.lcut(sentence)
            word_seq, pos_seq = [], []
            for w, p in word_pos_seq:
                word_seq.append(w)
                pos_seq.append(p)
            return word_seq, pos_seq
        elif cut_type == 'char':
            word_seq = list(sentence)
            pos_seq = []
            for w in word_seq:
                w_p = posseg.lcut(w)
                pos_seq.append(w_p[0].flag)
            return word_seq, pos_seq
    else:
        if cut_type == 'word':
            return jieba.lcut(sentence)
        elif cut_type == 'char':
            return list(sentence)

INFO:root:生成结果: 
    if cut_type == 'word':
        if pos:
            return posseg.cut(sentence)
        else:
            return jieba.cut(sentence)
    elif cut_type == 'char':
        return list(sentence)
    else:
        raise ValueError("cut_type must be 'word' or 'char'")


INFO:root:----------------------------------------
INFO:root:max length: 8467
INFO:root:max position: 8467
INFO:root:target_namespace: pycorrector.pycorrector<folder>.utils<folder>.tokenizer<file>.segment<func>
INFO:root:****************************************
INFO:root:--------data 22--------

data 22:   0%|          | 0/512 [00:00<?, ?it/s]
data 22:   2%|▏         | 10/512 [01:27<1:13:05,  8.74s/it]
data 22:   4%|▍         | 20/512 [02:54<1:11:36,  8.73s/it]
data 22:   6%|▌         | 30/512 [04:23<1:10:43,  8.80s/it]
data 22:   8%|▊         | 40/512 [05:52<1:09:30,  8.84s/it]
data 22:  10%|▉         | 50/512 [07:23<1:08:50,  8.94s/it]
data 22:  12%|█▏        | 60/512 [08:51<1:07:00,  8.89s/it]
data 22:  14%|█▎        | 70/512 [10:22<1:05:53,  8.94s/it]
data 22:  16%|█▌        | 80/512 [11:48<1:03:41,  8.85s/it]
data 22:  18%|█▊        | 90/512 [13:10<1:00:51,  8.65s/it]
data 22:  20%|█▉        | 100/512 [14:37<59:25,  8.65s/it] 
data 22:  21%|██▏       | 110/512 [16:04<58:00,  8.66s/it]
data 22:  23%|██▎       | 120/512 [17:30<56:34,  8.66s/it]
data 22:  25%|██▌       | 130/512 [19:03<56:20,  8.85s/it]
data 22:  27%|██▋       | 140/512 [20:27<53:57,  8.70s/it]
data 22:  29%|██▉       | 150/512 [21:54<52:36,  8.72s/it]
data 22:  31%|███▏      | 160/512 [23:20<50:50,  8.67s/it]
data 22:  33%|███▎      | 170/512 [24:50<49:59,  8.77s/it]
data 22:  35%|███▌      | 180/512 [26:16<48:20,  8.74s/it]
data 22:  37%|███▋      | 190/512 [27:42<46:36,  8.68s/it]
data 22:  39%|███▉      | 200/512 [31:16<1:05:03, 12.51s/it]
data 22:  41%|████      | 210/512 [32:45<57:26, 11.41s/it]  
data 22:  43%|████▎     | 220/512 [34:12<51:32, 10.59s/it]
data 22:  45%|████▍     | 230/512 [35:40<47:16, 10.06s/it]
data 22:  47%|████▋     | 240/512 [37:10<44:15,  9.76s/it]
data 22:  49%|████▉     | 250/512 [38:43<41:56,  9.60s/it]
data 22:  51%|█████     | 260/512 [40:14<39:45,  9.47s/it]
data 22:  53%|█████▎    | 270/512 [41:44<37:34,  9.32s/it]
data 22:  55%|█████▍    | 280/512 [43:15<35:45,  9.25s/it]
data 22:  57%|█████▋    | 290/512 [44:42<33:36,  9.08s/it]
data 22:  59%|█████▊    | 300/512 [46:07<31:28,  8.91s/it]
data 22:  61%|██████    | 310/512 [47:31<29:30,  8.76s/it]
data 22:  62%|██████▎   | 320/512 [48:56<27:47,  8.69s/it]
data 22:  64%|██████▍   | 330/512 [50:23<26:20,  8.69s/it]
data 22:  66%|██████▋   | 340/512 [51:45<24:29,  8.54s/it]
data 22:  68%|██████▊   | 350/512 [53:08<22:50,  8.46s/it]
data 22:  70%|███████   | 360/512 [54:33<21:29,  8.48s/it]
data 22:  72%|███████▏  | 370/512 [56:00<20:13,  8.54s/it]
data 22:  74%|███████▍  | 380/512 [57:25<18:46,  8.53s/it]
data 22:  76%|███████▌  | 390/512 [58:50<17:18,  8.51s/it]
data 22:  78%|███████▊  | 400/512 [1:00:17<16:00,  8.58s/it]
data 22:  80%|████████  | 410/512 [1:01:40<14:28,  8.51s/it]
data 22:  82%|████████▏ | 420/512 [1:03:09<13:11,  8.60s/it]
data 22:  84%|████████▍ | 430/512 [1:04:30<11:34,  8.47s/it]
data 22:  86%|████████▌ | 440/512 [1:05:56<10:12,  8.51s/it]
data 22:  88%|████████▊ | 450/512 [1:07:23<08:50,  8.56s/it]
data 22:  90%|████████▉ | 460/512 [1:08:50<07:27,  8.60s/it]
data 22:  92%|█████████▏| 470/512 [1:10:16<06:01,  8.61s/it]
data 22:  94%|█████████▍| 480/512 [1:11:46<04:38,  8.72s/it]
data 22:  96%|█████████▌| 490/512 [1:13:16<03:13,  8.80s/it]
data 22:  98%|█████████▊| 500/512 [1:14:44<01:45,  8.80s/it]
data 22: 100%|█████████▉| 510/512 [1:16:07<00:17,  8.65s/it]
data 22: 100%|█████████▉| 510/512 [1:16:28<00:17,  9.00s/it]
INFO:root:函数头: 
def object_type_repr(obj: t.Any) -> str:

INFO:root:目标函数体: 
    
    if obj is None:
        return "None"
    elif obj is Ellipsis:
        return "Ellipsis"

    cls = type(obj)

    if cls.__module__ == "builtins":
        return f"{cls.__name__} object"

    return f"{cls.__module__}.{cls.__name__} object"

INFO:root:生成结果: 
    if obj is None:
        return "None"
    elif obj is Ellipsis:
        return "..."
    elif obj is True:
        return "True"
    elif obj is False:
        return "False"
    elif obj is None:
        return "None"
    elif obj is None:
        return "None"
    elif obj is None:
        return "None"
    elif obj is None:
        return "None"
    elif obj is None:
        return "None"
    elif obj is None:
        return "None"
    elif obj is None:
        return "None"
    elif obj is None:
        return "None"
    elif obj is None:
        return "None"
    elif obj is None:
        return "None"
    elif obj is None:
        return "None"
    elif obj is None:
        return "None"
    elif obj is None:
        return "None"
    elif obj is None:
        return "None"
    elif obj is None:
        return "None"
    elif obj is None:
        return "None"
    elif obj is None:
        return "None"
    elif obj is None:
        return "None"
    elif obj is None:
        return "None"
    elif obj is None:
        return "None"
    elif obj is None:
        return "None"
    elif obj is None:
        return "None"
    elif obj is None:
        return "None"
    elif obj is None:
        return "None"
    elif obj is None:
        return "None"
    elif obj is None:
        return "None"
    elif obj is None:
        return "None"
    elif obj is None:
        return "None"
    elif obj is None:
        return "None"
    elif obj is None:
        return "None"
    elif obj is None:
        return "None"
    elif obj is None:
        return "None"
    elif obj is None:
        return "None"
    elif obj is None:
        return "None"
    elif obj is None:
        return "None"
    elif obj is None:
        return "None"
    elif obj is None:
        return "None"
    elif obj is None:
        return "None"
    elif obj is None:
        return "None"
    elif obj is None:
        return "None"
    elif obj is None:
        return "None"
    elif obj is None:
        return "None"
    elif obj is None:


INFO:root:----------------------------------------
INFO:root:max length: 8218
INFO:root:max position: 9954
INFO:root:target_namespace: Jinja2.src<folder>.jinja2<folder>.utils<file>.object_type_repr<func>
INFO:root:****************************************

data 22:   0%|          | 0/512 [00:00<?, ?it/s]
data 22:   2%|▏         | 10/512 [01:21<1:08:33,  8.19s/it]
data 22:   4%|▍         | 20/512 [02:47<1:08:51,  8.40s/it]
data 22:   6%|▌         | 30/512 [04:09<1:06:50,  8.32s/it]
data 22:   8%|▊         | 40/512 [05:37<1:06:56,  8.51s/it]
data 22:  10%|▉         | 50/512 [07:06<1:06:42,  8.66s/it]
data 22:  12%|█▏        | 60/512 [08:34<1:05:29,  8.69s/it]
data 22:  14%|█▎        | 70/512 [10:02<1:04:11,  8.71s/it]
data 22:  16%|█▌        | 80/512 [11:29<1:02:52,  8.73s/it]
data 22:  18%|█▊        | 90/512 [12:53<1:00:41,  8.63s/it]
data 22:  18%|█▊        | 90/512 [14:12<1:06:38,  9.47s/it]
INFO:root:函数头: 
def object_type_repr(obj: t.Any) -> str:

INFO:root:目标函数体: 
    
    if obj is None:
        return "None"
    elif obj is Ellipsis:
        return "Ellipsis"

    cls = type(obj)

    if cls.__module__ == "builtins":
        return f"{cls.__name__} object"

    return f"{cls.__module__}.{cls.__name__} object"

INFO:root:生成结果: 
    if obj is None:
        return "None object"
    elif obj is ...:
        return "Ellipsis object"
    elif obj is True:
        return "True object"
    elif obj is False:
        return "False object"
    elif obj is NotImplemented:
        return "NotImplemented object"

    module = obj.__module__
    if module == "__builtin__":
        module = "builtins"

    return f"{module}.{obj.__qualname__} object"




INFO:root:----------------------------------------
INFO:root:max length: 6996
INFO:root:max position: 9126
INFO:root:target_namespace: Jinja2.src<folder>.jinja2<folder>.utils<file>.object_type_repr<func>
INFO:root:****************************************

data 22:   0%|          | 0/512 [00:00<?, ?it/s]
data 22:   2%|▏         | 10/512 [01:18<1:05:44,  7.86s/it]
data 22:   4%|▍         | 20/512 [02:47<1:09:15,  8.45s/it]
data 22:   6%|▌         | 30/512 [04:13<1:08:33,  8.54s/it]
data 22:   8%|▊         | 40/512 [05:39<1:07:13,  8.55s/it]
data 22:  10%|▉         | 50/512 [07:05<1:05:58,  8.57s/it]
data 22:  12%|█▏        | 60/512 [13:33<2:22:08, 18.87s/it]
data 22:  14%|█▎        | 70/512 [15:00<1:54:27, 15.54s/it]
data 22:  16%|█▌        | 80/512 [16:27<1:36:10, 13.36s/it]
data 22:  18%|█▊        | 90/512 [17:53<1:23:24, 11.86s/it]
data 22:  20%|█▉        | 100/512 [19:16<1:13:55, 10.77s/it]
data 22:  21%|██▏       | 110/512 [20:45<1:08:17, 10.19s/it]
data 22:  23%|██▎       | 120/512 [22:15<1:04:20,  9.85s/it]
data 22:  25%|██▌       | 130/512 [23:41<1:00:16,  9.47s/it]
data 22:  27%|██▋       | 140/512 [25:05<56:33,  9.12s/it]  
data 22:  29%|██▉       | 150/512 [26:26<53:10,  8.81s/it]
data 22:  31%|███▏      | 160/512 [29:55<1:13:02, 12.45s/it]
data 22:  33%|███▎      | 170/512 [31:16<1:03:34, 11.15s/it]
data 22:  35%|███▌      | 180/512 [32:47<58:16, 10.53s/it]  
data 22:  37%|███▋      | 190/512 [34:12<53:15,  9.92s/it]
data 22:  39%|███▉      | 200/512 [37:41<1:08:44, 13.22s/it]
data 22:  41%|████      | 210/512 [41:10<1:18:12, 15.54s/it]
data 22:  43%|████▎     | 220/512 [42:35<1:05:18, 13.42s/it]
data 22:  45%|████▍     | 230/512 [44:02<56:27, 12.01s/it]  
data 22:  47%|████▋     | 240/512 [45:28<49:46, 10.98s/it]
data 22:  49%|████▉     | 250/512 [52:53<1:31:54, 21.05s/it]
data 22:  51%|█████     | 260/512 [54:23<1:13:13, 17.43s/it]
data 22:  53%|█████▎    | 270/512 [55:57<1:00:31, 15.01s/it]
data 22:  55%|█████▍    | 280/512 [59:24<1:04:40, 16.73s/it]
data 22:  57%|█████▋    | 290/512 [1:01:01<54:05, 14.62s/it]
data 22:  59%|█████▊    | 300/512 [1:02:30<45:31, 12.88s/it]
data 22:  61%|██████    | 310/512 [1:05:01<45:40, 13.57s/it]
data 22:  62%|██████▎   | 320/512 [1:08:32<50:37, 15.82s/it]
data 22:  64%|██████▍   | 330/512 [1:10:00<41:34, 13.70s/it]
data 22:  66%|██████▋   | 340/512 [1:15:32<56:04, 19.56s/it]
data 22:  68%|██████▊   | 350/512 [1:16:51<43:21, 16.06s/it]
data 22:  70%|███████   | 360/512 [1:20:23<44:33, 17.59s/it]
data 22:  72%|███████▏  | 370/512 [1:21:45<35:00, 14.79s/it]
data 22:  74%|███████▍  | 380/512 [1:25:12<36:27, 16.57s/it]
data 22:  76%|███████▌  | 390/512 [1:26:40<28:56, 14.23s/it]
data 22:  78%|███████▊  | 400/512 [1:33:09<40:22, 21.63s/it]
data 22:  80%|████████  | 410/512 [1:34:40<30:21, 17.86s/it]
data 22:  82%|████████▏ | 420/512 [1:36:07<23:10, 15.12s/it]
data 22:  84%|████████▍ | 430/512 [1:37:36<18:08, 13.27s/it]
data 22:  86%|████████▌ | 440/512 [1:41:04<18:37, 15.52s/it]
data 22:  88%|████████▊ | 450/512 [1:42:27<13:47, 13.34s/it]
data 22:  90%|████████▉ | 460/512 [1:43:53<10:20, 11.94s/it]
data 22:  92%|█████████▏| 470/512 [1:45:18<07:37, 10.90s/it]
data 22:  94%|█████████▍| 480/512 [1:46:49<05:31, 10.35s/it]
data 22:  96%|█████████▌| 490/512 [1:48:15<03:36,  9.84s/it]
data 22:  98%|█████████▊| 500/512 [1:49:46<01:55,  9.60s/it]
data 22: 100%|█████████▉| 510/512 [2:09:15<01:23, 41.81s/it]
data 22: 100%|█████████▉| 510/512 [2:09:39<00:30, 15.25s/it]
INFO:root:函数头: 
def object_type_repr(obj: t.Any) -> str:

INFO:root:目标函数体: 
    
    if obj is None:
        return "None"
    elif obj is Ellipsis:
        return "Ellipsis"

    cls = type(obj)

    if cls.__module__ == "builtins":
        return f"{cls.__name__} object"

    return f"{cls.__module__}.{cls.__name__} object"

INFO:root:生成结果: 
    if obj is None:
        return "None"
    if obj is Ellipsis:
        return "..."
    if obj is True:
        return "True"
    if obj is False:
        return "False"
    if obj is NoneType:
        return "NoneType"
    if obj is NotImplemented:
        return "NotImplemented"
    if obj is EllipsisType:
        return "EllipsisType"
    if obj is NotImplementedType:
        return "NotImplementedType"
    if obj is NotImplementedType:
        return "NotImplementedType"
    if obj is NotImplementedType:
        return "NotImplementedType"
    if obj is NotImplementedType:
        return "NotImplementedType"
    if obj is NotImplementedType:
        return "NotImplementedType"
    if obj is NotImplementedType:
        return "NotImplementedType"
    if obj is NotImplementedType:
        return "NotImplementedType"
    if obj is NotImplementedType:
        return "NotImplementedType"
    if obj is NotImplementedType:
        return "NotImplementedType"
    if obj is NotImplementedType:
        return "NotImplementedType"
    if obj is NotImplementedType:
        return "NotImplementedType"
    if obj is NotImplementedType:
        return "NotImplementedType"
    if obj is NotImplementedType:
        return "NotImplementedType"
    if obj is NotImplementedType:
        return "NotImplementedType"
    if obj is NotImplementedType:
        return "NotImplementedType"
    if obj is NotImplementedType:
        return "NotImplementedType"
    if obj is NotImplementedType:
        return "NotImplementedType"
    if obj is NotImplementedType:
        return "NotImplementedType"
    if obj is NotImplementedType:
        return "NotImplementedType"
    if obj is NotImplementedType:
        return "NotImplementedType"
    if obj is NotImplementedType:
        return "NotImplementedType"
    if obj is NotImplementedType:
        return "NotImplementedType"
    if obj is NotImplementedType:
        return "NotImplementedType"
    if obj is NotImplementedType:
        return "NotImplementedType"
    if obj is NotImplementedType:
        return "NotImplementedType"
    if obj is NotImplementedType:
        return "NotImplementedType"
    if obj is NotImplementedType:
        return "NotImplementedType"
    if obj is NotImplementedType:
        return "NotImplementedType"
    if obj is NotImplementedType:
        return "NotImplementedType"
    if obj is NotImplementedType:
        return "NotImplementedType"
    if obj is NotImplementedType:
       

INFO:root:----------------------------------------
INFO:root:max length: 7825
INFO:root:max position: 10330
INFO:root:target_namespace: Jinja2.src<folder>.jinja2<folder>.utils<file>.object_type_repr<func>
INFO:root:****************************************

data 22:   0%|          | 0/512 [00:00<?, ?it/s]
data 22:   2%|▏         | 10/512 [01:19<1:06:45,  7.98s/it]
data 22:   4%|▍         | 20/512 [02:45<1:08:10,  8.31s/it]
data 22:   6%|▌         | 30/512 [04:14<1:09:00,  8.59s/it]
data 22:   8%|▊         | 40/512 [05:39<1:07:21,  8.56s/it]
data 22:  10%|▉         | 50/512 [11:03<2:12:07, 17.16s/it]
data 22:  12%|█▏        | 60/512 [19:35<3:36:24, 28.73s/it]
data 22:  14%|█▎        | 70/512 [21:02<2:43:28, 22.19s/it]
data 22:  16%|█▌        | 80/512 [22:29<2:08:42, 17.88s/it]
data 22:  18%|█▊        | 90/512 [24:03<1:47:08, 15.23s/it]
data 22:  20%|█▉        | 100/512 [25:29<1:30:38, 13.20s/it]
data 22:  21%|██▏       | 110/512 [26:55<1:18:49, 11.76s/it]
data 22:  23%|██▎       | 120/512 [28:25<1:11:29, 10.94s/it]
data 22:  25%|██▌       | 130/512 [29:59<1:06:35, 10.46s/it]
data 22:  27%|██▋       | 140/512 [36:31<1:58:39, 19.14s/it]
data 22:  29%|██▉       | 150/512 [38:05<1:37:45, 16.20s/it]
data 22:  31%|███▏      | 160/512 [39:38<1:22:56, 14.14s/it]
data 22:  33%|███▎      | 170/512 [41:13<1:12:38, 12.74s/it]
data 22:  35%|███▌      | 180/512 [42:48<1:05:09, 11.77s/it]
data 22:  37%|███▋      | 190/512 [44:15<58:09, 10.84s/it]  
data 22:  39%|███▉      | 200/512 [47:48<1:12:42, 13.98s/it]
data 22:  41%|████      | 210/512 [49:17<1:02:41, 12.45s/it]
data 22:  43%|████▎     | 220/512 [50:44<55:06, 11.32s/it]  
data 22:  45%|████▍     | 230/512 [52:24<51:23, 10.94s/it]
data 22:  47%|████▋     | 240/512 [53:53<46:49, 10.33s/it]
data 22:  49%|████▉     | 250/512 [55:22<43:12,  9.89s/it]
data 22:  51%|█████     | 260/512 [56:49<40:04,  9.54s/it]
data 22:  53%|█████▎    | 270/512 [1:00:17<52:09, 12.93s/it]
data 22:  55%|█████▍    | 280/512 [1:01:41<44:43, 11.57s/it]
data 22:  57%|█████▋    | 290/512 [1:03:04<39:08, 10.58s/it]
data 22:  59%|█████▊    | 300/512 [1:04:29<35:09,  9.95s/it]
data 22:  61%|██████    | 310/512 [1:05:53<31:54,  9.48s/it]
data 22:  62%|██████▎   | 320/512 [1:07:20<29:36,  9.25s/it]
data 22:  62%|██████▎   | 320/512 [1:08:13<40:56, 12.79s/it]
INFO:root:函数头: 
def object_type_repr(obj: t.Any) -> str:

INFO:root:目标函数体: 
    
    if obj is None:
        return "None"
    elif obj is Ellipsis:
        return "Ellipsis"

    cls = type(obj)

    if cls.__module__ == "builtins":
        return f"{cls.__name__} object"

    return f"{cls.__module__}.{cls.__name__} object"

INFO:root:生成结果: 
    import inspect
    import sys

    # Handle builtins
    if inspect.isbuiltin(obj):
        return f"{obj.__name__} object"

    # Handle None and Ellipsis
    if obj is None or obj is Ellipsis:
        return str(obj)

    # Handle modules
    if inspect.ismodule(obj):
        return f"{obj.__name__} object"

    # Handle classes
    if inspect.isclass(obj):
        return f"{obj.__module__}.{obj.__qualname__}"

    # Handle instances
    if inspect.isinstance(obj, type):
        return f"{obj.__module__}.{obj.__qualname__}"

    # Handle functions
    if inspect.isfunction(obj):
        return f"{obj.__module__}.{obj.__qualname__}"

    # Handle methods
    if inspect.ismethod(obj):
        return f"{obj.__module__}.{obj.__qualname__}"

    # Handle generators
    if inspect.isgenerator(obj):
        return f"{obj.__module__}.{obj.__qualname__}"

    # Handle async generators
    if inspect.isasyncgen(obj):
        return f"{obj.__module__}.{obj.__qualname__}"

    # Handle async functions
    if inspect.isasyncfunction(obj):
        return f"{obj.__module__}.{obj.__qualname__}"

    # Handle async methods
    if inspect.isasyncmethod(obj):
        return f"{obj.__module__}.{obj.__qualname__}"

    # Handle other types
    return f"{obj.__module__}.{obj.__qualname__}"



INFO:root:----------------------------------------
INFO:root:max length: 7829
INFO:root:max position: 9825
INFO:root:target_namespace: Jinja2.src<folder>.jinja2<folder>.utils<file>.object_type_repr<func>
INFO:root:****************************************

data 22:   0%|          | 0/512 [00:00<?, ?it/s]
data 22:   2%|▏         | 10/512 [01:19<1:06:54,  8.00s/it]
data 22:   4%|▍         | 20/512 [02:44<1:07:47,  8.27s/it]
data 22:   6%|▌         | 30/512 [06:12<1:52:14, 13.97s/it]
data 22:   8%|▊         | 40/512 [07:36<1:32:45, 11.79s/it]
data 22:  10%|▉         | 50/512 [09:07<1:23:11, 10.80s/it]
data 22:  12%|█▏        | 60/512 [10:34<1:16:09, 10.11s/it]
data 22:  14%|█▎        | 70/512 [12:02<1:11:14,  9.67s/it]
data 22:  16%|█▌        | 80/512 [13:34<1:08:27,  9.51s/it]
data 22:  18%|█▊        | 90/512 [15:04<1:05:46,  9.35s/it]
data 22:  20%|█▉        | 100/512 [16:42<1:05:13,  9.50s/it]
data 22:  21%|██▏       | 110/512 [20:16<1:27:59, 13.13s/it]
data 22:  23%|██▎       | 120/512 [21:44<1:17:18, 11.83s/it]
data 22:  25%|██▌       | 130/512 [23:18<1:10:31, 11.08s/it]
data 22:  27%|██▋       | 140/512 [24:49<1:04:58, 10.48s/it]
data 22:  29%|██▉       | 150/512 [26:25<1:01:38, 10.22s/it]
data 22:  31%|███▏      | 160/512 [41:55<3:26:09, 35.14s/it]
data 22:  33%|███▎      | 170/512 [43:25<2:35:27, 27.27s/it]
data 22:  35%|███▌      | 180/512 [44:50<1:59:45, 21.64s/it]
data 22:  37%|███▋      | 190/512 [46:17<1:35:15, 17.75s/it]
data 22:  39%|███▉      | 200/512 [49:46<1:37:11, 18.69s/it]
data 22:  41%|████      | 210/512 [51:12<1:18:50, 15.66s/it]
data 22:  43%|████▎     | 220/512 [52:35<1:05:30, 13.46s/it]
data 22:  45%|████▍     | 230/512 [54:01<56:27, 12.01s/it]  
data 22:  47%|████▋     | 240/512 [55:25<49:30, 10.92s/it]
data 22:  49%|████▉     | 250/512 [56:50<44:30, 10.19s/it]
data 22:  51%|█████     | 260/512 [58:18<41:00,  9.76s/it]
data 22:  53%|█████▎    | 270/512 [1:03:47<1:07:22, 16.70s/it]
data 22:  55%|█████▍    | 280/512 [1:05:14<55:20, 14.31s/it]  
data 22:  57%|█████▋    | 290/512 [1:06:40<46:39, 12.61s/it]
data 22:  59%|█████▊    | 300/512 [1:08:09<40:32, 11.48s/it]
data 22:  61%|██████    | 310/512 [1:09:38<36:02, 10.70s/it]
data 22:  62%|██████▎   | 320/512 [1:11:00<31:52,  9.96s/it]
data 22:  64%|██████▍   | 330/512 [1:12:29<29:14,  9.64s/it]
data 22:  66%|██████▋   | 340/512 [1:13:57<26:54,  9.39s/it]
data 22:  68%|██████▊   | 350/512 [1:17:19<34:09, 12.65s/it]
data 22:  70%|███████   | 360/512 [1:18:49<29:12, 11.53s/it]
data 22:  72%|███████▏  | 370/512 [1:20:20<25:36, 10.82s/it]
data 22:  74%|███████▍  | 380/512 [1:21:52<22:45, 10.34s/it]
data 22:  76%|███████▌  | 390/512 [1:23:23<20:13,  9.95s/it]
data 22:  78%|███████▊  | 400/512 [1:24:51<17:55,  9.60s/it]
data 22:  80%|████████  | 410/512 [1:26:18<15:53,  9.35s/it]
data 22:  82%|████████▏ | 420/512 [1:27:42<13:54,  9.07s/it]
data 22:  84%|████████▍ | 430/512 [1:31:15<17:22, 12.72s/it]
data 22:  86%|████████▌ | 440/512 [1:32:43<13:52, 11.57s/it]
data 22:  88%|████████▊ | 450/512 [1:34:03<10:50, 10.49s/it]
data 22:  90%|████████▉ | 460/512 [1:35:31<08:38,  9.96s/it]
data 22:  92%|█████████▏| 470/512 [1:36:55<06:38,  9.50s/it]
data 22:  94%|█████████▍| 480/512 [1:38:22<04:56,  9.26s/it]
data 22:  96%|█████████▌| 490/512 [1:39:51<03:21,  9.17s/it]
data 22:  98%|█████████▊| 500/512 [1:41:19<01:48,  9.05s/it]
data 22: 100%|█████████▉| 510/512 [1:44:45<00:25, 12.51s/it]
data 22: 100%|█████████▉| 510/512 [1:45:11<00:24, 12.38s/it]
INFO:root:函数头: 
def object_type_repr(obj: t.Any) -> str:

INFO:root:目标函数体: 
    
    if obj is None:
        return "None"
    elif obj is Ellipsis:
        return "Ellipsis"

    cls = type(obj)

    if cls.__module__ == "builtins":
        return f"{cls.__name__} object"

    return f"{cls.__module__}.{cls.__name__} object"

INFO:root:生成结果: 
    if obj is None:
        return "None"
    elif obj is ...:
        return "..."
    elif obj is True:
        return "True"
    elif obj is False:
        return "False"
    elif obj is Ellipsis:
        return "..."
    elif obj is NotImplemented:
        return "NotImplemented"
    elif obj is None:
        return "None"
    elif obj is Ellipsis:
        return "..."
    elif obj is True:
        return "True"
    elif obj is False:
        return "False"
    elif obj is Ellipsis:
        return "..."
    elif obj is NotImplemented:
        return "NotImplemented"
    elif obj is None:
        return "None"
    elif obj is Ellipsis:
        return "..."
    elif obj is True:
        return "True"
    elif obj is False:
        return "False"
    elif obj is Ellipsis:
        return "..."
    elif obj is NotImplemented:
        return "NotImplemented"
    elif obj is None:
        return "None"
    elif obj is Ellipsis:
        return "..."
    elif obj is True:
        return "True"
    elif obj is False:
        return "False"
    elif obj is Ellipsis:
        return "..."
    elif obj is NotImplemented:
        return "NotImplemented"
    elif obj is None:
        return "None"
    elif obj is Ellipsis:
        return "..."
    elif obj is True:
        return "True"
    elif obj is False:
        return "False"
    elif obj is Ellipsis:
        return "..."
    elif obj is NotImplemented:
        return "NotImplemented"
    elif obj is None:
        return "None"
    elif obj is Ellipsis:
        return "..."
    elif obj is True:
        return "True"
    elif obj is False:
        return "False"
    elif obj is Ellipsis:
        return "..."
    elif obj is NotImplemented:
        return "NotImplemented"
    elif obj is None:
        return "None"
    elif obj is Ellipsis:
        return "..."
    elif obj is True:
        return "True"
    elif obj is False:
        return "False"
    elif obj is Ellipsis:
        return "..."
    elif obj is NotImplemented:
        return "NotImplemented"
    elif obj is None:
        return "None"
    elif obj is Ellipsis:
        return "..."
    elif obj is True:
        return "True"
    elif obj is False:
        return "False"


INFO:root:----------------------------------------
INFO:root:max length: 8182
INFO:root:max position: 9646
INFO:root:target_namespace: Jinja2.src<folder>.jinja2<folder>.utils<file>.object_type_repr<func>
INFO:root:****************************************
INFO:root:--------data 23--------

data 23:   0%|          | 0/512 [00:00<?, ?it/s]
data 23:   2%|▏         | 10/512 [01:41<1:24:40, 10.12s/it]
data 23:   4%|▍         | 20/512 [03:33<1:28:23, 10.78s/it]
data 23:   4%|▍         | 20/512 [04:56<2:01:26, 14.81s/it]
INFO:root:函数头: 
    def setdefault(self, key: t.Any, default: t.Any = None) -> t.Any:

INFO:root:目标函数体: 
        
        try:
            return self[key]
        except KeyError:
            self[key] = default
            return default

INFO:root:生成结果: 
        if key in self._mapping:
            return self[key]
        self[key] = default
        return default

INFO:root:----------------------------------------
INFO:root:max length: 7190
INFO:root:max position: 10589
INFO:root:target_namespace: Jinja2.src<folder>.jinja2<folder>.utils<file>.LRUCache<class>.setdefault<func>
INFO:root:****************************************

data 23:   0%|          | 0/512 [00:00<?, ?it/s]
data 23:   2%|▏         | 10/512 [01:42<1:25:34, 10.23s/it]
data 23:   4%|▍         | 20/512 [03:30<1:26:41, 10.57s/it]
data 23:   4%|▍         | 20/512 [04:35<1:52:52, 13.77s/it]
INFO:root:函数头: 
    def setdefault(self, key: t.Any, default: t.Any = None) -> t.Any:

INFO:root:目标函数体: 
        
        try:
            return self[key]
        except KeyError:
            self[key] = default
            return default

INFO:root:生成结果: 
        try:
            return self[key]
        except KeyError:
            self[key] = default
            return default

INFO:root:----------------------------------------
INFO:root:max length: 6633
INFO:root:max position: 10477
INFO:root:target_namespace: Jinja2.src<folder>.jinja2<folder>.utils<file>.LRUCache<class>.setdefault<func>
INFO:root:****************************************

data 23:   0%|          | 0/512 [00:00<?, ?it/s]
data 23:   2%|▏         | 10/512 [03:31<2:56:38, 21.11s/it]
data 23:   4%|▍         | 20/512 [05:18<2:03:02, 15.01s/it]
data 23:   4%|▍         | 20/512 [06:24<2:37:50, 19.25s/it]
INFO:root:函数头: 
    def setdefault(self, key: t.Any, default: t.Any = None) -> t.Any:

INFO:root:目标函数体: 
        
        try:
            return self[key]
        except KeyError:
            self[key] = default
            return default

INFO:root:生成结果: 
        try:
            return self[key]
        except KeyError:
            self[key] = default
            return default

INFO:root:----------------------------------------
INFO:root:max length: 6962
INFO:root:max position: 10444
INFO:root:target_namespace: Jinja2.src<folder>.jinja2<folder>.utils<file>.LRUCache<class>.setdefault<func>
INFO:root:****************************************

data 23:   0%|          | 0/512 [00:00<?, ?it/s]
data 23:   2%|▏         | 10/512 [01:39<1:23:26,  9.97s/it]
data 23:   4%|▍         | 20/512 [03:23<1:23:44, 10.21s/it]
data 23:   4%|▍         | 20/512 [04:44<1:56:27, 14.20s/it]
INFO:root:函数头: 
    def setdefault(self, key: t.Any, default: t.Any = None) -> t.Any:

INFO:root:目标函数体: 
        
        try:
            return self[key]
        except KeyError:
            self[key] = default
            return default

INFO:root:生成结果: 
        if key in self._mapping:
            return self[key]
        self[key] = default
        return default

INFO:root:----------------------------------------
INFO:root:max length: 7306
INFO:root:max position: 10747
INFO:root:target_namespace: Jinja2.src<folder>.jinja2<folder>.utils<file>.LRUCache<class>.setdefault<func>
INFO:root:****************************************

data 23:   0%|          | 0/512 [00:00<?, ?it/s]
data 23:   2%|▏         | 10/512 [01:35<1:20:00,  9.56s/it]
data 23:   4%|▍         | 20/512 [03:23<1:24:19, 10.28s/it]
data 23:   4%|▍         | 20/512 [06:29<2:39:43, 19.48s/it]
INFO:root:函数头: 
    def setdefault(self, key: t.Any, default: t.Any = None) -> t.Any:

INFO:root:目标函数体: 
        
        try:
            return self[key]
        except KeyError:
            self[key] = default
            return default

INFO:root:生成结果: 
        try:
            return self[key]
        except KeyError:
            self[key] = default
            return default

INFO:root:----------------------------------------
INFO:root:max length: 7136
INFO:root:max position: 10463
INFO:root:target_namespace: Jinja2.src<folder>.jinja2<folder>.utils<file>.LRUCache<class>.setdefault<func>
INFO:root:****************************************
INFO:root:--------data 24--------

data 24:   0%|          | 0/512 [00:00<?, ?it/s]
data 24:   2%|▏         | 10/512 [02:53<2:25:13, 17.36s/it]
data 24:   4%|▍         | 20/512 [05:47<2:22:43, 17.41s/it]
data 24:   6%|▌         | 30/512 [08:47<2:21:41, 17.64s/it]
data 24:   8%|▊         | 40/512 [13:48<2:57:40, 22.59s/it]
data 24:   8%|▊         | 40/512 [16:11<3:10:59, 24.28s/it]
INFO:root:函数头: 
    @staticmethod
    def _compute_word_freq(list_of_words):

INFO:root:目标函数体: 
        word_freq = {}
        for w in list_of_words:
            word_freq[w] = word_freq.get(w, 0) + 1
        return word_freq

INFO:root:生成结果: 
        word_freq = {}
        for word in list_of_words:
            if word in word_freq:
                word_freq[word] += 1
            else:
                word_freq[word] = 1
        return word_freq


INFO:root:----------------------------------------
INFO:root:max length: 8575
INFO:root:max position: 12139
INFO:root:target_namespace: sumy.sumy<folder>.summarizers<folder>.sum_basic<file>.SumBasicSummarizer<class>._compute_word_freq<func>
INFO:root:****************************************

data 24:   0%|          | 0/512 [00:00<?, ?it/s]
data 24:   2%|▏         | 10/512 [02:32<2:07:13, 15.21s/it]
data 24:   4%|▍         | 20/512 [05:34<2:19:09, 16.97s/it]
data 24:   6%|▌         | 30/512 [08:33<2:19:54, 17.42s/it]
data 24:   8%|▊         | 40/512 [13:34<2:56:16, 22.41s/it]
data 24:   8%|▊         | 40/512 [16:05<3:09:54, 24.14s/it]
INFO:root:函数头: 
    @staticmethod
    def _compute_word_freq(list_of_words):

INFO:root:目标函数体: 
        word_freq = {}
        for w in list_of_words:
            word_freq[w] = word_freq.get(w, 0) + 1
        return word_freq

INFO:root:生成结果: 
        word_freq = {}
        for word in list_of_words:
            if word in word_freq:
                word_freq[word] += 1
            else:
                word_freq[word] = 1
        return word_freq


INFO:root:----------------------------------------
INFO:root:max length: 7545
INFO:root:max position: 12425
INFO:root:target_namespace: sumy.sumy<folder>.summarizers<folder>.sum_basic<file>.SumBasicSummarizer<class>._compute_word_freq<func>
INFO:root:****************************************

data 24:   0%|          | 0/512 [00:00<?, ?it/s]
data 24:   2%|▏         | 10/512 [02:42<2:15:51, 16.24s/it]
data 24:   4%|▍         | 20/512 [05:43<2:22:07, 17.33s/it]
data 24:   6%|▌         | 30/512 [10:27<2:59:47, 22.38s/it]
data 24:   8%|▊         | 40/512 [13:31<2:43:47, 20.82s/it]
data 24:   8%|▊         | 40/512 [15:50<3:06:54, 23.76s/it]
INFO:root:函数头: 
    @staticmethod
    def _compute_word_freq(list_of_words):

INFO:root:目标函数体: 
        word_freq = {}
        for w in list_of_words:
            word_freq[w] = word_freq.get(w, 0) + 1
        return word_freq

INFO:root:生成结果: 
        word_freq = {}
        for word in list_of_words:
            if word in word_freq:
                word_freq[word] += 1
            else:
                word_freq[word] = 1
        return word_freq


INFO:root:----------------------------------------
INFO:root:max length: 7964
INFO:root:max position: 12186
INFO:root:target_namespace: sumy.sumy<folder>.summarizers<folder>.sum_basic<file>.SumBasicSummarizer<class>._compute_word_freq<func>
INFO:root:****************************************

data 24:   0%|          | 0/512 [00:00<?, ?it/s]
data 24:   2%|▏         | 10/512 [02:31<2:06:30, 15.12s/it]
data 24:   4%|▍         | 20/512 [07:19<3:10:05, 23.18s/it]
data 24:   6%|▌         | 30/512 [10:03<2:41:12, 20.07s/it]
data 24:   8%|▊         | 40/512 [12:58<2:30:01, 19.07s/it]
data 24:   8%|▊         | 40/512 [15:20<3:01:00, 23.01s/it]
INFO:root:函数头: 
    @staticmethod
    def _compute_word_freq(list_of_words):

INFO:root:目标函数体: 
        word_freq = {}
        for w in list_of_words:
            word_freq[w] = word_freq.get(w, 0) + 1
        return word_freq

INFO:root:生成结果: 
        word_freq = {}
        for word in list_of_words:
            if word in word_freq:
                word_freq[word] += 1
            else:
                word_freq[word] = 1
        return word_freq


INFO:root:----------------------------------------
INFO:root:max length: 8566
INFO:root:max position: 11846
INFO:root:target_namespace: sumy.sumy<folder>.summarizers<folder>.sum_basic<file>.SumBasicSummarizer<class>._compute_word_freq<func>
INFO:root:****************************************

data 24:   0%|          | 0/512 [00:00<?, ?it/s]
data 24:   2%|▏         | 10/512 [02:32<2:07:15, 15.21s/it]
data 24:   4%|▍         | 20/512 [07:19<3:10:03, 23.18s/it]
data 24:   6%|▌         | 30/512 [10:07<2:42:39, 20.25s/it]
data 24:   8%|▊         | 40/512 [13:01<2:30:31, 19.14s/it]
data 24:   8%|▊         | 40/512 [15:09<2:58:54, 22.74s/it]
INFO:root:函数头: 
    @staticmethod
    def _compute_word_freq(list_of_words):

INFO:root:目标函数体: 
        word_freq = {}
        for w in list_of_words:
            word_freq[w] = word_freq.get(w, 0) + 1
        return word_freq

INFO:root:生成结果: 
        word_freq = {}
        for word in list_of_words:
            if word in word_freq:
                word_freq[word] += 1
            else:
                word_freq[word] = 1
        return word_freq


INFO:root:----------------------------------------
INFO:root:max length: 8028
INFO:root:max position: 12575
INFO:root:target_namespace: sumy.sumy<folder>.summarizers<folder>.sum_basic<file>.SumBasicSummarizer<class>._compute_word_freq<func>
INFO:root:****************************************
INFO:root:--------data 25--------

data 25:   0%|          | 0/512 [00:00<?, ?it/s]
data 25:   2%|▏         | 10/512 [04:19<3:37:21, 25.98s/it]
data 25:   4%|▍         | 20/512 [07:16<2:53:07, 21.11s/it]
data 25:   6%|▌         | 30/512 [09:59<2:31:55, 18.91s/it]
data 25:   8%|▊         | 40/512 [12:45<2:21:21, 17.97s/it]
data 25:   8%|▊         | 40/512 [14:41<2:53:21, 22.04s/it]
INFO:root:函数头: 
    @staticmethod
    def _compute_average_probability_of_words(word_freq_in_doc, content_words_in_sentence):

INFO:root:目标函数体: 
        content_words_count = len(content_words_in_sentence)
        if content_words_count > 0:
            word_freq_sum = sum([word_freq_in_doc[w] for w in content_words_in_sentence])
            word_freq_avg = word_freq_sum / content_words_count
            return word_freq_avg
        else:
            return 0

INFO:root:生成结果: 
        if not content_words_in_sentence:
            return 0.0
        total_probability = sum(word_freq_in_doc[word] for word in content_words_in_sentence)
        return total_probability / len(content_words_in_sentence)


INFO:root:----------------------------------------
INFO:root:max length: 7797
INFO:root:max position: 11734
INFO:root:target_namespace: sumy.sumy<folder>.summarizers<folder>.sum_basic<file>.SumBasicSummarizer<class>._compute_average_probability_of_words<func>
INFO:root:****************************************

data 25:   0%|          | 0/512 [00:00<?, ?it/s]
data 25:   2%|▏         | 10/512 [04:19<3:37:16, 25.97s/it]
data 25:   4%|▍         | 20/512 [07:16<2:52:48, 21.07s/it]
data 25:   6%|▌         | 30/512 [10:12<2:36:33, 19.49s/it]
data 25:   8%|▊         | 40/512 [12:55<2:23:35, 18.25s/it]
data 25:   8%|▊         | 40/512 [14:57<2:56:27, 22.43s/it]
INFO:root:函数头: 
    @staticmethod
    def _compute_average_probability_of_words(word_freq_in_doc, content_words_in_sentence):

INFO:root:目标函数体: 
        content_words_count = len(content_words_in_sentence)
        if content_words_count > 0:
            word_freq_sum = sum([word_freq_in_doc[w] for w in content_words_in_sentence])
            word_freq_avg = word_freq_sum / content_words_count
            return word_freq_avg
        else:
            return 0

INFO:root:生成结果: 
        total_probability = sum(word_freq_in_doc[word] for word in content_words_in_sentence)
        if total_probability == 0:
            return 0
        return total_probability / len(content_words_in_sentence)

INFO:root:----------------------------------------
INFO:root:max length: 7489
INFO:root:max position: 11987
INFO:root:target_namespace: sumy.sumy<folder>.summarizers<folder>.sum_basic<file>.SumBasicSummarizer<class>._compute_average_probability_of_words<func>
INFO:root:****************************************

data 25:   0%|          | 0/512 [00:00<?, ?it/s]
data 25:   2%|▏         | 10/512 [04:24<3:40:59, 26.41s/it]
data 25:   4%|▍         | 20/512 [07:33<3:00:34, 22.02s/it]
data 25:   6%|▌         | 30/512 [10:26<2:39:37, 19.87s/it]
data 25:   8%|▊         | 40/512 [13:13<2:26:15, 18.59s/it]
data 25:   8%|▊         | 40/512 [17:47<3:29:57, 26.69s/it]
INFO:root:函数头: 
    @staticmethod
    def _compute_average_probability_of_words(word_freq_in_doc, content_words_in_sentence):

INFO:root:目标函数体: 
        content_words_count = len(content_words_in_sentence)
        if content_words_count > 0:
            word_freq_sum = sum([word_freq_in_doc[w] for w in content_words_in_sentence])
            word_freq_avg = word_freq_sum / content_words_count
            return word_freq_avg
        else:
            return 0

INFO:root:生成结果: 
        total_probability = sum(word_freq_in_doc[word] for word in content_words_in_sentence if word in word_freq_in_doc)
        return total_probability / len(content_words_in_sentence) if content_words_in_sentence else 0


INFO:root:----------------------------------------
INFO:root:max length: 8084
INFO:root:max position: 12359
INFO:root:target_namespace: sumy.sumy<folder>.summarizers<folder>.sum_basic<file>.SumBasicSummarizer<class>._compute_average_probability_of_words<func>
INFO:root:****************************************

data 25:   0%|          | 0/512 [00:00<?, ?it/s]
data 25:   2%|▏         | 10/512 [02:23<2:00:24, 14.39s/it]
data 25:   4%|▍         | 20/512 [05:31<2:19:18, 16.99s/it]
data 25:   6%|▌         | 30/512 [13:19<4:05:35, 30.57s/it]
data 25:   8%|▊         | 40/512 [16:04<3:16:49, 25.02s/it]
data 25:   8%|▊         | 40/512 [18:38<3:40:03, 27.97s/it]
INFO:root:函数头: 
    @staticmethod
    def _compute_average_probability_of_words(word_freq_in_doc, content_words_in_sentence):

INFO:root:目标函数体: 
        content_words_count = len(content_words_in_sentence)
        if content_words_count > 0:
            word_freq_sum = sum([word_freq_in_doc[w] for w in content_words_in_sentence])
            word_freq_avg = word_freq_sum / content_words_count
            return word_freq_avg
        else:
            return 0

INFO:root:生成结果: 
        if not content_words_in_sentence:
            return 0.0
        total_probability = sum(word_freq_in_doc[word] for word in content_words_in_sentence)
        return total_probability / len(content_words_in_sentence)

INFO:root:----------------------------------------
INFO:root:max length: 7896
INFO:root:max position: 12149
INFO:root:target_namespace: sumy.sumy<folder>.summarizers<folder>.sum_basic<file>.SumBasicSummarizer<class>._compute_average_probability_of_words<func>
INFO:root:****************************************

data 25:   0%|          | 0/512 [00:00<?, ?it/s]
data 25:   2%|▏         | 10/512 [02:17<1:55:15, 13.78s/it]
data 25:   4%|▍         | 20/512 [05:13<2:11:17, 16.01s/it]
data 25:   6%|▌         | 30/512 [10:04<2:56:37, 21.99s/it]
data 25:   8%|▊         | 40/512 [12:59<2:39:05, 20.22s/it]
data 25:   8%|▊         | 40/512 [15:39<3:04:44, 23.48s/it]
INFO:root:函数头: 
    @staticmethod
    def _compute_average_probability_of_words(word_freq_in_doc, content_words_in_sentence):

INFO:root:目标函数体: 
        content_words_count = len(content_words_in_sentence)
        if content_words_count > 0:
            word_freq_sum = sum([word_freq_in_doc[w] for w in content_words_in_sentence])
            word_freq_avg = word_freq_sum / content_words_count
            return word_freq_avg
        else:
            return 0

INFO:root:生成结果: 
        total_probability = sum(word_freq_in_doc[word] for word in content_words_in_sentence if word in word_freq_in_doc)
        return total_probability / len(content_words_in_sentence) if content_words_in_sentence else 0

INFO:root:----------------------------------------
INFO:root:max length: 8009
INFO:root:max position: 12514
INFO:root:target_namespace: sumy.sumy<folder>.summarizers<folder>.sum_basic<file>.SumBasicSummarizer<class>._compute_average_probability_of_words<func>
INFO:root:****************************************
INFO:root:--------data 26--------

data 26:   0%|          | 0/512 [00:00<?, ?it/s]
data 26:   2%|▏         | 10/512 [02:47<2:19:49, 16.71s/it]
data 26:   4%|▍         | 20/512 [07:38<3:16:55, 24.01s/it]
data 26:   6%|▌         | 30/512 [10:13<2:41:53, 20.15s/it]
data 26:   8%|▊         | 40/512 [15:14<3:09:13, 24.05s/it]
data 26:  10%|▉         | 50/512 [20:09<3:20:30, 26.04s/it]
data 26:  12%|█▏        | 60/512 [22:45<2:49:17, 22.47s/it]
data 26:  14%|█▎        | 70/512 [25:11<2:26:34, 19.90s/it]
data 26:  16%|█▌        | 80/512 [27:49<2:13:58, 18.61s/it]
data 26:  16%|█▌        | 80/512 [30:02<2:42:13, 22.53s/it]
INFO:root:函数头: 
    @staticmethod
    def _compute_idf(sentences):

INFO:root:目标函数体: 
        idf_metrics = {}
        sentences_count = len(sentences)

        for sentence in sentences:
            for term in sentence:
                if term not in idf_metrics:
                    n_j = sum(1 for s in sentences if term in s)
                    idf_metrics[term] = math.log(sentences_count / (1 + n_j))

        return idf_metrics

INFO:root:生成结果: 
        tf_metrics = [_compute_tf(sentences)]  # Assuming _compute_tf is defined in the current file
        idf_metrics = {}
        total_sentences = len(sentences)

        for term, tf in tf_metrics[-1].items():
            tf_metrics.append({term: tf})
            idf_metrics[term] = math.log(total_sentences / tf_metrics[-1][term])

        return idf_metrics


INFO:root:----------------------------------------
INFO:root:max length: 9201
INFO:root:max position: 13302
INFO:root:target_namespace: sumy.sumy<folder>.summarizers<folder>.lex_rank<file>.LexRankSummarizer<class>._compute_idf<func>
INFO:root:****************************************

data 26:   0%|          | 0/512 [00:00<?, ?it/s]
data 26:   2%|▏         | 10/512 [04:36<3:51:06, 27.62s/it]
data 26:   4%|▍         | 20/512 [07:21<2:53:04, 21.11s/it]
data 26:   6%|▌         | 30/512 [10:00<2:30:15, 18.70s/it]
data 26:   8%|▊         | 40/512 [12:58<2:24:34, 18.38s/it]
data 26:  10%|▉         | 50/512 [17:37<2:47:47, 21.79s/it]
data 26:  12%|█▏        | 60/512 [20:23<2:30:56, 20.04s/it]
data 26:  14%|█▎        | 70/512 [22:58<2:16:39, 18.55s/it]
data 26:  16%|█▌        | 80/512 [25:37<2:07:33, 17.72s/it]
data 26:  16%|█▌        | 80/512 [26:25<2:22:43, 19.82s/it]
INFO:root:函数头: 
    @staticmethod
    def _compute_idf(sentences):

INFO:root:目标函数体: 
        idf_metrics = {}
        sentences_count = len(sentences)

        for sentence in sentences:
            for term in sentence:
                if term not in idf_metrics:
                    n_j = sum(1 for s in sentences if term in s)
                    idf_metrics[term] = math.log(sentences_count / (1 + n_j))

        return idf_metrics

INFO:root:生成结果: 
        import math

        # Calculate the total number of documents
        total_documents = len(sentences)

        # Calculate the IDF for each term
        idf_metrics = {}
        for sentence in sentences:
            term_counts = Counter(sentence)
            for term, count in term_counts.items():
                idf_metrics[term] = math.log(total_documents / count)

        return idf_metrics


INFO:root:----------------------------------------
INFO:root:max length: 8082
INFO:root:max position: 13034
INFO:root:target_namespace: sumy.sumy<folder>.summarizers<folder>.lex_rank<file>.LexRankSummarizer<class>._compute_idf<func>
INFO:root:****************************************

data 26:   0%|          | 0/512 [00:00<?, ?it/s]
data 26:   2%|▏         | 10/512 [02:36<2:10:44, 15.63s/it]
data 26:   4%|▍         | 20/512 [07:21<3:10:27, 23.23s/it]
data 26:   6%|▌         | 30/512 [09:49<2:35:44, 19.39s/it]
data 26:   8%|▊         | 40/512 [12:46<2:27:06, 18.70s/it]
data 26:  10%|▉         | 50/512 [15:26<2:16:26, 17.72s/it]
data 26:  10%|▉         | 50/512 [15:43<2:25:13, 18.86s/it]
INFO:root:函数头: 
    @staticmethod
    def _compute_idf(sentences):

INFO:root:目标函数体: 
        idf_metrics = {}
        sentences_count = len(sentences)

        for sentence in sentences:
            for term in sentence:
                if term not in idf_metrics:
                    n_j = sum(1 for s in sentences if term in s)
                    idf_metrics[term] = math.log(sentences_count / (1 + n_j))

        return idf_metrics

INFO:root:生成结果: 
        from sumy.nlp.tokenizers import Tokenizer
        tokenizer = Tokenizer('english')
        tfidf_model = TfidfModel(sentences)
        idf_metrics = tfidf_model.idf_
        return idf_metrics


INFO:root:----------------------------------------
INFO:root:max length: 7595
INFO:root:max position: 11825
INFO:root:target_namespace: sumy.sumy<folder>.summarizers<folder>.lex_rank<file>.LexRankSummarizer<class>._compute_idf<func>
INFO:root:****************************************

data 26:   0%|          | 0/512 [00:00<?, ?it/s]
data 26:   2%|▏         | 10/512 [02:32<2:07:23, 15.23s/it]
data 26:   4%|▍         | 20/512 [05:13<2:08:56, 15.73s/it]
data 26:   6%|▌         | 30/512 [07:42<2:03:30, 15.37s/it]
data 26:   8%|▊         | 40/512 [10:49<2:11:16, 16.69s/it]
data 26:  10%|▉         | 50/512 [13:23<2:04:55, 16.22s/it]
data 26:  12%|█▏        | 60/512 [15:50<1:58:22, 15.71s/it]
data 26:  12%|█▏        | 60/512 [17:42<2:13:20, 17.70s/it]
INFO:root:函数头: 
    @staticmethod
    def _compute_idf(sentences):

INFO:root:目标函数体: 
        idf_metrics = {}
        sentences_count = len(sentences)

        for sentence in sentences:
            for term in sentence:
                if term not in idf_metrics:
                    n_j = sum(1 for s in sentences if term in s)
                    idf_metrics[term] = math.log(sentences_count / (1 + n_j))

        return idf_metrics

INFO:root:生成结果: 
        total_sentences = len(sentences)
        term_count = {}
        for sentence in sentences:
            term_count.update(Counter(sentence))
        idf_metrics = {}
        for term, count in term_count.items():
            idf_metrics[term] = math.log(total_sentences / count)
        return idf_metrics


INFO:root:----------------------------------------
INFO:root:max length: 8119
INFO:root:max position: 12689
INFO:root:target_namespace: sumy.sumy<folder>.summarizers<folder>.lex_rank<file>.LexRankSummarizer<class>._compute_idf<func>
INFO:root:****************************************

data 26:   0%|          | 0/512 [00:00<?, ?it/s]
data 26:   2%|▏         | 10/512 [02:34<2:09:15, 15.45s/it]
data 26:   4%|▍         | 20/512 [05:17<2:10:33, 15.92s/it]
data 26:   6%|▌         | 30/512 [07:54<2:07:19, 15.85s/it]
data 26:   8%|▊         | 40/512 [10:42<2:07:26, 16.20s/it]
data 26:  10%|▉         | 50/512 [13:19<2:03:21, 16.02s/it]
data 26:  12%|█▏        | 60/512 [16:01<2:01:19, 16.11s/it]
data 26:  14%|█▎        | 70/512 [18:41<1:58:14, 16.05s/it]
data 26:  16%|█▌        | 80/512 [21:31<1:57:46, 16.36s/it]
data 26:  18%|█▊        | 90/512 [24:22<1:56:40, 16.59s/it]
data 26:  20%|█▉        | 100/512 [27:20<1:56:36, 16.98s/it]
data 26:  21%|██▏       | 110/512 [30:23<1:56:20, 17.36s/it]
data 26:  23%|██▎       | 120/512 [32:58<1:49:51, 16.82s/it]
data 26:  25%|██▌       | 130/512 [35:42<1:46:15, 16.69s/it]
data 26:  25%|██▌       | 130/512 [37:59<1:51:37, 17.53s/it]
INFO:root:函数头: 
    @staticmethod
    def _compute_idf(sentences):

INFO:root:目标函数体: 
        idf_metrics = {}
        sentences_count = len(sentences)

        for sentence in sentences:
            for term in sentence:
                if term not in idf_metrics:
                    n_j = sum(1 for s in sentences if term in s)
                    idf_metrics[term] = math.log(sentences_count / (1 + n_j))

        return idf_metrics

INFO:root:生成结果: 
        # Implement the IDF computation here
        # You can use resources in the current project, and you MUST write import statements FIRST to call the corresponding resource.
        # Example:
        # from ..utils import get_stop_words

        idf_metrics = {}
        stop_words = get_stop_words()  # Assuming stop_words is defined in sumy/utils.py
        total_sentences = len(sentences)

        for term in set(chain.from_iterable(sentences)):
            term_count = sum(term in sentence for sentence in sentences if term not in stop_words)
            idf_metrics[term] = math.log(total_sentences / term_count)

        return idf_metrics


INFO:root:----------------------------------------
INFO:root:max length: 8537
INFO:root:max position: 12508
INFO:root:target_namespace: sumy.sumy<folder>.summarizers<folder>.lex_rank<file>.LexRankSummarizer<class>._compute_idf<func>
INFO:root:****************************************
INFO:root:--------data 27--------

data 27:   0%|          | 0/512 [00:00<?, ?it/s]
data 27:   2%|▏         | 10/512 [02:32<2:07:33, 15.25s/it]
data 27:   4%|▍         | 20/512 [05:14<2:09:48, 15.83s/it]
data 27:   6%|▌         | 30/512 [08:03<2:11:01, 16.31s/it]
data 27:   8%|▊         | 40/512 [11:03<2:13:31, 16.97s/it]
data 27:  10%|▉         | 50/512 [13:28<2:03:47, 16.08s/it]
data 27:  12%|█▏        | 60/512 [16:02<1:59:19, 15.84s/it]
data 27:  14%|█▎        | 70/512 [18:31<1:54:24, 15.53s/it]
data 27:  16%|█▌        | 80/512 [20:52<1:48:31, 15.07s/it]
data 27:  18%|█▊        | 90/512 [23:32<1:48:02, 15.36s/it]
data 27:  20%|█▉        | 100/512 [26:20<1:48:41, 15.83s/it]
data 27:  21%|██▏       | 110/512 [29:12<1:48:50, 16.25s/it]
data 27:  21%|██▏       | 110/512 [31:42<1:55:52, 17.29s/it]
INFO:root:函数头: 
    @staticmethod
    def cosine_similarity(sentence1, sentence2, tf1, tf2, idf_metrics):

INFO:root:目标函数体: 
        
        unique_words1 = frozenset(sentence1)
        unique_words2 = frozenset(sentence2)
        common_words = unique_words1 & unique_words2

        numerator = 0.0
        for term in common_words:
            numerator += tf1[term]*tf2[term] * idf_metrics[term]**2

        denominator1 = sum((tf1[t]*idf_metrics[t])**2 for t in unique_words1)
        denominator2 = sum((tf2[t]*idf_metrics[t])**2 for t in unique_words2)

        if denominator1 > 0 and denominator2 > 0:
            return numerator / (math.sqrt(denominator1) * math.sqrt(denominator2))
        else:
            return 0.0

INFO:root:生成结果: 
        norm_A = math.sqrt(sum(tf1[term] ** 2 for term in tf1))
        norm_B = math.sqrt(sum(tf2[term] ** 2 for term in tf2))
        if norm_A == 0 or norm_B == 0:
            return -1.0

        numerator = sum(tf1[term] * tf2.get(term, 0) * idf_metrics.get(term, 0) for term in tf1 if term in tf2)
        denominator = norm_A * norm_B
        return numerator / denominator

INFO:root:----------------------------------------
INFO:root:max length: 9678
INFO:root:max position: 13422
INFO:root:target_namespace: sumy.sumy<folder>.summarizers<folder>.lex_rank<file>.LexRankSummarizer<class>.cosine_similarity<func>
INFO:root:****************************************

data 27:   0%|          | 0/512 [00:00<?, ?it/s]
data 27:   2%|▏         | 10/512 [02:33<2:08:37, 15.37s/it]
data 27:   4%|▍         | 20/512 [05:27<2:15:42, 16.55s/it]
data 27:   6%|▌         | 30/512 [08:19<2:15:30, 16.87s/it]
data 27:   8%|▊         | 40/512 [11:00<2:10:12, 16.55s/it]
data 27:  10%|▉         | 50/512 [15:03<2:28:59, 19.35s/it]
data 27:  10%|▉         | 50/512 [16:38<2:33:41, 19.96s/it]
INFO:root:函数头: 
    @staticmethod
    def cosine_similarity(sentence1, sentence2, tf1, tf2, idf_metrics):

INFO:root:目标函数体: 
        
        unique_words1 = frozenset(sentence1)
        unique_words2 = frozenset(sentence2)
        common_words = unique_words1 & unique_words2

        numerator = 0.0
        for term in common_words:
            numerator += tf1[term]*tf2[term] * idf_metrics[term]**2

        denominator1 = sum((tf1[t]*idf_metrics[t])**2 for t in unique_words1)
        denominator2 = sum((tf2[t]*idf_metrics[t])**2 for t in unique_words2)

        if denominator1 > 0 and denominator2 > 0:
            return numerator / (math.sqrt(denominator1) * math.sqrt(denominator2))
        else:
            return 0.0

INFO:root:生成结果: 
        # Implement the cosine similarity calculation here
        # Use tf_metrics and idf_metrics to compute the cosine similarity between sentence1 and sentence2
        # Return the cosine similarity as a float between -1.0 and 1.0
        pass


INFO:root:----------------------------------------
INFO:root:max length: 8501
INFO:root:max position: 13139
INFO:root:target_namespace: sumy.sumy<folder>.summarizers<folder>.lex_rank<file>.LexRankSummarizer<class>.cosine_similarity<func>
INFO:root:****************************************

data 27:   0%|          | 0/512 [00:00<?, ?it/s]
data 27:   2%|▏         | 10/512 [02:38<2:12:31, 15.84s/it]
data 27:   2%|▏         | 10/512 [04:04<3:24:48, 24.48s/it]
INFO:root:函数头: 
    @staticmethod
    def cosine_similarity(sentence1, sentence2, tf1, tf2, idf_metrics):

INFO:root:目标函数体: 
        
        unique_words1 = frozenset(sentence1)
        unique_words2 = frozenset(sentence2)
        common_words = unique_words1 & unique_words2

        numerator = 0.0
        for term in common_words:
            numerator += tf1[term]*tf2[term] * idf_metrics[term]**2

        denominator1 = sum((tf1[t]*idf_metrics[t])**2 for t in unique_words1)
        denominator2 = sum((tf2[t]*idf_metrics[t])**2 for t in unique_words2)

        if denominator1 > 0 and denominator2 > 0:
            return numerator / (math.sqrt(denominator1) * math.sqrt(denominator2))
        else:
            return 0.0

INFO:root:生成结果: 
        # Implement the cosine similarity calculation here
        # ...


INFO:root:----------------------------------------
INFO:root:max length: 7520
INFO:root:max position: 12449
INFO:root:target_namespace: sumy.sumy<folder>.summarizers<folder>.lex_rank<file>.LexRankSummarizer<class>.cosine_similarity<func>
INFO:root:****************************************

data 27:   0%|          | 0/512 [00:00<?, ?it/s]
data 27:   2%|▏         | 10/512 [02:41<2:15:01, 16.14s/it]
data 27:   4%|▍         | 20/512 [07:03<3:00:53, 22.06s/it]
data 27:   6%|▌         | 30/512 [09:54<2:39:05, 19.80s/it]
data 27:   6%|▌         | 30/512 [11:52<3:10:47, 23.75s/it]
INFO:root:函数头: 
    @staticmethod
    def cosine_similarity(sentence1, sentence2, tf1, tf2, idf_metrics):

INFO:root:目标函数体: 
        
        unique_words1 = frozenset(sentence1)
        unique_words2 = frozenset(sentence2)
        common_words = unique_words1 & unique_words2

        numerator = 0.0
        for term in common_words:
            numerator += tf1[term]*tf2[term] * idf_metrics[term]**2

        denominator1 = sum((tf1[t]*idf_metrics[t])**2 for t in unique_words1)
        denominator2 = sum((tf2[t]*idf_metrics[t])**2 for t in unique_words2)

        if denominator1 > 0 and denominator2 > 0:
            return numerator / (math.sqrt(denominator1) * math.sqrt(denominator2))
        else:
            return 0.0

INFO:root:生成结果: 
        # Implement the cosine similarity calculation here
        # Use tf_metrics and idf_metrics to compute the cosine similarity
        # Return the cosine similarity value
        pass


INFO:root:----------------------------------------
INFO:root:max length: 9225
INFO:root:max position: 13162
INFO:root:target_namespace: sumy.sumy<folder>.summarizers<folder>.lex_rank<file>.LexRankSummarizer<class>.cosine_similarity<func>
INFO:root:****************************************

data 27:   0%|          | 0/512 [00:00<?, ?it/s]
data 27:   2%|▏         | 10/512 [02:33<2:08:46, 15.39s/it]
data 27:   4%|▍         | 20/512 [05:27<2:15:48, 16.56s/it]
data 27:   6%|▌         | 30/512 [08:23<2:16:36, 17.01s/it]
data 27:   8%|▊         | 40/512 [11:08<2:12:29, 16.84s/it]
data 27:   8%|▊         | 40/512 [12:36<2:28:41, 18.90s/it]
INFO:root:函数头: 
    @staticmethod
    def cosine_similarity(sentence1, sentence2, tf1, tf2, idf_metrics):

INFO:root:目标函数体: 
        
        unique_words1 = frozenset(sentence1)
        unique_words2 = frozenset(sentence2)
        common_words = unique_words1 & unique_words2

        numerator = 0.0
        for term in common_words:
            numerator += tf1[term]*tf2[term] * idf_metrics[term]**2

        denominator1 = sum((tf1[t]*idf_metrics[t])**2 for t in unique_words1)
        denominator2 = sum((tf2[t]*idf_metrics[t])**2 for t in unique_words2)

        if denominator1 > 0 and denominator2 > 0:
            return numerator / (math.sqrt(denominator1) * math.sqrt(denominator2))
        else:
            return 0.0

INFO:root:生成结果: 
        # Implement the cosine similarity calculation here
        # Use tf_metrics and idf_metrics to compute the cosine similarity between sentence1 and sentence2
        # Return the computed cosine similarity as a float
        pass


INFO:root:----------------------------------------
INFO:root:max length: 8093
INFO:root:max position: 12744
INFO:root:target_namespace: sumy.sumy<folder>.summarizers<folder>.lex_rank<file>.LexRankSummarizer<class>.cosine_similarity<func>
INFO:root:****************************************
INFO:root:--------data 28--------

data 28:   0%|          | 0/512 [00:00<?, ?it/s]
data 28:   2%|▏         | 10/512 [01:10<59:14,  7.08s/it]
data 28:   4%|▍         | 20/512 [02:25<59:48,  7.29s/it]
data 28:   6%|▌         | 30/512 [03:40<59:32,  7.41s/it]
data 28:   8%|▊         | 40/512 [04:54<58:11,  7.40s/it]
data 28:   8%|▊         | 40/512 [05:15<1:02:00,  7.88s/it]
INFO:root:函数头: 
def _get_ngrams(n, text):

INFO:root:目标函数体: 
    ngram_set = set()
    text_length = len(text)
    max_index_ngram_start = text_length - n
    for i in range(max_index_ngram_start + 1):
        ngram_set.add(tuple(text[i:i + n]))
    return ngram_set

INFO:root:生成结果: 
    ngrams = set()
    words = text.split()
    for i in range(len(words) - n + 1):
        ngrams.add(tuple(words[i:i+n]))
    return ngrams


INFO:root:----------------------------------------
INFO:root:max length: 6499
INFO:root:max position: 8517
INFO:root:target_namespace: sumy.sumy<folder>.evaluation<folder>.rouge<file>._get_ngrams<func>
INFO:root:****************************************

data 28:   0%|          | 0/512 [00:00<?, ?it/s]
data 28:   2%|▏         | 10/512 [01:05<54:46,  6.55s/it]
data 28:   4%|▍         | 20/512 [02:21<58:50,  7.18s/it]
data 28:   6%|▌         | 30/512 [04:52<1:26:31, 10.77s/it]
data 28:   8%|▊         | 40/512 [10:15<2:31:42, 19.28s/it]
data 28:   8%|▊         | 40/512 [10:31<2:04:13, 15.79s/it]
INFO:root:函数头: 
def _get_ngrams(n, text):

INFO:root:目标函数体: 
    ngram_set = set()
    text_length = len(text)
    max_index_ngram_start = text_length - n
    for i in range(max_index_ngram_start + 1):
        ngram_set.add(tuple(text[i:i + n]))
    return ngram_set

INFO:root:生成结果: 
    text = text.lower()
    ngrams = set()
    for i in range(len(text) - n + 1):
        ngrams.add(text[i:i+n])
    return ngrams


INFO:root:----------------------------------------
INFO:root:max length: 6970
INFO:root:max position: 9146
INFO:root:target_namespace: sumy.sumy<folder>.evaluation<folder>.rouge<file>._get_ngrams<func>
INFO:root:****************************************

data 28:   0%|          | 0/512 [00:00<?, ?it/s]
data 28:   2%|▏         | 10/512 [01:17<1:04:58,  7.77s/it]
data 28:   4%|▍         | 20/512 [02:43<1:07:43,  8.26s/it]
data 28:   6%|▌         | 30/512 [04:19<1:11:19,  8.88s/it]
data 28:   8%|▊         | 40/512 [06:57<1:31:05, 11.58s/it]
data 28:   8%|▊         | 40/512 [07:21<1:26:52, 11.04s/it]
INFO:root:函数头: 
def _get_ngrams(n, text):

INFO:root:目标函数体: 
    ngram_set = set()
    text_length = len(text)
    max_index_ngram_start = text_length - n
    for i in range(max_index_ngram_start + 1):
        ngram_set.add(tuple(text[i:i + n]))
    return ngram_set

INFO:root:生成结果: 
    ngrams = set()
    words = text.split()
    for i in range(len(words) - n + 1):
        ngrams.add(tuple(words[i:i+n]))
    return ngrams




INFO:root:----------------------------------------
INFO:root:max length: 6626
INFO:root:max position: 8187
INFO:root:target_namespace: sumy.sumy<folder>.evaluation<folder>.rouge<file>._get_ngrams<func>
INFO:root:****************************************

data 28:   0%|          | 0/512 [00:00<?, ?it/s]
data 28:   2%|▏         | 10/512 [02:34<2:09:26, 15.47s/it]
data 28:   4%|▍         | 20/512 [04:56<2:00:50, 14.74s/it]
data 28:   6%|▌         | 30/512 [06:21<1:35:29, 11.89s/it]
data 28:   8%|▊         | 40/512 [07:46<1:22:48, 10.53s/it]
data 28:   8%|▊         | 40/512 [08:30<1:40:21, 12.76s/it]
INFO:root:函数头: 
def _get_ngrams(n, text):

INFO:root:目标函数体: 
    ngram_set = set()
    text_length = len(text)
    max_index_ngram_start = text_length - n
    for i in range(max_index_ngram_start + 1):
        ngram_set.add(tuple(text[i:i + n]))
    return ngram_set

INFO:root:生成结果: 
    words = text.split()
    ngrams = set()
    for i in range(len(words) - n + 1):
        ngrams.add(' '.join(words[i:i+n]))
    return ngrams




INFO:root:----------------------------------------
INFO:root:max length: 6527
INFO:root:max position: 8411
INFO:root:target_namespace: sumy.sumy<folder>.evaluation<folder>.rouge<file>._get_ngrams<func>
INFO:root:****************************************

data 28:   0%|          | 0/512 [00:00<?, ?it/s]
data 28:   2%|▏         | 10/512 [04:29<3:45:26, 26.95s/it]
data 28:   4%|▍         | 20/512 [05:55<2:12:19, 16.14s/it]
data 28:   6%|▌         | 30/512 [07:20<1:41:53, 12.68s/it]
data 28:   8%|▊         | 40/512 [08:44<1:26:23, 10.98s/it]
data 28:   8%|▊         | 40/512 [09:08<1:47:57, 13.72s/it]
INFO:root:函数头: 
def _get_ngrams(n, text):

INFO:root:目标函数体: 
    ngram_set = set()
    text_length = len(text)
    max_index_ngram_start = text_length - n
    for i in range(max_index_ngram_start + 1):
        ngram_set.add(tuple(text[i:i + n]))
    return ngram_set

INFO:root:生成结果: 
    words = text.split()
    ngrams = set()
    for i in range(len(words) - n + 1):
        ngrams.add(tuple(words[i:i+n]))
    return ngrams




INFO:root:----------------------------------------
INFO:root:max length: 6847
INFO:root:max position: 8470
INFO:root:target_namespace: sumy.sumy<folder>.evaluation<folder>.rouge<file>._get_ngrams<func>
INFO:root:****************************************
INFO:root:--------data 29--------

data 29:   0%|          | 0/512 [00:00<?, ?it/s]
data 29:   2%|▏         | 10/512 [01:22<1:09:00,  8.25s/it]
data 29:   4%|▍         | 20/512 [02:43<1:06:50,  8.15s/it]
data 29:   6%|▌         | 30/512 [04:06<1:06:14,  8.25s/it]
data 29:   8%|▊         | 40/512 [05:32<1:05:46,  8.36s/it]
data 29:   8%|▊         | 40/512 [05:58<1:10:31,  8.96s/it]
INFO:root:函数头: 
def _split_into_words(sentences):

INFO:root:目标函数体: 
    full_text_words = []
    for s in sentences:
        if not isinstance(s, Sentence):
            raise (ValueError("Object in collection must be of type Sentence"))
        full_text_words.extend(s.words)
    return full_text_words

INFO:root:生成结果: 
    words = []
    for sentence in sentences:
        if not isinstance(sentence, Sentence):
            raise ValueError("Object in collection must be of type Sentence")
        words.extend(sentence.words)
    return words




INFO:root:----------------------------------------
INFO:root:max length: 7067
INFO:root:max position: 8526
INFO:root:target_namespace: sumy.sumy<folder>.evaluation<folder>.rouge<file>._split_into_words<func>
INFO:root:****************************************

data 29:   0%|          | 0/512 [00:00<?, ?it/s]
data 29:   2%|▏         | 10/512 [01:18<1:05:17,  7.80s/it]
data 29:   4%|▍         | 20/512 [02:45<1:08:34,  8.36s/it]
data 29:   6%|▌         | 30/512 [04:10<1:07:46,  8.44s/it]
data 29:   8%|▊         | 40/512 [05:31<1:05:21,  8.31s/it]
data 29:   8%|▊         | 40/512 [05:58<1:10:30,  8.96s/it]
INFO:root:函数头: 
def _split_into_words(sentences):

INFO:root:目标函数体: 
    full_text_words = []
    for s in sentences:
        if not isinstance(s, Sentence):
            raise (ValueError("Object in collection must be of type Sentence"))
        full_text_words.extend(s.words)
    return full_text_words

INFO:root:生成结果: 
    words = []
    for sentence in sentences:
        if not isinstance(sentence, Sentence):
            raise ValueError("Object in collection must be of type Sentence")
        words.extend(sentence.tokens)
    return words




INFO:root:----------------------------------------
INFO:root:max length: 7154
INFO:root:max position: 9323
INFO:root:target_namespace: sumy.sumy<folder>.evaluation<folder>.rouge<file>._split_into_words<func>
INFO:root:****************************************

data 29:   0%|          | 0/512 [00:00<?, ?it/s]
data 29:   2%|▏         | 10/512 [01:14<1:02:44,  7.50s/it]
data 29:   4%|▍         | 20/512 [02:40<1:06:30,  8.11s/it]
data 29:   6%|▌         | 30/512 [03:53<1:02:08,  7.74s/it]
data 29:   8%|▊         | 40/512 [05:08<1:00:03,  7.63s/it]
data 29:   8%|▊         | 40/512 [05:30<1:05:02,  8.27s/it]
INFO:root:函数头: 
def _split_into_words(sentences):

INFO:root:目标函数体: 
    full_text_words = []
    for s in sentences:
        if not isinstance(s, Sentence):
            raise (ValueError("Object in collection must be of type Sentence"))
        full_text_words.extend(s.words)
    return full_text_words

INFO:root:生成结果: 
    words = []
    for sentence in sentences:
        if not isinstance(sentence, Sentence):
            raise ValueError("Object in collection must be of type Sentence")
        words.extend(sentence.tokens)
    return words




INFO:root:----------------------------------------
INFO:root:max length: 6879
INFO:root:max position: 8702
INFO:root:target_namespace: sumy.sumy<folder>.evaluation<folder>.rouge<file>._split_into_words<func>
INFO:root:****************************************

data 29:   0%|          | 0/512 [00:00<?, ?it/s]
data 29:   2%|▏         | 10/512 [09:05<7:36:41, 54.59s/it]
data 29:   4%|▍         | 20/512 [10:24<3:42:11, 27.10s/it]
data 29:   6%|▌         | 30/512 [11:41<2:26:35, 18.25s/it]
data 29:   8%|▊         | 40/512 [12:54<1:49:31, 13.92s/it]
data 29:   8%|▊         | 40/512 [13:16<2:36:40, 19.92s/it]
INFO:root:函数头: 
def _split_into_words(sentences):

INFO:root:目标函数体: 
    full_text_words = []
    for s in sentences:
        if not isinstance(s, Sentence):
            raise (ValueError("Object in collection must be of type Sentence"))
        full_text_words.extend(s.words)
    return full_text_words

INFO:root:生成结果: 
    words = []
    for sentence in sentences:
        if not isinstance(sentence, Sentence):
            raise ValueError("Object in collection must be of type Sentence")
        words.extend(sentence.words)
    return words




INFO:root:----------------------------------------
INFO:root:max length: 7317
INFO:root:max position: 8285
INFO:root:target_namespace: sumy.sumy<folder>.evaluation<folder>.rouge<file>._split_into_words<func>
INFO:root:****************************************

data 29:   0%|          | 0/512 [00:00<?, ?it/s]
data 29:   2%|▏         | 10/512 [01:06<55:39,  6.65s/it]
data 29:   4%|▍         | 20/512 [10:22<4:50:52, 35.47s/it]
data 29:   6%|▌         | 30/512 [16:42<4:54:12, 36.62s/it]
data 29:   8%|▊         | 40/512 [18:03<3:19:17, 25.33s/it]
data 29:   8%|▊         | 40/512 [18:24<3:37:07, 27.60s/it]
INFO:root:函数头: 
def _split_into_words(sentences):

INFO:root:目标函数体: 
    full_text_words = []
    for s in sentences:
        if not isinstance(s, Sentence):
            raise (ValueError("Object in collection must be of type Sentence"))
        full_text_words.extend(s.words)
    return full_text_words

INFO:root:生成结果: 
    words = []
    for sentence in sentences:
        if not isinstance(sentence, Sentence):
            raise ValueError("Object in collection must be of type Sentence")
        words.extend(sentence.words)
    return words




INFO:root:----------------------------------------
INFO:root:max length: 6838
INFO:root:max position: 8469
INFO:root:target_namespace: sumy.sumy<folder>.evaluation<folder>.rouge<file>._split_into_words<func>
INFO:root:****************************************
INFO:root:--------data 30--------

data 30:   0%|          | 0/512 [00:00<?, ?it/s]
data 30:   2%|▏         | 10/512 [01:38<1:22:26,  9.85s/it]
data 30:   4%|▍         | 20/512 [05:22<2:21:04, 17.20s/it]
data 30:   6%|▌         | 30/512 [15:02<4:48:00, 35.85s/it]
data 30:   8%|▊         | 40/512 [36:46<9:35:32, 73.16s/it]
data 30:  10%|▉         | 50/512 [38:29<6:28:48, 50.49s/it]
data 30:  10%|▉         | 50/512 [39:26<6:04:30, 47.34s/it]
INFO:root:函数头: 
def register_router(router_class):

INFO:root:目标函数体: 
    

    def wraps(fn):
        # Omit body code

    return wraps

INFO:root:生成结果: 
    registered_routers = {}
    def decorator(func):
        if router_class in registered_routers:
            raise ValueError('Router class {} is already registered'.format(router_class))
        registered_routers[router_class] = func
        return func
    return decorator




INFO:root:----------------------------------------
INFO:root:max length: 8713
INFO:root:max position: 10999
INFO:root:target_namespace: falcon.falcon<folder>.inspect<file>.register_router<func>
INFO:root:****************************************

data 30:   0%|          | 0/512 [00:00<?, ?it/s]
data 30:   2%|▏         | 10/512 [02:34<2:09:24, 15.47s/it]
data 30:   4%|▍         | 20/512 [04:08<1:37:36, 11.90s/it]
data 30:   6%|▌         | 30/512 [05:46<1:27:43, 10.92s/it]
data 30:   8%|▊         | 40/512 [07:26<1:22:58, 10.55s/it]
data 30:  10%|▉         | 50/512 [09:07<1:20:00, 10.39s/it]
data 30:  10%|▉         | 50/512 [10:06<1:33:21, 12.13s/it]
INFO:root:函数头: 
def register_router(router_class):

INFO:root:目标函数体: 
    

    def wraps(fn):
        # Omit body code

    return wraps

INFO:root:生成结果: 
    if router_class in _supported_routers:
        raise ValueError(f'Router class {router_class} is already registered')

    def decorator(inspect_function):
        _supported_routers[router_class] = inspect_function
        return inspect_function

    return decorator




INFO:root:----------------------------------------
INFO:root:max length: 8794
INFO:root:max position: 11213
INFO:root:target_namespace: falcon.falcon<folder>.inspect<file>.register_router<func>
INFO:root:****************************************

data 30:   0%|          | 0/512 [00:00<?, ?it/s]
data 30:   2%|▏         | 10/512 [01:40<1:23:57, 10.03s/it]
data 30:   4%|▍         | 20/512 [03:17<1:20:59,  9.88s/it]
data 30:   6%|▌         | 30/512 [04:52<1:17:39,  9.67s/it]
data 30:   8%|▊         | 40/512 [06:22<1:14:13,  9.44s/it]
data 30:  10%|▉         | 50/512 [08:00<1:13:28,  9.54s/it]
data 30:  12%|█▏        | 60/512 [09:37<1:12:20,  9.60s/it]
data 30:  12%|█▏        | 60/512 [09:46<1:13:41,  9.78s/it]
INFO:root:函数头: 
def register_router(router_class):

INFO:root:目标函数体: 
    

    def wraps(fn):
        # Omit body code

    return wraps

INFO:root:生成结果: 
    def decorator(inspect_function):
        if inspect_function in _supported_routers:
            raise ValueError(
                'Router class {} is already registered'.format(inspect_function)
            )
        _supported_routers[router_class] = inspect_function
        return inspect_function

    return decorator




INFO:root:----------------------------------------
INFO:root:max length: 8565
INFO:root:max position: 10869
INFO:root:target_namespace: falcon.falcon<folder>.inspect<file>.register_router<func>
INFO:root:****************************************

data 30:   0%|          | 0/512 [00:00<?, ?it/s]
data 30:   2%|▏         | 10/512 [01:31<1:16:43,  9.17s/it]
data 30:   2%|▏         | 10/512 [02:22<1:59:28, 14.28s/it]
INFO:root:函数头: 
def register_router(router_class):

INFO:root:目标函数体: 
    

    def wraps(fn):
        # Omit body code

    return wraps

INFO:root:生成结果: 
    _supported_routers[router_class] = inspect_function




INFO:root:----------------------------------------
INFO:root:max length: 7911
INFO:root:max position: 10929
INFO:root:target_namespace: falcon.falcon<folder>.inspect<file>.register_router<func>
INFO:root:****************************************

data 30:   0%|          | 0/512 [00:00<?, ?it/s]
data 30:   2%|▏         | 10/512 [01:29<1:15:17,  9.00s/it]
data 30:   4%|▍         | 20/512 [03:10<1:19:05,  9.65s/it]
data 30:   6%|▌         | 30/512 [04:56<1:20:51, 10.06s/it]
data 30:   8%|▊         | 40/512 [06:33<1:17:59,  9.92s/it]
data 30:  10%|▉         | 50/512 [08:10<1:15:37,  9.82s/it]
data 30:  12%|█▏        | 60/512 [09:42<1:12:30,  9.62s/it]
data 30:  12%|█▏        | 60/512 [10:43<1:20:48, 10.73s/it]
INFO:root:函数头: 
def register_router(router_class):

INFO:root:目标函数体: 
    

    def wraps(fn):
        # Omit body code

    return wraps

INFO:root:生成结果: 
    _supported_routers[router_class] = None

    def decorator(func):
        if _supported_routers[router_class] is not None:
            raise ValueError(f'Re-router {router_class} already registered')
        _supported_routers[router_class] = func
        return func

    return decorator




INFO:root:----------------------------------------
INFO:root:max length: 8589
INFO:root:max position: 11052
INFO:root:target_namespace: falcon.falcon<folder>.inspect<file>.register_router<func>
INFO:root:****************************************
INFO:root:--------data 31--------

data 31:   0%|          | 0/512 [00:00<?, ?it/s]
data 31:   2%|▏         | 10/512 [01:32<1:17:10,  9.22s/it]
data 31:   4%|▍         | 20/512 [02:57<1:12:13,  8.81s/it]
data 31:   6%|▌         | 30/512 [04:26<1:11:07,  8.85s/it]
data 31:   8%|▊         | 40/512 [05:49<1:07:51,  8.63s/it]
data 31:  10%|▉         | 50/512 [07:10<1:04:58,  8.44s/it]
data 31:  12%|█▏        | 60/512 [08:31<1:02:43,  8.33s/it]
data 31:  14%|█▎        | 70/512 [10:03<1:03:26,  8.61s/it]
data 31:  16%|█▌        | 80/512 [11:31<1:02:31,  8.68s/it]
data 31:  18%|█▊        | 90/512 [13:08<1:03:16,  9.00s/it]
data 31:  20%|█▉        | 100/512 [14:43<1:02:46,  9.14s/it]
data 31:  21%|██▏       | 110/512 [16:20<1:02:26,  9.32s/it]
data 31:  23%|██▎       | 120/512 [17:56<1:01:26,  9.40s/it]
data 31:  25%|██▌       | 130/512 [19:29<59:43,  9.38s/it]  
data 31:  27%|██▋       | 140/512 [21:06<58:40,  9.46s/it]
data 31:  29%|██▉       | 150/512 [22:45<57:51,  9.59s/it]
data 31:  31%|███▏      | 160/512 [24:22<56:27,  9.62s/it]
data 31:  33%|███▎      | 170/512 [25:59<55:03,  9.66s/it]
data 31:  35%|███▌      | 180/512 [27:37<53:44,  9.71s/it]
data 31:  37%|███▋      | 190/512 [29:03<50:20,  9.38s/it]
data 31:  39%|███▉      | 200/512 [30:23<46:31,  8.95s/it]
data 31:  41%|████      | 210/512 [31:48<44:19,  8.81s/it]
data 31:  43%|████▎     | 220/512 [33:05<41:18,  8.49s/it]
data 31:  45%|████▍     | 230/512 [34:33<40:20,  8.58s/it]
data 31:  47%|████▋     | 240/512 [36:12<40:41,  8.98s/it]
data 31:  49%|████▉     | 250/512 [37:47<39:55,  9.14s/it]
data 31:  51%|█████     | 260/512 [39:23<38:51,  9.25s/it]
data 31:  53%|█████▎    | 270/512 [40:47<36:20,  9.01s/it]
data 31:  55%|█████▍    | 280/512 [42:09<33:57,  8.78s/it]
data 31:  57%|█████▋    | 290/512 [43:44<33:12,  8.98s/it]
data 31:  59%|█████▊    | 300/512 [45:24<32:47,  9.28s/it]
data 31:  61%|██████    | 310/512 [47:05<32:05,  9.53s/it]
data 31:  62%|██████▎   | 320/512 [48:48<31:16,  9.77s/it]
data 31:  64%|██████▍   | 330/512 [50:35<30:27, 10.04s/it]
data 31:  66%|██████▋   | 340/512 [52:16<28:50, 10.06s/it]
data 31:  68%|██████▊   | 350/512 [53:56<27:04, 10.03s/it]
data 31:  70%|███████   | 360/512 [55:30<24:55,  9.84s/it]
data 31:  72%|███████▏  | 370/512 [57:04<23:01,  9.73s/it]
data 31:  74%|███████▍  | 380/512 [58:44<21:34,  9.80s/it]
data 31:  76%|███████▌  | 390/512 [1:00:18<19:40,  9.67s/it]
data 31:  78%|███████▊  | 400/512 [1:01:56<18:07,  9.71s/it]
data 31:  80%|████████  | 410/512 [1:03:30<16:21,  9.63s/it]
data 31:  82%|████████▏ | 420/512 [1:05:05<14:41,  9.58s/it]
data 31:  84%|████████▍ | 430/512 [1:06:41<13:08,  9.61s/it]
data 31:  86%|████████▌ | 440/512 [1:08:19<11:35,  9.66s/it]
data 31:  88%|████████▊ | 450/512 [1:09:46<09:40,  9.36s/it]
data 31:  90%|████████▉ | 460/512 [1:11:15<07:59,  9.23s/it]
data 31:  92%|█████████▏| 470/512 [1:12:34<06:11,  8.85s/it]
data 31:  94%|█████████▍| 480/512 [1:13:50<04:31,  8.47s/it]
data 31:  96%|█████████▌| 490/512 [1:15:07<03:01,  8.23s/it]
data 31:  98%|█████████▊| 500/512 [1:16:19<01:34,  7.91s/it]
data 31: 100%|█████████▉| 510/512 [1:19:38<00:23, 11.51s/it]
data 31: 100%|█████████▉| 510/512 [1:20:01<00:18,  9.41s/it]
INFO:root:函数头: 
@register_router(CompiledRouter)
def inspect_compiled_router(router: CompiledRouter) -> 'List[RouteInfo]':

INFO:root:目标函数体: 
    

    def _traverse(roots, parent):
        # Omit body code

    routes = []  # type: List[RouteInfo]
    _traverse(router._roots, '')
    return routes

INFO:root:生成结果: 
    routes = []
    for route in router._routes.values():
        methods = []
        for method in route.methods:
            methods.append(method.upper())
        info = RouteInfo(
            route.path,
            methods,
            route.resource,
            route.app,
            route.methods,
            route.methods,
            route.methods,
            route.methods,
            route.methods,
            route.methods,
            route.methods,
            route.methods,
            route.methods,
            route.methods,
            route.methods,
            route.methods,
            route.methods,
            route.methods,
            route.methods,
            route.methods,
            route.methods,
            route.methods,
            route.methods,
            route.methods,
            route.methods,
            route.methods,
            route.methods,
            route.methods,
            route.methods,
            route.methods,
            route.methods,
            route.methods,
            route.methods,
            route.methods,
            route.methods,
            route.methods,
            route.methods,
            route.methods,
            route.methods,
            route.methods,
            route.methods,
            route.methods,
            route.methods,
            route.methods,
            route.methods,
            route.methods,
            route.methods,
            route.methods,
            route.methods,
            route.methods,
            route.methods,
            route.methods,
            route.methods,
            route.methods,
            route.methods,
            route.methods,
            route.methods,
            route.methods,
            route.methods,
            route.methods,
            route.methods,
            route.methods,
            route.methods,
            route.methods,
            route.methods,
            route.methods,
            route.methods,
            route.methods,
            route.methods,
            route.methods,
            route.methods,
            route.methods,
            route.methods,
            route.methods,
            route.methods,
            route.methods,
            route.methods,
            route.methods,
            route.methods,
            route.methods,
            route.methods,
            route.methods,
            route.methods,
            route.methods,
            route.methods,
            route.methods,
            route.methods,
            route.methods,
            route.methods,
            route.methods,
            route.methods,
            route.methods,
            route.methods,
            route.methods,
            route.methods,
            route.methods,
            route.methods,
            route.methods,
            route.methods,
            route.methods,
            route.methods,
            route.methods,
            route.methods,
            route.methods,
            route.methods,
            route.methods,
            route.methods,
            route.methods,
            route.methods,
            route.methods,
            route.methods,
            route.methods,
            route.methods,
            route.methods,
            route.methods,
            route.methods,
            route.methods,
            route.methods,
            route.methods,
           

INFO:root:----------------------------------------
INFO:root:max length: 10528
INFO:root:max position: 12929
INFO:root:target_namespace: falcon.falcon<folder>.inspect<file>.inspect_compiled_router<func>
INFO:root:****************************************

data 31:   0%|          | 0/512 [00:00<?, ?it/s]
data 31:   2%|▏         | 10/512 [01:22<1:09:10,  8.27s/it]
data 31:   4%|▍         | 20/512 [02:44<1:07:17,  8.21s/it]
data 31:   6%|▌         | 30/512 [04:08<1:06:38,  8.30s/it]
data 31:   8%|▊         | 40/512 [05:27<1:04:01,  8.14s/it]
data 31:  10%|▉         | 50/512 [06:42<1:01:00,  7.92s/it]
data 31:  12%|█▏        | 60/512 [08:02<59:42,  7.93s/it]  
data 31:  14%|█▎        | 70/512 [09:28<1:00:03,  8.15s/it]
data 31:  14%|█▎        | 70/512 [10:13<1:04:34,  8.77s/it]
INFO:root:函数头: 
@register_router(CompiledRouter)
def inspect_compiled_router(router: CompiledRouter) -> 'List[RouteInfo]':

INFO:root:目标函数体: 
    

    def _traverse(roots, parent):
        # Omit body code

    routes = []  # type: List[RouteInfo]
    _traverse(router._roots, '')
    return routes

INFO:root:生成结果: 
    routes = []
    for rule in router._rules.values():
        method_names = [method.upper() for method in rule.methods]
        route_info = RouteInfo(
            rule.path,
            method_names,
            rule.resource,
            rule._middlewares,
            rule._methods,
            rule._kwargs,
        )
        routes.append(route_info)
    return routes




INFO:root:----------------------------------------
INFO:root:max length: 9762
INFO:root:max position: 12353
INFO:root:target_namespace: falcon.falcon<folder>.inspect<file>.inspect_compiled_router<func>
INFO:root:****************************************

data 31:   0%|          | 0/512 [00:00<?, ?it/s]
data 31:   2%|▏         | 10/512 [01:20<1:07:38,  8.09s/it]
data 31:   4%|▍         | 20/512 [02:43<1:07:09,  8.19s/it]
data 31:   6%|▌         | 30/512 [04:06<1:06:11,  8.24s/it]
data 31:   8%|▊         | 40/512 [05:30<1:05:25,  8.32s/it]
data 31:   8%|▊         | 40/512 [06:32<1:17:07,  9.80s/it]
INFO:root:函数头: 
@register_router(CompiledRouter)
def inspect_compiled_router(router: CompiledRouter) -> 'List[RouteInfo]':

INFO:root:目标函数体: 
    

    def _traverse(roots, parent):
        # Omit body code

    routes = []  # type: List[RouteInfo]
    _traverse(router._roots, '')
    return routes

INFO:root:生成结果: 
    routes = []
    for route in router.routes:
        method_info = []
        for method in route.methods:
            method_info.append(MethodInfo(method))
        routes.append(RouteInfo(route.path, method_info))
    return routes




INFO:root:----------------------------------------
INFO:root:max length: 9790
INFO:root:max position: 11721
INFO:root:target_namespace: falcon.falcon<folder>.inspect<file>.inspect_compiled_router<func>
INFO:root:****************************************

data 31:   0%|          | 0/512 [00:00<?, ?it/s]
data 31:   2%|▏         | 10/512 [01:19<1:06:45,  7.98s/it]
data 31:   4%|▍         | 20/512 [02:44<1:07:51,  8.27s/it]
data 31:   6%|▌         | 30/512 [04:10<1:07:28,  8.40s/it]
data 31:   8%|▊         | 40/512 [05:28<1:04:15,  8.17s/it]
data 31:  10%|▉         | 50/512 [06:47<1:02:08,  8.07s/it]
data 31:  12%|█▏        | 60/512 [08:07<1:00:42,  8.06s/it]
data 31:  14%|█▎        | 70/512 [09:40<1:02:24,  8.47s/it]
data 31:  16%|█▌        | 80/512 [11:17<1:03:48,  8.86s/it]
data 31:  18%|█▊        | 90/512 [12:55<1:04:14,  9.13s/it]
data 31:  18%|█▊        | 90/512 [14:02<1:05:52,  9.37s/it]
INFO:root:函数头: 
@register_router(CompiledRouter)
def inspect_compiled_router(router: CompiledRouter) -> 'List[RouteInfo]':

INFO:root:目标函数体: 
    

    def _traverse(roots, parent):
        # Omit body code

    routes = []  # type: List[RouteInfo]
    _traverse(router._roots, '')
    return routes

INFO:root:生成结果: 
    routes = []
    for route in router._routes:
        methods = []
        for method in route.methods:
            methods.append(method.upper())
        info = RouteInfo(
            route.path,
            methods,
            route.resource,
            route._options.get('tags', []),
            route._options.get('description', ''),
            route._options.get('consumes', []),
            route._options.get('produces', []),
        )
        routes.append(info)
    return routes




INFO:root:----------------------------------------
INFO:root:max length: 10130
INFO:root:max position: 11944
INFO:root:target_namespace: falcon.falcon<folder>.inspect<file>.inspect_compiled_router<func>
INFO:root:****************************************

data 31:   0%|          | 0/512 [00:00<?, ?it/s]
data 31:   2%|▏         | 10/512 [01:23<1:09:59,  8.37s/it]
data 31:   4%|▍         | 20/512 [02:49<1:09:51,  8.52s/it]
data 31:   6%|▌         | 30/512 [04:16<1:09:05,  8.60s/it]
data 31:   8%|▊         | 40/512 [05:44<1:08:18,  8.68s/it]
data 31:   8%|▊         | 40/512 [06:59<1:22:34, 10.50s/it]
INFO:root:函数头: 
@register_router(CompiledRouter)
def inspect_compiled_router(router: CompiledRouter) -> 'List[RouteInfo]':

INFO:root:目标函数体: 
    

    def _traverse(roots, parent):
        # Omit body code

    routes = []  # type: List[RouteInfo]
    _traverse(router._roots, '')
    return routes

INFO:root:生成结果: 
    routes = []
    for route in router.routes:
        methods = []
        for method in route.methods:
            methods.append(method.upper())
        info = RouteInfo(route.path, methods)
        routes.append(info)
    return routes




INFO:root:----------------------------------------
INFO:root:max length: 9545
INFO:root:max position: 12018
INFO:root:target_namespace: falcon.falcon<folder>.inspect<file>.inspect_compiled_router<func>
INFO:root:****************************************
INFO:root:已生成31条结果
INFO:root:--------data 32--------

data 32:   0%|          | 0/512 [00:00<?, ?it/s]
data 32:   2%|▏         | 10/512 [01:49<1:31:35, 10.95s/it]
data 32:   4%|▍         | 20/512 [03:41<1:30:48, 11.08s/it]
data 32:   6%|▌         | 30/512 [05:22<1:25:22, 10.63s/it]
data 32:   6%|▌         | 30/512 [05:31<1:28:46, 11.05s/it]
INFO:root:函数头: 
def _is_internal(obj):

INFO:root:目标函数体: 
    
    module = inspect.getmodule(obj)
    if module:
        return module.__name__.startswith('falcon.')
    return False

INFO:root:生成结果: 
    module = obj.__module__
    return module.startswith('falcon.') or module.startswith(' falcone.') or module.startswith(' falcone.')


INFO:root:----------------------------------------
INFO:root:max length: 9501
INFO:root:max position: 12957
INFO:root:target_namespace: falcon.falcon<folder>.inspect<file>._is_internal<func>
INFO:root:****************************************

data 32:   0%|          | 0/512 [00:00<?, ?it/s]
data 32:   2%|▏         | 10/512 [01:44<1:27:22, 10.44s/it]
data 32:   4%|▍         | 20/512 [03:36<1:29:31, 10.92s/it]
data 32:   4%|▍         | 20/512 [04:09<1:42:20, 12.48s/it]
INFO:root:函数头: 
def _is_internal(obj):

INFO:root:目标函数体: 
    
    module = inspect.getmodule(obj)
    if module:
        return module.__name__.startswith('falcon.')
    return False

INFO:root:生成结果: 
    module = getattr(obj, '__module__', None)
    return module and module.startswith('falcon')




INFO:root:----------------------------------------
INFO:root:max length: 8443
INFO:root:max position: 13109
INFO:root:target_namespace: falcon.falcon<folder>.inspect<file>._is_internal<func>
INFO:root:****************************************

data 32:   0%|          | 0/512 [00:00<?, ?it/s]
data 32:   2%|▏         | 10/512 [01:48<1:30:34, 10.82s/it]
data 32:   4%|▍         | 20/512 [03:38<1:29:57, 10.97s/it]
data 32:   6%|▌         | 30/512 [05:19<1:24:45, 10.55s/it]
data 32:   8%|▊         | 40/512 [07:09<1:24:21, 10.72s/it]
data 32:  10%|▉         | 50/512 [09:03<1:24:31, 10.98s/it]
data 32:  12%|█▏        | 60/512 [10:56<1:23:30, 11.09s/it]
data 32:  14%|█▎        | 70/512 [12:57<1:24:05, 11.42s/it]
data 32:  16%|█▌        | 80/512 [14:53<1:22:31, 11.46s/it]
data 32:  18%|█▊        | 90/512 [16:48<1:20:48, 11.49s/it]
data 32:  20%|█▉        | 100/512 [18:40<1:18:14, 11.39s/it]
data 32:  21%|██▏       | 110/512 [20:27<1:14:53, 11.18s/it]
data 32:  23%|██▎       | 120/512 [22:14<1:12:08, 11.04s/it]
data 32:  25%|██▌       | 130/512 [24:03<1:09:57, 10.99s/it]
data 32:  27%|██▋       | 140/512 [26:04<1:10:13, 11.33s/it]
data 32:  29%|██▉       | 150/512 [28:02<1:09:17, 11.49s/it]
data 32:  31%|███▏      | 160/512 [30:01<1:08:04, 11.60s/it]
data 32:  33%|███▎      | 170/512 [32:02<1:07:01, 11.76s/it]
data 32:  35%|███▌      | 180/512 [33:58<1:04:45, 11.70s/it]
data 32:  37%|███▋      | 190/512 [35:52<1:02:19, 11.61s/it]
data 32:  39%|███▉      | 200/512 [37:42<59:26, 11.43s/it]  
data 32:  41%|████      | 210/512 [39:36<57:26, 11.41s/it]
data 32:  43%|████▎     | 220/512 [41:20<54:02, 11.10s/it]
data 32:  45%|████▍     | 230/512 [43:11<52:16, 11.12s/it]
data 32:  47%|████▋     | 240/512 [45:00<50:00, 11.03s/it]
data 32:  49%|████▉     | 250/512 [46:46<47:40, 10.92s/it]
data 32:  51%|█████     | 260/512 [48:36<45:58, 10.95s/it]
data 32:  53%|█████▎    | 270/512 [50:22<43:38, 10.82s/it]
data 32:  55%|█████▍    | 280/512 [52:08<41:38, 10.77s/it]
data 32:  57%|█████▋    | 290/512 [53:59<40:14, 10.87s/it]
data 32:  59%|█████▊    | 300/512 [55:53<38:56, 11.02s/it]
data 32:  61%|██████    | 310/512 [57:39<36:42, 10.90s/it]
data 32:  62%|██████▎   | 320/512 [59:27<34:44, 10.86s/it]
data 32:  64%|██████▍   | 330/512 [1:01:06<32:07, 10.59s/it]
data 32:  66%|██████▋   | 340/512 [1:02:53<30:26, 10.62s/it]
data 32:  68%|██████▊   | 350/512 [1:04:43<28:57, 10.72s/it]
data 32:  70%|███████   | 360/512 [1:08:28<36:09, 14.27s/it]
data 32:  72%|███████▏  | 370/512 [1:10:20<31:32, 13.33s/it]
data 32:  74%|███████▍  | 380/512 [1:12:04<27:23, 12.45s/it]
data 32:  76%|███████▌  | 390/512 [1:13:57<24:37, 12.11s/it]
data 32:  78%|███████▊  | 400/512 [1:15:46<21:57, 11.77s/it]
data 32:  80%|████████  | 410/512 [1:17:35<19:31, 11.48s/it]
data 32:  82%|████████▏ | 420/512 [1:19:24<17:22, 11.33s/it]
data 32:  84%|████████▍ | 430/512 [1:21:10<15:08, 11.08s/it]
data 32:  86%|████████▌ | 440/512 [1:23:03<13:23, 11.15s/it]
data 32:  88%|████████▊ | 450/512 [1:24:47<11:17, 10.93s/it]
data 32:  90%|████████▉ | 460/512 [1:26:36<09:27, 10.92s/it]
data 32:  92%|█████████▏| 470/512 [1:28:35<07:51, 11.23s/it]
data 32:  94%|█████████▍| 480/512 [1:30:32<06:03, 11.37s/it]
data 32:  96%|█████████▌| 490/512 [1:32:37<04:17, 11.69s/it]
data 32:  98%|█████████▊| 500/512 [1:34:40<02:22, 11.87s/it]
data 32: 100%|█████████▉| 510/512 [1:36:57<00:24, 12.44s/it]
data 32: 100%|█████████▉| 510/512 [1:37:33<00:22, 11.48s/it]
INFO:root:函数头: 
def _is_internal(obj):

INFO:root:目标函数体: 
    
    module = inspect.getmodule(obj)
    if module:
        return module.__name__.startswith('falcon.')
    return False

INFO:root:生成结果: 
    module = obj.__module__
    return module.startswith('falcon') or module.startswith('falcon.') or module.startswith('falcon.') or module.startswith('falcon.') or module.startswith('falcon.') or module.startswith('falcon.') or module.startswith('falcon.') or module.startswith('falcon.') or module.startswith('falcon.') or module.startswith('falcon.') or module.startswith('falcon.') or module.startswith('falcon.') or module.startswith('falcon.') or module.startswith('falcon.') or module.startswith('falcon.') or module.startswith('falcon.') or module.startswith('falcon.') or module.startswith('falcon.') or module.startswith('falcon.') or module.startswith('falcon.') or module.startswith('falcon.') or module.startswith('falcon.') or module.startswith('falcon.') or module.startswith('falcon.') or module.startswith('falcon.') or module.startswith('falcon.') or module.startswith('falcon.') or module.startswith('falcon.') or module.startswith('falcon.') or module.startswith('falcon.') or module.startswith('falcon.') or module.startswith('falcon.') or module.startswith('falcon.') or module.startswith('falcon.') or module.startswith('falcon.') or module.startswith('falcon.') or module.startswith('falcon.') or module.startswith('falcon.') or module.startswith('falcon.') or module.startswith('falcon.') or module.startswith('falcon.') or module.startswith('falcon.') or module.startswith('falcon.') or module.startswith('falcon.') or module.startswith('falcon.') or module.startswith('falcon.') or module.startswith('falcon.') or module.startswith('falcon.') or module.startswith('falcon.') or module.startswith('falcon.') or module.startswith('falcon.') or module.startswith('falcon.') or module.startswith('falcon.') or module.startswith('falcon.') or module.startswith('falcon.') or module.startswith('falcon.') or module.startswith('falcon.') or module.startswith('falcon.') or module.startswith('falcon.') or module.startswith('falcon.') or module.startswith('falcon.') or module.startswith('falcon.') or module.startswith('falcon.') or module.startswith('falcon.') or module.startswith('falcon.') or module.startswith('falcon.') or module.startswith('falcon.') or module.startswith('falcon.') or module.startswith('falcon.') or module.startswith('falcon.') or module.startswith('falcon.') or module.startswith('falcon.')

INFO:root:----------------------------------------
INFO:root:max length: 10927
INFO:root:max position: 13723
INFO:root:target_namespace: falcon.falcon<folder>.inspect<file>._is_internal<func>
INFO:root:****************************************

data 32:   0%|          | 0/512 [00:00<?, ?it/s]
data 32:   2%|▏         | 10/512 [01:50<1:32:21, 11.04s/it]
data 32:   4%|▍         | 20/512 [03:44<1:32:20, 11.26s/it]
data 32:   6%|▌         | 30/512 [05:27<1:27:01, 10.83s/it]
data 32:   8%|▊         | 40/512 [07:22<1:27:14, 11.09s/it]
data 32:  10%|▉         | 50/512 [09:15<1:25:57, 11.16s/it]
data 32:  12%|█▏        | 60/512 [11:12<1:25:27, 11.34s/it]
data 32:  14%|█▎        | 70/512 [13:10<1:24:33, 11.48s/it]
data 32:  16%|█▌        | 80/512 [14:59<1:21:22, 11.30s/it]
data 32:  18%|█▊        | 90/512 [17:00<1:21:15, 11.55s/it]
data 32:  20%|█▉        | 100/512 [18:53<1:18:43, 11.46s/it]
data 32:  21%|██▏       | 110/512 [20:44<1:16:15, 11.38s/it]
data 32:  23%|██▎       | 120/512 [22:40<1:14:37, 11.42s/it]
data 32:  25%|██▌       | 130/512 [24:30<1:11:56, 11.30s/it]
data 32:  27%|██▋       | 140/512 [26:23<1:10:02, 11.30s/it]
data 32:  29%|██▉       | 150/512 [28:21<1:09:03, 11.45s/it]
data 32:  31%|███▏      | 160/512 [30:19<1:07:48, 11.56s/it]
data 32:  33%|███▎      | 170/512 [32:15<1:05:57, 11.57s/it]
data 32:  35%|███▌      | 180/512 [34:16<1:04:59, 11.75s/it]
data 32:  37%|███▋      | 190/512 [36:12<1:02:46, 11.70s/it]
data 32:  39%|███▉      | 200/512 [38:07<1:00:28, 11.63s/it]
data 32:  41%|████      | 210/512 [40:07<59:03, 11.73s/it]  
data 32:  43%|████▎     | 220/512 [42:00<56:29, 11.61s/it]
data 32:  45%|████▍     | 230/512 [43:53<54:06, 11.51s/it]
data 32:  47%|████▋     | 240/512 [45:43<51:35, 11.38s/it]
data 32:  49%|████▉     | 250/512 [47:38<49:46, 11.40s/it]
data 32:  51%|█████     | 260/512 [49:30<47:37, 11.34s/it]
data 32:  53%|█████▎    | 270/512 [51:22<45:37, 11.31s/it]
data 32:  55%|█████▍    | 280/512 [53:13<43:26, 11.23s/it]
data 32:  57%|█████▋    | 290/512 [54:59<40:50, 11.04s/it]
data 32:  59%|█████▊    | 300/512 [56:47<38:47, 10.98s/it]
data 32:  61%|██████    | 310/512 [58:30<36:15, 10.77s/it]
data 32:  62%|██████▎   | 320/512 [1:00:18<34:28, 10.77s/it]
data 32:  64%|██████▍   | 330/512 [1:01:59<32:04, 10.57s/it]
data 32:  66%|██████▋   | 340/512 [1:03:46<30:25, 10.61s/it]
data 32:  68%|██████▊   | 350/512 [1:05:31<28:36, 10.60s/it]
data 32:  70%|███████   | 360/512 [1:07:13<26:31, 10.47s/it]
data 32:  72%|███████▏  | 370/512 [1:09:03<25:10, 10.64s/it]
data 32:  74%|███████▍  | 380/512 [1:10:43<22:55, 10.42s/it]
data 32:  76%|███████▌  | 390/512 [1:12:28<21:14, 10.45s/it]
data 32:  78%|███████▊  | 400/512 [1:14:12<19:28, 10.44s/it]
data 32:  80%|████████  | 410/512 [1:15:55<17:40, 10.40s/it]
data 32:  82%|████████▏ | 420/512 [1:17:39<15:55, 10.39s/it]
data 32:  84%|████████▍ | 430/512 [1:19:20<14:06, 10.32s/it]
data 32:  86%|████████▌ | 440/512 [1:21:14<12:46, 10.65s/it]
data 32:  88%|████████▊ | 450/512 [1:22:56<10:51, 10.50s/it]
data 32:  90%|████████▉ | 460/512 [1:26:44<12:17, 14.18s/it]
data 32:  92%|█████████▏| 470/512 [1:28:30<09:11, 13.12s/it]
data 32:  94%|█████████▍| 480/512 [1:30:28<06:47, 12.72s/it]
data 32:  96%|█████████▌| 490/512 [1:32:35<04:39, 12.71s/it]
data 32:  98%|█████████▊| 500/512 [1:34:35<02:30, 12.52s/it]
data 32: 100%|█████████▉| 510/512 [1:36:46<00:25, 12.68s/it]
data 32: 100%|█████████▉| 510/512 [1:37:23<00:22, 11.46s/it]
INFO:root:函数头: 
def _is_internal(obj):

INFO:root:目标函数体: 
    
    module = inspect.getmodule(obj)
    if module:
        return module.__name__.startswith('falcon.')
    return False

INFO:root:生成结果: 
    module = obj.__module__
    return module.startswith('falcon.') or module.startswith('falcon.') or module.startswith('falcon.') or module.startswith('falcon.') or module.startswith('falcon.') or module.startswith('falcon.') or module.startswith('falcon.') or module.startswith('falcon.') or module.startswith('falcon.') or module.startswith('falcon.') or module.startswith('falcon.') or module.startswith('falcon.') or module.startswith('falcon.') or module.startswith('falcon.') or module.startswith('falcon.') or module.startswith('falcon.') or module.startswith('falcon.') or module.startswith('falcon.') or module.startswith('falcon.') or module.startswith('falcon.') or module.startswith('falcon.') or module.startswith('falcon.') or module.startswith('falcon.') or module.startswith('falcon.') or module.startswith('falcon.') or module.startswith('falcon.') or module.startswith('falcon.') or module.startswith('falcon.') or module.startswith('falcon.') or module.startswith('falcon.') or module.startswith('falcon.') or module.startswith('falcon.') or module.startswith('falcon.') or module.startswith('falcon.') or module.startswith('falcon.') or module.startswith('falcon.') or module.startswith('falcon.') or module.startswith('falcon.') or module.startswith('falcon.') or module.startswith('falcon.') or module.startswith('falcon.') or module.startswith('falcon.') or module.startswith('falcon.') or module.startswith('falcon.') or module.startswith('falcon.') or module.startswith('falcon.') or module.startswith('falcon.') or module.startswith('falcon.') or module.startswith('falcon.') or module.startswith('falcon.') or module.startswith('falcon.') or module.startswith('falcon.') or module.startswith('falcon.') or module.startswith('falcon.') or module.startswith('falcon.') or module.startswith('falcon.') or module.startswith('falcon.') or module.startswith('falcon.') or module.startswith('falcon.') or module.startswith('falcon.') or module.startswith('falcon.') or module.startswith('falcon.') or module.startswith('falcon.') or module.startswith('falcon.') or module.startswith('falcon.') or module.startswith('falcon.') or module.startswith('falcon.') or module.startswith('falcon.') or module.startswith('falcon.') or module.startswith('falcon.') or module.startswith('falcon.') or module.startswith('falcon.')

INFO:root:----------------------------------------
INFO:root:max length: 10849
INFO:root:max position: 14052
INFO:root:target_namespace: falcon.falcon<folder>.inspect<file>._is_internal<func>
INFO:root:****************************************

data 32:   0%|          | 0/512 [00:00<?, ?it/s]
data 32:   2%|▏         | 10/512 [01:42<1:25:28, 10.22s/it]
data 32:   4%|▍         | 20/512 [03:35<1:29:07, 10.87s/it]
data 32:   6%|▌         | 30/512 [06:20<1:47:50, 13.42s/it]
data 32:   8%|▊         | 40/512 [08:12<1:38:52, 12.57s/it]
data 32:  10%|▉         | 50/512 [10:09<1:34:16, 12.24s/it]
data 32:  12%|█▏        | 60/512 [12:11<1:32:13, 12.24s/it]
data 32:  14%|█▎        | 70/512 [14:05<1:28:03, 11.95s/it]
data 32:  16%|█▌        | 80/512 [15:58<1:24:39, 11.76s/it]
data 32:  18%|█▊        | 90/512 [18:00<1:23:32, 11.88s/it]
data 32:  20%|█▉        | 100/512 [19:57<1:21:15, 11.83s/it]
data 32:  21%|██▏       | 110/512 [21:50<1:18:16, 11.68s/it]
data 32:  23%|██▎       | 120/512 [23:39<1:14:37, 11.42s/it]
data 32:  25%|██▌       | 130/512 [25:33<1:12:45, 11.43s/it]
data 32:  27%|██▋       | 140/512 [27:42<1:13:30, 11.86s/it]
data 32:  29%|██▉       | 150/512 [29:50<1:13:24, 12.17s/it]
data 32:  31%|███▏      | 160/512 [32:02<1:13:07, 12.46s/it]
data 32:  33%|███▎      | 170/512 [34:21<1:13:28, 12.89s/it]
data 32:  35%|███▌      | 180/512 [36:38<1:12:42, 13.14s/it]
data 32:  37%|███▋      | 190/512 [38:52<1:11:00, 13.23s/it]
data 32:  39%|███▉      | 200/512 [40:59<1:07:53, 13.06s/it]
data 32:  41%|████      | 210/512 [43:09<1:05:37, 13.04s/it]
data 32:  43%|████▎     | 220/512 [45:11<1:02:18, 12.80s/it]
data 32:  45%|████▍     | 230/512 [47:13<59:13, 12.60s/it]  
data 32:  47%|████▋     | 240/512 [49:04<55:06, 12.15s/it]
data 32:  49%|████▉     | 250/512 [50:54<51:37, 11.82s/it]
data 32:  51%|█████     | 260/512 [52:44<48:36, 11.57s/it]
data 32:  53%|█████▎    | 270/512 [54:31<45:36, 11.31s/it]
data 32:  55%|█████▍    | 280/512 [56:19<43:04, 11.14s/it]
data 32:  57%|█████▋    | 290/512 [58:07<40:53, 11.05s/it]
data 32:  59%|█████▊    | 300/512 [59:56<38:55, 11.01s/it]
data 32:  61%|██████    | 310/512 [1:01:41<36:32, 10.86s/it]
data 32:  62%|██████▎   | 320/512 [1:03:33<35:04, 10.96s/it]
data 32:  64%|██████▍   | 330/512 [1:05:19<32:55, 10.85s/it]
data 32:  66%|██████▋   | 340/512 [1:07:06<30:59, 10.81s/it]
data 32:  68%|██████▊   | 350/512 [1:08:53<29:05, 10.78s/it]
data 32:  70%|███████   | 360/512 [1:10:39<27:06, 10.70s/it]
data 32:  72%|███████▏  | 370/512 [1:12:28<25:29, 10.77s/it]
data 32:  74%|███████▍  | 380/512 [1:14:14<23:33, 10.71s/it]
data 32:  76%|███████▌  | 390/512 [1:16:08<22:12, 10.93s/it]
data 32:  78%|███████▊  | 400/512 [1:17:52<20:06, 10.77s/it]
data 32:  80%|████████  | 410/512 [1:19:41<18:23, 10.82s/it]
data 32:  82%|████████▏ | 420/512 [1:21:30<16:35, 10.82s/it]
data 32:  84%|████████▍ | 430/512 [1:23:16<14:43, 10.78s/it]
data 32:  86%|████████▌ | 440/512 [1:25:14<13:17, 11.07s/it]
data 32:  88%|████████▊ | 450/512 [1:27:00<11:18, 10.94s/it]
data 32:  90%|████████▉ | 460/512 [1:28:49<09:28, 10.93s/it]
data 32:  92%|█████████▏| 470/512 [1:32:45<10:17, 14.71s/it]
data 32:  94%|█████████▍| 480/512 [1:34:50<07:30, 14.06s/it]
data 32:  96%|█████████▌| 490/512 [1:37:00<05:02, 13.75s/it]
data 32:  98%|█████████▊| 500/512 [1:39:11<02:42, 13.54s/it]
data 32: 100%|█████████▉| 510/512 [1:41:25<00:26, 13.50s/it]
data 32: 100%|█████████▉| 510/512 [1:43:59<00:24, 12.23s/it]
INFO:root:函数头: 
def _is_internal(obj):

INFO:root:目标函数体: 
    
    module = inspect.getmodule(obj)
    if module:
        return module.__name__.startswith('falcon.')
    return False

INFO:root:生成结果: 
    module = obj.__module__
    return module.startswith('falcon.') or module.startswith('falcon.') or module.startswith('falcon.') or module.startswith('falcon.') or module.startswith('falcon.') or module.startswith('falcon.') or module.startswith('falcon.') or module.startswith('falcon.') or module.startswith('falcon.') or module.startswith('falcon.') or module.startswith('falcon.') or module.startswith('falcon.') or module.startswith('falcon.') or module.startswith('falcon.') or module.startswith('falcon.') or module.startswith('falcon.') or module.startswith('falcon.') or module.startswith('falcon.') or module.startswith('falcon.') or module.startswith('falcon.') or module.startswith('falcon.') or module.startswith('falcon.') or module.startswith('falcon.') or module.startswith('falcon.') or module.startswith('falcon.') or module.startswith('falcon.') or module.startswith('falcon.') or module.startswith('falcon.') or module.startswith('falcon.') or module.startswith('falcon.') or module.startswith('falcon.') or module.startswith('falcon.') or module.startswith('falcon.') or module.startswith('falcon.') or module.startswith('falcon.') or module.startswith('falcon.') or module.startswith('falcon.') or module.startswith('falcon.') or module.startswith('falcon.') or module.startswith('falcon.') or module.startswith('falcon.') or module.startswith('falcon.') or module.startswith('falcon.') or module.startswith('falcon.') or module.startswith('falcon.') or module.startswith('falcon.') or module.startswith('falcon.') or module.startswith('falcon.') or module.startswith('falcon.') or module.startswith('falcon.') or module.startswith('falcon.') or module.startswith('falcon.') or module.startswith('falcon.') or module.startswith('falcon.') or module.startswith('falcon.') or module.startswith('falcon.') or module.startswith('falcon.') or module.startswith('falcon.') or module.startswith('falcon.') or module.startswith('falcon.') or module.startswith('falcon.') or module.startswith('falcon.') or module.startswith('falcon.') or module.startswith('falcon.') or module.startswith('falcon.') or module.startswith('falcon.') or module.startswith('falcon.') or module.startswith('falcon.') or module.startswith('falcon.') or module.startswith('falcon.') or module.startswith('falcon.') or module.startswith('falcon.')

INFO:root:----------------------------------------
INFO:root:max length: 10693
INFO:root:max position: 13929
INFO:root:target_namespace: falcon.falcon<folder>.inspect<file>._is_internal<func>
INFO:root:****************************************
INFO:root:--------data 33--------

data 33:   0%|          | 0/512 [00:00<?, ?it/s]
data 33:   2%|▏         | 10/512 [01:40<1:24:02, 10.05s/it]
data 33:   4%|▍         | 20/512 [03:21<1:22:37, 10.08s/it]
data 33:   6%|▌         | 30/512 [04:58<1:19:45,  9.93s/it]
data 33:   8%|▊         | 40/512 [06:41<1:19:02, 10.05s/it]
data 33:  10%|▉         | 50/512 [08:33<1:20:40, 10.48s/it]
data 33:  12%|█▏        | 60/512 [10:23<1:20:13, 10.65s/it]
data 33:  14%|█▎        | 70/512 [11:59<1:15:57, 10.31s/it]
data 33:  16%|█▌        | 80/512 [22:37<3:16:54, 27.35s/it]
data 33:  18%|█▊        | 90/512 [24:19<2:34:26, 21.96s/it]
data 33:  20%|█▉        | 100/512 [25:51<2:03:45, 18.02s/it]
data 33:  20%|█▉        | 100/512 [26:53<1:50:48, 16.14s/it]
INFO:root:函数头: 
def load_app(parser, args):


INFO:root:目标函数体: 
    try:
        module, instance = args.app_module.split(':', 1)
    except ValueError:
        parser.error(
            'The app_module must include a colon between the module and instance'
        )
    try:
        app = getattr(importlib.import_module(module), instance)
    except AttributeError:
        parser.error('{!r} not found in module {!r}'.format(instance, module))

    if not isinstance(app, falcon.App):
        if callable(app):
            app = app()
            if not isinstance(app, falcon.App):
                parser.error(
                    '{} did not return a falcon.App instance'.format(args.app_module)
                )
        else:
            parser.error(
                'The instance must be of falcon.App or be '
                'a callable without args that returns falcon.App'
            )
    return app

INFO:root:生成结果: 
    try:
        module_name, app_name = args.app_module.split(':')
        module = importlib.import_module(module_name)
        app_instance = getattr(module, app_name)
    except (ImportError, AttributeError):
        try:
            app_instance = args.app_module()
        except Exception as e:
            parser.error(f'Could not load app: {e}')
    if not isinstance(app_instance, falcon.App):
        parser.error('App must be an instance of falcon.App')
    return app_instance




INFO:root:----------------------------------------
INFO:root:max length: 8727
INFO:root:max position: 11830
INFO:root:target_namespace: falcon.falcon<folder>.cmd<folder>.inspect_app<file>.load_app<func>
INFO:root:****************************************

data 33:   0%|          | 0/512 [00:00<?, ?it/s]
data 33:   2%|▏         | 10/512 [01:30<1:15:54,  9.07s/it]
data 33:   4%|▍         | 20/512 [09:51<4:32:20, 33.21s/it]
data 33:   6%|▌         | 30/512 [11:30<3:01:11, 22.55s/it]
data 33:   8%|▊         | 40/512 [16:11<3:14:34, 24.73s/it]
data 33:  10%|▉         | 50/512 [17:55<2:30:44, 19.58s/it]
data 33:  12%|█▏        | 60/512 [20:50<2:22:08, 18.87s/it]
data 33:  14%|█▎        | 70/512 [22:25<1:56:25, 15.80s/it]
data 33:  16%|█▌        | 80/512 [25:03<1:53:51, 15.81s/it]
data 33:  18%|█▊        | 90/512 [32:50<2:59:09, 25.47s/it]
data 33:  20%|█▉        | 100/512 [34:26<2:21:07, 20.55s/it]
data 33:  20%|█▉        | 100/512 [35:45<2:27:20, 21.46s/it]
INFO:root:函数头: 
def load_app(parser, args):


INFO:root:目标函数体: 
    try:
        module, instance = args.app_module.split(':', 1)
    except ValueError:
        parser.error(
            'The app_module must include a colon between the module and instance'
        )
    try:
        app = getattr(importlib.import_module(module), instance)
    except AttributeError:
        parser.error('{!r} not found in module {!r}'.format(instance, module))

    if not isinstance(app, falcon.App):
        if callable(app):
            app = app()
            if not isinstance(app, falcon.App):
                parser.error(
                    '{} did not return a falcon.App instance'.format(args.app_module)
                )
        else:
            parser.error(
                'The instance must be of falcon.App or be '
                'a callable without args that returns falcon.App'
            )
    return app

INFO:root:生成结果: 
    try:
        module_name, app_name = args.app_module.split(':')
        module = importlib.import_module(module_name)
        app_instance = getattr(module, app_name)
    except (ImportError, AttributeError):
        try:
            app_instance = args.app_module()
        except Exception as e:
            parser.error(f'Failed to load app: {e}')
    if not isinstance(app_instance, falcon.App):
        parser.error('The loaded app is not an instance of falcon.App')
    return app_instance




INFO:root:----------------------------------------
INFO:root:max length: 8401
INFO:root:max position: 11708
INFO:root:target_namespace: falcon.falcon<folder>.cmd<folder>.inspect_app<file>.load_app<func>
INFO:root:****************************************

data 33:   0%|          | 0/512 [00:00<?, ?it/s]
data 33:   2%|▏         | 10/512 [01:30<1:15:46,  9.06s/it]
data 33:   4%|▍         | 20/512 [03:10<1:18:44,  9.60s/it]
data 33:   6%|▌         | 30/512 [04:54<1:20:03,  9.97s/it]
data 33:   8%|▊         | 40/512 [06:50<1:23:28, 10.61s/it]
data 33:  10%|▉         | 50/512 [11:24<2:08:28, 16.68s/it]
data 33:  12%|█▏        | 60/512 [13:26<1:54:07, 15.15s/it]
data 33:  14%|█▎        | 70/512 [15:20<1:42:30, 13.92s/it]
data 33:  16%|█▌        | 80/512 [16:59<1:31:03, 12.65s/it]
data 33:  16%|█▌        | 80/512 [17:23<1:33:52, 13.04s/it]
INFO:root:函数头: 
def load_app(parser, args):


INFO:root:目标函数体: 
    try:
        module, instance = args.app_module.split(':', 1)
    except ValueError:
        parser.error(
            'The app_module must include a colon between the module and instance'
        )
    try:
        app = getattr(importlib.import_module(module), instance)
    except AttributeError:
        parser.error('{!r} not found in module {!r}'.format(instance, module))

    if not isinstance(app, falcon.App):
        if callable(app):
            app = app()
            if not isinstance(app, falcon.App):
                parser.error(
                    '{} did not return a falcon.App instance'.format(args.app_module)
                )
        else:
            parser.error(
                'The instance must be of falcon.App or be '
                'a callable without args that returns falcon.App'
            )
    return app

INFO:root:生成结果: 
    import falcon

    module_name, instance_name = args.app_module.split(':')
    module = importlib.import_module(module_name)
    app = getattr(module, instance_name)

    if not isinstance(app, falcon.App):
        if callable(app):
            app = app()
        else:
            raise ValueError(f'Expected a Falcon app instance or a callable returning one.')

    return app




INFO:root:----------------------------------------
INFO:root:max length: 8678
INFO:root:max position: 12227
INFO:root:target_namespace: falcon.falcon<folder>.cmd<folder>.inspect_app<file>.load_app<func>
INFO:root:****************************************

data 33:   0%|          | 0/512 [00:00<?, ?it/s]
data 33:   2%|▏         | 10/512 [01:48<1:30:55, 10.87s/it]
data 33:   4%|▍         | 20/512 [03:40<1:30:42, 11.06s/it]
data 33:   6%|▌         | 30/512 [05:34<1:30:09, 11.22s/it]
data 33:   8%|▊         | 40/512 [07:30<1:29:28, 11.37s/it]
data 33:  10%|▉         | 50/512 [09:24<1:27:36, 11.38s/it]
data 33:  12%|█▏        | 60/512 [11:27<1:28:07, 11.70s/it]
data 33:  14%|█▎        | 70/512 [13:18<1:24:41, 11.50s/it]
data 33:  16%|█▌        | 80/512 [15:02<1:20:08, 11.13s/it]
data 33:  18%|█▊        | 90/512 [17:02<1:20:12, 11.40s/it]
data 33:  20%|█▉        | 100/512 [19:08<1:20:51, 11.78s/it]
data 33:  21%|██▏       | 110/512 [21:00<1:17:47, 11.61s/it]
data 33:  23%|██▎       | 120/512 [22:44<1:13:20, 11.23s/it]
data 33:  23%|██▎       | 120/512 [23:41<1:17:25, 11.85s/it]
INFO:root:函数头: 
def load_app(parser, args):


INFO:root:目标函数体: 
    try:
        module, instance = args.app_module.split(':', 1)
    except ValueError:
        parser.error(
            'The app_module must include a colon between the module and instance'
        )
    try:
        app = getattr(importlib.import_module(module), instance)
    except AttributeError:
        parser.error('{!r} not found in module {!r}'.format(instance, module))

    if not isinstance(app, falcon.App):
        if callable(app):
            app = app()
            if not isinstance(app, falcon.App):
                parser.error(
                    '{} did not return a falcon.App instance'.format(args.app_module)
                )
        else:
            parser.error(
                'The instance must be of falcon.App or be '
                'a callable without args that returns falcon.App'
            )
    return app

INFO:root:生成结果: 
    try:
        module_name, app_name = args.app_module.split(':')
        module = importlib.import_module(module_name)
        app_instance = getattr(module, app_name)
    except ImportError:
        parser.error(f'Module "{module_name}" not found')
    except AttributeError:
        parser.error(f'Module "{module_name}" does not contain an attribute "{app_name}"')
    if not isinstance(app_instance, falcon.App):
        try:
            app_instance = app_instance()
        except Exception as e:
            parser.error(f'Failed to create app instance: {e}')
    return app_instance




INFO:root:----------------------------------------
INFO:root:max length: 9032
INFO:root:max position: 12896
INFO:root:target_namespace: falcon.falcon<folder>.cmd<folder>.inspect_app<file>.load_app<func>
INFO:root:****************************************

data 33:   0%|          | 0/512 [00:00<?, ?it/s]
data 33:   2%|▏         | 10/512 [01:43<1:26:26, 10.33s/it]
data 33:   4%|▍         | 20/512 [03:40<1:31:10, 11.12s/it]
data 33:   6%|▌         | 30/512 [05:31<1:29:16, 11.11s/it]
data 33:   8%|▊         | 40/512 [07:28<1:29:14, 11.34s/it]
data 33:  10%|▉         | 50/512 [09:19<1:26:42, 11.26s/it]
data 33:  12%|█▏        | 60/512 [11:14<1:25:33, 11.36s/it]
data 33:  14%|█▎        | 70/512 [15:04<1:51:36, 15.15s/it]
data 33:  16%|█▌        | 80/512 [16:39<1:36:16, 13.37s/it]
data 33:  18%|█▊        | 90/512 [18:24<1:27:40, 12.47s/it]
data 33:  20%|█▉        | 100/512 [20:18<1:23:18, 12.13s/it]
data 33:  21%|██▏       | 110/512 [21:59<1:17:07, 11.51s/it]
data 33:  23%|██▎       | 120/512 [23:38<1:12:01, 11.03s/it]
data 33:  23%|██▎       | 120/512 [24:10<1:18:57, 12.08s/it]
INFO:root:函数头: 
def load_app(parser, args):


INFO:root:目标函数体: 
    try:
        module, instance = args.app_module.split(':', 1)
    except ValueError:
        parser.error(
            'The app_module must include a colon between the module and instance'
        )
    try:
        app = getattr(importlib.import_module(module), instance)
    except AttributeError:
        parser.error('{!r} not found in module {!r}'.format(instance, module))

    if not isinstance(app, falcon.App):
        if callable(app):
            app = app()
            if not isinstance(app, falcon.App):
                parser.error(
                    '{} did not return a falcon.App instance'.format(args.app_module)
                )
        else:
            parser.error(
                'The instance must be of falcon.App or be '
                'a callable without args that returns falcon.App'
            )
    return app

INFO:root:生成结果: 
    try:
        module_name, app_name = args.app_module.split(':')
        module = importlib.import_module(module_name)
        app_instance = getattr(module, app_name)
    except ImportError:
        parser.error(f'Module "{module_name}" not found')
    except AttributeError:
        parser.error(f'Attribute "{app_name}" not found in module "{module_name}"')

    if not isinstance(app_instance, falcon.App):
        try:
            app_instance = app_instance()
        except Exception as e:
            parser.error(f'Error creating app instance: {e}')

    return app_instance




INFO:root:----------------------------------------
INFO:root:max length: 8769
INFO:root:max position: 11964
INFO:root:target_namespace: falcon.falcon<folder>.cmd<folder>.inspect_app<file>.load_app<func>
INFO:root:****************************************
INFO:root:--------data 34--------

data 34:   0%|          | 0/512 [00:00<?, ?it/s]
data 34:   2%|▏         | 10/512 [01:34<1:19:14,  9.47s/it]
data 34:   4%|▍         | 20/512 [03:14<1:20:20,  9.80s/it]
data 34:   6%|▌         | 30/512 [04:47<1:16:34,  9.53s/it]
data 34:   8%|▊         | 40/512 [06:22<1:14:57,  9.53s/it]
data 34:  10%|▉         | 50/512 [07:56<1:13:06,  9.49s/it]
data 34:  12%|█▏        | 60/512 [09:35<1:12:25,  9.61s/it]
data 34:  14%|█▎        | 70/512 [11:10<1:10:33,  9.58s/it]
data 34:  16%|█▌        | 80/512 [12:40<1:07:36,  9.39s/it]
data 34:  18%|█▊        | 90/512 [14:16<1:06:35,  9.47s/it]
data 34:  18%|█▊        | 90/512 [15:36<1:13:11, 10.41s/it]
INFO:root:函数头: 
def make_parser():

INFO:root:目标函数体: 
    
    parser = argparse.ArgumentParser(
        description='Example: falcon-inspect-app myprogram:app'
    )
    parser.add_argument(
        '-r',
        '--route_only',
        action='store_true',
        help='Prints only the information regarding the routes',
    )
    parser.add_argument(
        '-v',
        '--verbose',
        action='store_true',
        help='More verbose output',
    )
    parser.add_argument(
        '-i',
        '--internal',
        action='store_true',
        help='Print also internal falcon route methods and error handlers',
    )
    parser.add_argument(
        'app_module',
        help='The module and app to inspect. Example: myapp.somemodule:api',
    )
    return parser

INFO:root:生成结果: 
    parser = argparse.ArgumentParser(description='Inspect Falcon application')

    parser.add_argument('-r', '--router', action='store_true', help='Inspect the router')
    parser.add_argument('-v', '--verbose', action='store_true', help='Enable verbose mode')
    parser.add_argument('-i', '--internal', action='store_true', help='Inspect the internal routes')
    parser.add_argument('app_module', help='The module containing the Falcon application')

    return parser




INFO:root:----------------------------------------
INFO:root:max length: 8347
INFO:root:max position: 11898
INFO:root:target_namespace: falcon.falcon<folder>.cmd<folder>.inspect_app<file>.make_parser<func>
INFO:root:****************************************

data 34:   0%|          | 0/512 [00:00<?, ?it/s]
data 34:   2%|▏         | 10/512 [01:34<1:19:01,  9.45s/it]
data 34:   4%|▍         | 20/512 [03:14<1:20:16,  9.79s/it]
data 34:   6%|▌         | 30/512 [04:47<1:16:54,  9.57s/it]
data 34:   8%|▊         | 40/512 [06:21<1:14:31,  9.47s/it]
data 34:  10%|▉         | 50/512 [07:56<1:13:06,  9.49s/it]
data 34:  12%|█▏        | 60/512 [09:34<1:12:18,  9.60s/it]
data 34:  14%|█▎        | 70/512 [11:04<1:09:20,  9.41s/it]
data 34:  16%|█▌        | 80/512 [12:39<1:07:49,  9.42s/it]
data 34:  18%|█▊        | 90/512 [14:08<1:05:18,  9.29s/it]
data 34:  18%|█▊        | 90/512 [14:51<1:09:40,  9.91s/it]
INFO:root:函数头: 
def make_parser():

INFO:root:目标函数体: 
    
    parser = argparse.ArgumentParser(
        description='Example: falcon-inspect-app myprogram:app'
    )
    parser.add_argument(
        '-r',
        '--route_only',
        action='store_true',
        help='Prints only the information regarding the routes',
    )
    parser.add_argument(
        '-v',
        '--verbose',
        action='store_true',
        help='More verbose output',
    )
    parser.add_argument(
        '-i',
        '--internal',
        action='store_true',
        help='Print also internal falcon route methods and error handlers',
    )
    parser.add_argument(
        'app_module',
        help='The module and app to inspect. Example: myapp.somemodule:api',
    )
    return parser

INFO:root:生成结果: 
    parser = argparse.ArgumentParser(description='Inspect Falcon application')
    parser.add_argument('-r', '--router', help='Specify the router to inspect')
    parser.add_argument('-v', '--verbose', action='store_true', help='Enable verbose mode')
    parser.add_argument('-i', '--internal', action='store_true', help='Inspect internal routes')
    parser.add_argument('app_module', help='Path to the Falcon application module')
    return parser




INFO:root:----------------------------------------
INFO:root:max length: 9224
INFO:root:max position: 11723
INFO:root:target_namespace: falcon.falcon<folder>.cmd<folder>.inspect_app<file>.make_parser<func>
INFO:root:****************************************

data 34:   0%|          | 0/512 [00:00<?, ?it/s]
data 34:   2%|▏         | 10/512 [01:32<1:17:00,  9.21s/it]
data 34:   4%|▍         | 20/512 [03:10<1:18:21,  9.56s/it]
data 34:   6%|▌         | 30/512 [04:48<1:17:41,  9.67s/it]
data 34:   8%|▊         | 40/512 [06:20<1:14:48,  9.51s/it]
data 34:  10%|▉         | 50/512 [07:58<1:13:50,  9.59s/it]
data 34:  12%|█▏        | 60/512 [09:33<1:12:13,  9.59s/it]
data 34:  14%|█▎        | 70/512 [11:21<1:13:28,  9.97s/it]
data 34:  16%|█▌        | 80/512 [12:54<1:10:21,  9.77s/it]
data 34:  18%|█▊        | 90/512 [14:29<1:08:00,  9.67s/it]
data 34:  20%|█▉        | 100/512 [16:05<1:06:16,  9.65s/it]
data 34:  21%|██▏       | 110/512 [17:42<1:04:41,  9.66s/it]
data 34:  21%|██▏       | 110/512 [18:02<1:05:56,  9.84s/it]
INFO:root:函数头: 
def make_parser():

INFO:root:目标函数体: 
    
    parser = argparse.ArgumentParser(
        description='Example: falcon-inspect-app myprogram:app'
    )
    parser.add_argument(
        '-r',
        '--route_only',
        action='store_true',
        help='Prints only the information regarding the routes',
    )
    parser.add_argument(
        '-v',
        '--verbose',
        action='store_true',
        help='More verbose output',
    )
    parser.add_argument(
        '-i',
        '--internal',
        action='store_true',
        help='Print also internal falcon route methods and error handlers',
    )
    parser.add_argument(
        'app_module',
        help='The module and app to inspect. Example: myapp.somemodule:api',
    )
    return parser

INFO:root:生成结果: 
    parser = argparse.ArgumentParser(description='Inspect Falcon application')

    parser.add_argument(
        '-r', '--router', action='store_true', help='Inspect the router'
    )
    parser.add_argument(
        '-v', '--verbose', action='store_true', help='Verbose mode'
    )
    parser.add_argument(
        '-i', '--internal', action='store_true', help='Inspect internal routes'
    )
    parser.add_argument(
        'app_module', help='Path to the Falcon application module'
    )

    return parser




INFO:root:----------------------------------------
INFO:root:max length: 8577
INFO:root:max position: 11914
INFO:root:target_namespace: falcon.falcon<folder>.cmd<folder>.inspect_app<file>.make_parser<func>
INFO:root:****************************************

data 34:   0%|          | 0/512 [00:00<?, ?it/s]
data 34:   2%|▏         | 10/512 [01:34<1:19:04,  9.45s/it]
data 34:   4%|▍         | 20/512 [03:15<1:20:41,  9.84s/it]
data 34:   6%|▌         | 30/512 [04:49<1:17:18,  9.62s/it]
data 34:   8%|▊         | 40/512 [06:21<1:14:26,  9.46s/it]
data 34:  10%|▉         | 50/512 [07:56<1:13:03,  9.49s/it]
data 34:  12%|█▏        | 60/512 [09:30<1:11:15,  9.46s/it]
data 34:  14%|█▎        | 70/512 [11:14<1:11:48,  9.75s/it]
data 34:  16%|█▌        | 80/512 [12:54<1:10:44,  9.82s/it]
data 34:  18%|█▊        | 90/512 [14:33<1:09:22,  9.86s/it]
data 34:  18%|█▊        | 90/512 [15:54<1:14:35, 10.60s/it]
INFO:root:函数头: 
def make_parser():

INFO:root:目标函数体: 
    
    parser = argparse.ArgumentParser(
        description='Example: falcon-inspect-app myprogram:app'
    )
    parser.add_argument(
        '-r',
        '--route_only',
        action='store_true',
        help='Prints only the information regarding the routes',
    )
    parser.add_argument(
        '-v',
        '--verbose',
        action='store_true',
        help='More verbose output',
    )
    parser.add_argument(
        '-i',
        '--internal',
        action='store_true',
        help='Print also internal falcon route methods and error handlers',
    )
    parser.add_argument(
        'app_module',
        help='The module and app to inspect. Example: myapp.somemodule:api',
    )
    return parser

INFO:root:生成结果: 
    parser = argparse.ArgumentParser(description='Inspect Falcon application')

    parser.add_argument('-r', '--router', action='store_true', help='Inspect the route configuration')
    parser.add_argument('-v', '--verbose', action='store_true', help='Increase verbosity')
    parser.add_argument('-i', '--internal', action='store_true', help='Inspect the internal configuration')
    parser.add_argument('app_module', help='Path to the Falcon application module')

    return parser




INFO:root:----------------------------------------
INFO:root:max length: 8638
INFO:root:max position: 11913
INFO:root:target_namespace: falcon.falcon<folder>.cmd<folder>.inspect_app<file>.make_parser<func>
INFO:root:****************************************

data 34:   0%|          | 0/512 [00:00<?, ?it/s]
data 34:   2%|▏         | 10/512 [01:34<1:18:47,  9.42s/it]
data 34:   4%|▍         | 20/512 [03:15<1:20:51,  9.86s/it]
data 34:   6%|▌         | 30/512 [04:48<1:17:10,  9.61s/it]
data 34:   8%|▊         | 40/512 [06:22<1:14:49,  9.51s/it]
data 34:  10%|▉         | 50/512 [07:56<1:13:00,  9.48s/it]
data 34:  12%|█▏        | 60/512 [09:36<1:12:32,  9.63s/it]
data 34:  14%|█▎        | 70/512 [11:05<1:09:19,  9.41s/it]
data 34:  16%|█▌        | 80/512 [12:46<1:09:22,  9.64s/it]
data 34:  18%|█▊        | 90/512 [14:21<1:07:20,  9.58s/it]
data 34:  20%|█▉        | 100/512 [15:55<1:05:23,  9.52s/it]
data 34:  21%|██▏       | 110/512 [17:28<1:03:22,  9.46s/it]
data 34:  23%|██▎       | 120/512 [19:07<1:02:40,  9.59s/it]
data 34:  23%|██▎       | 120/512 [19:16<1:02:57,  9.64s/it]
INFO:root:函数头: 
def make_parser():

INFO:root:目标函数体: 
    
    parser = argparse.ArgumentParser(
        description='Example: falcon-inspect-app myprogram:app'
    )
    parser.add_argument(
        '-r',
        '--route_only',
        action='store_true',
        help='Prints only the information regarding the routes',
    )
    parser.add_argument(
        '-v',
        '--verbose',
        action='store_true',
        help='More verbose output',
    )
    parser.add_argument(
        '-i',
        '--internal',
        action='store_true',
        help='Print also internal falcon route methods and error handlers',
    )
    parser.add_argument(
        'app_module',
        help='The module and app to inspect. Example: myapp.somemodule:api',
    )
    return parser

INFO:root:生成结果: 
    parser = argparse.ArgumentParser(description='Inspect Falcon application')

    parser.add_argument(
        '-r', '--router', dest='router', default=None,
        help='Path to the Falcon router module')

    parser.add_argument(
        '-v', '--verbose', dest='verbose', action='store_true',
        help='Enable verbose mode')

    parser.add_argument(
        '-i', '--internal', dest='internal', action='store_true',
        help='Inspect internal routes')

    parser.add_argument(
        'app_module', help='Path to the Falcon application module')

    return parser


INFO:root:----------------------------------------
INFO:root:max length: 8716
INFO:root:max position: 12069
INFO:root:target_namespace: falcon.falcon<folder>.cmd<folder>.inspect_app<file>.make_parser<func>
INFO:root:****************************************
INFO:root:--------data 35--------

data 35:   0%|          | 0/512 [00:00<?, ?it/s]
data 35:   2%|▏         | 10/512 [02:00<1:40:31, 12.01s/it]
data 35:   4%|▍         | 20/512 [04:07<1:42:08, 12.46s/it]
data 35:   6%|▌         | 30/512 [06:06<1:37:55, 12.19s/it]
data 35:   8%|▊         | 40/512 [08:06<1:35:20, 12.12s/it]
data 35:  10%|▉         | 50/512 [09:59<1:31:02, 11.82s/it]
data 35:  12%|█▏        | 60/512 [12:01<1:30:02, 11.95s/it]
data 35:  14%|█▎        | 70/512 [13:58<1:27:27, 11.87s/it]
data 35:  16%|█▌        | 80/512 [15:51<1:24:08, 11.69s/it]
data 35:  18%|█▊        | 90/512 [17:49<1:22:31, 11.73s/it]
data 35:  20%|█▉        | 100/512 [19:54<1:22:06, 11.96s/it]
data 35:  21%|██▏       | 110/512 [24:00<1:46:01, 15.82s/it]
data 35:  23%|██▎       | 120/512 [25:56<1:35:03, 14.55s/it]
data 35:  25%|██▌       | 130/512 [27:53<1:27:02, 13.67s/it]
data 35:  27%|██▋       | 140/512 [29:52<1:21:28, 13.14s/it]
data 35:  29%|██▉       | 150/512 [34:24<1:44:55, 17.39s/it]
data 35:  31%|███▏      | 160/512 [36:25<1:32:32, 15.77s/it]
data 35:  33%|███▎      | 170/512 [41:00<1:50:02, 19.31s/it]
data 35:  33%|███▎      | 170/512 [41:48<1:24:07, 14.76s/it]
INFO:root:函数头: 
def unquote_string(quoted):

INFO:root:目标函数体: 
    

    if len(quoted) < 2:
        return quoted
    elif quoted[0] != '"' or quoted[-1] != '"':
        # return original one, prevent side-effect
        return quoted

    tmp_quoted = quoted[1:-1]

    # PERF(philiptzou): Most header strings don't contain "quoted-pair" which
    # defined by RFC 7320. We use this little trick (quick string search) to
    # speed up string parsing by preventing unnecessary processes if possible.
    if '\\' not in tmp_quoted:
        return tmp_quoted
    elif r'\\' not in tmp_quoted:
        return tmp_quoted.replace('\\', '')
    else:
        return '\\'.join([q.replace('\\', '') for q in tmp_quoted.split(r'\\')])

INFO:root:生成结果: 
    if not isinstance(quoted, str):
        raise TypeError('Expected string')

    # Unquote the string by removing surrounding quotes and unescaping characters.
    unquoted = quoted[1:-1].replace('%', '%')

    # Unquote escaped characters.
    unquoted = unquoted.replace('+', ' ')
    unquoted = unquoted.replace('%2B', '+')
    unquoted = unquoted.replace('%2C', ',')
    unquoted = unquoted.replace('%2F', '/')
    unquoted = unquoted.replace('%3A', ':')
    unquoted = unquoted.replace('%3B', ';')
    unquoted = unquoted.replace('%3D', '=')
    unquoted = unquoted.replace('%2E', '.')
    unquoted = unquoted.replace('%20', ' ')

    return unquoted


INFO:root:----------------------------------------
INFO:root:max length: 10327
INFO:root:max position: 14867
INFO:root:target_namespace: falcon.falcon<folder>.util<folder>.uri<file>.unquote_string<func>
INFO:root:****************************************

data 35:   0%|          | 0/512 [00:00<?, ?it/s]
data 35:   2%|▏         | 10/512 [01:59<1:40:08, 11.97s/it]
data 35:   4%|▍         | 20/512 [07:13<3:11:58, 23.41s/it]
data 35:   6%|▌         | 30/512 [09:49<2:39:24, 19.84s/it]
data 35:   8%|▊         | 40/512 [12:23<2:22:07, 18.07s/it]
data 35:  10%|▉         | 50/512 [14:46<2:08:39, 16.71s/it]
data 35:  12%|█▏        | 60/512 [17:10<2:00:03, 15.94s/it]
data 35:  14%|█▎        | 70/512 [19:42<1:55:31, 15.68s/it]
data 35:  16%|█▌        | 80/512 [27:16<3:00:58, 25.14s/it]
data 35:  18%|█▊        | 90/512 [29:37<2:32:43, 21.71s/it]
data 35:  20%|█▉        | 100/512 [38:11<3:31:51, 30.85s/it]
data 35:  21%|██▏       | 110/512 [40:30<2:51:55, 25.66s/it]
data 35:  23%|██▎       | 120/512 [42:59<2:26:20, 22.40s/it]
data 35:  25%|██▌       | 130/512 [45:41<2:10:34, 20.51s/it]
data 35:  27%|██▋       | 140/512 [48:08<1:56:20, 18.77s/it]
data 35:  27%|██▋       | 140/512 [49:41<2:12:03, 21.30s/it]
INFO:root:函数头: 
def unquote_string(quoted):

INFO:root:目标函数体: 
    

    if len(quoted) < 2:
        return quoted
    elif quoted[0] != '"' or quoted[-1] != '"':
        # return original one, prevent side-effect
        return quoted

    tmp_quoted = quoted[1:-1]

    # PERF(philiptzou): Most header strings don't contain "quoted-pair" which
    # defined by RFC 7320. We use this little trick (quick string search) to
    # speed up string parsing by preventing unnecessary processes if possible.
    if '\\' not in tmp_quoted:
        return tmp_quoted
    elif r'\\' not in tmp_quoted:
        return tmp_quoted.replace('\\', '')
    else:
        return '\\'.join([q.replace('\\', '') for q in tmp_quoted.split(r'\\')])

INFO:root:生成结果: 
    if not isinstance(quoted, str):
        raise TypeError('Expected string, got %s' % type(quoted).__name__)

    # Remove leading and trailing quotes
    if quoted.startswith('"') and quoted.endswith('"'):
        quoted = quoted[1:-1]

    # Unquote characters
    unquoted = ''
    i = 0
    while i < len(quoted):
        if quoted[i] == '\\':
            # Escape character found
            i += 1
            if i == len(quoted):
                raise ValueError('Invalid escape sequence')
            unquoted += quoted[i]
        else:
            unquoted += quoted[i]
            i += 1

    return unquoted


INFO:root:----------------------------------------
INFO:root:max length: 9447
INFO:root:max position: 14880
INFO:root:target_namespace: falcon.falcon<folder>.util<folder>.uri<file>.unquote_string<func>
INFO:root:****************************************

data 35:   0%|          | 0/512 [00:00<?, ?it/s]
data 35:   2%|▏         | 10/512 [07:18<6:06:37, 43.82s/it]
data 35:   4%|▍         | 20/512 [09:44<3:38:42, 26.67s/it]
data 35:   6%|▌         | 30/512 [12:11<2:50:09, 21.18s/it]
data 35:   8%|▊         | 40/512 [14:38<2:26:29, 18.62s/it]
data 35:  10%|▉         | 50/512 [17:00<2:11:02, 17.02s/it]
data 35:  12%|█▏        | 60/512 [19:27<2:02:18, 16.24s/it]
data 35:  12%|█▏        | 60/512 [19:55<2:30:05, 19.92s/it]
INFO:root:函数头: 
def unquote_string(quoted):

INFO:root:目标函数体: 
    

    if len(quoted) < 2:
        return quoted
    elif quoted[0] != '"' or quoted[-1] != '"':
        # return original one, prevent side-effect
        return quoted

    tmp_quoted = quoted[1:-1]

    # PERF(philiptzou): Most header strings don't contain "quoted-pair" which
    # defined by RFC 7320. We use this little trick (quick string search) to
    # speed up string parsing by preventing unnecessary processes if possible.
    if '\\' not in tmp_quoted:
        return tmp_quoted
    elif r'\\' not in tmp_quoted:
        return tmp_quoted.replace('\\', '')
    else:
        return '\\'.join([q.replace('\\', '') for q in tmp_quoted.split(r'\\')])

INFO:root:生成结果: 
    if not isinstance(quoted, str):
        raise TypeError('Expected a string')

    # Unquote the string by removing the quotes and escaping characters.
    unquoted = quoted[1:-1].replace('%', '%25').replace('+', '%2B')

    return unquoted


INFO:root:----------------------------------------
INFO:root:max length: 9512
INFO:root:max position: 14090
INFO:root:target_namespace: falcon.falcon<folder>.util<folder>.uri<file>.unquote_string<func>
INFO:root:****************************************

data 35:   0%|          | 0/512 [00:00<?, ?it/s]
data 35:   2%|▏         | 10/512 [02:18<1:56:16, 13.90s/it]
data 35:   4%|▍         | 20/512 [04:52<2:01:09, 14.77s/it]
data 35:   6%|▌         | 30/512 [07:23<1:59:48, 14.91s/it]
data 35:   8%|▊         | 40/512 [09:54<1:57:50, 14.98s/it]
data 35:  10%|▉         | 50/512 [12:20<1:54:09, 14.83s/it]
data 35:  12%|█▏        | 60/512 [14:51<1:52:24, 14.92s/it]
data 35:  14%|█▎        | 70/512 [17:25<1:51:10, 15.09s/it]
data 35:  16%|█▌        | 80/512 [19:55<1:48:21, 15.05s/it]
data 35:  18%|█▊        | 90/512 [22:24<1:45:30, 15.00s/it]
data 35:  20%|█▉        | 100/512 [24:51<1:42:30, 14.93s/it]
data 35:  21%|██▏       | 110/512 [27:15<1:38:51, 14.76s/it]
data 35:  23%|██▎       | 120/512 [31:43<2:00:18, 18.41s/it]
data 35:  25%|██▌       | 130/512 [34:08<1:49:50, 17.25s/it]
data 35:  27%|██▋       | 140/512 [36:42<1:43:27, 16.69s/it]
data 35:  27%|██▋       | 140/512 [39:14<1:44:17, 16.82s/it]
INFO:root:函数头: 
def unquote_string(quoted):

INFO:root:目标函数体: 
    

    if len(quoted) < 2:
        return quoted
    elif quoted[0] != '"' or quoted[-1] != '"':
        # return original one, prevent side-effect
        return quoted

    tmp_quoted = quoted[1:-1]

    # PERF(philiptzou): Most header strings don't contain "quoted-pair" which
    # defined by RFC 7320. We use this little trick (quick string search) to
    # speed up string parsing by preventing unnecessary processes if possible.
    if '\\' not in tmp_quoted:
        return tmp_quoted
    elif r'\\' not in tmp_quoted:
        return tmp_quoted.replace('\\', '')
    else:
        return '\\'.join([q.replace('\\', '') for q in tmp_quoted.split(r'\\')])

INFO:root:生成结果: 
    if not isinstance(quoted, str):
        raise TypeError('Expected string, got %s' % type(quoted).__name__)

    # Remove leading and trailing quotes
    if quoted.startswith('"') and quoted.endswith('"'):
        quoted = quoted[1:-1]

    # Unquote characters
    unquoted = ''
    i = 0
    while i < len(quoted):
        if quoted[i] == '\\':
            # Handle escape sequences
            i += 1
            if i >= len(quoted):
                raise ValueError('Unescaped \\ at end of string')
            unquoted += quoted[i]
        else:
            unquoted += quoted[i]
            i += 1

    return unquoted


INFO:root:----------------------------------------
INFO:root:max length: 9721
INFO:root:max position: 15452
INFO:root:target_namespace: falcon.falcon<folder>.util<folder>.uri<file>.unquote_string<func>
INFO:root:****************************************

data 35:   0%|          | 0/512 [00:00<?, ?it/s]
data 35:   2%|▏         | 10/512 [02:11<1:49:48, 13.12s/it]
data 35:   4%|▍         | 20/512 [04:43<1:57:50, 14.37s/it]
data 35:   6%|▌         | 30/512 [07:08<1:55:41, 14.40s/it]
data 35:   8%|▊         | 40/512 [09:23<1:50:43, 14.08s/it]
data 35:  10%|▉         | 50/512 [11:17<1:40:51, 13.10s/it]
data 35:  12%|█▏        | 60/512 [13:13<1:34:45, 12.58s/it]
data 35:  14%|█▎        | 70/512 [15:15<1:31:54, 12.48s/it]
data 35:  16%|█▌        | 80/512 [17:11<1:27:45, 12.19s/it]
data 35:  18%|█▊        | 90/512 [19:05<1:23:59, 11.94s/it]
data 35:  20%|█▉        | 100/512 [21:00<1:21:01, 11.80s/it]
data 35:  21%|██▏       | 110/512 [22:52<1:17:50, 11.62s/it]
data 35:  23%|██▎       | 120/512 [24:45<1:15:12, 11.51s/it]
data 35:  25%|██▌       | 130/512 [26:41<1:13:27, 11.54s/it]
data 35:  27%|██▋       | 140/512 [28:34<1:11:12, 11.49s/it]
data 35:  29%|██▉       | 150/512 [30:29<1:09:17, 11.49s/it]
data 35:  31%|███▏      | 160/512 [32:23<1:07:07, 11.44s/it]
data 35:  33%|███▎      | 170/512 [34:21<1:05:52, 11.56s/it]
data 35:  35%|███▌      | 180/512 [36:18<1:04:14, 11.61s/it]
data 35:  37%|███▋      | 190/512 [38:19<1:03:00, 11.74s/it]
data 35:  39%|███▉      | 200/512 [40:22<1:02:02, 11.93s/it]
data 35:  41%|████      | 210/512 [42:21<1:00:02, 11.93s/it]
data 35:  43%|████▎     | 220/512 [44:21<58:05, 11.94s/it]  
data 35:  45%|████▍     | 230/512 [46:23<56:28, 12.02s/it]
data 35:  47%|████▋     | 240/512 [48:27<55:01, 12.14s/it]
data 35:  49%|████▉     | 250/512 [50:31<53:18, 12.21s/it]
data 35:  51%|█████     | 260/512 [52:31<50:59, 12.14s/it]
data 35:  53%|█████▎    | 270/512 [54:32<48:56, 12.13s/it]
data 35:  55%|█████▍    | 280/512 [56:34<47:01, 12.16s/it]
data 35:  57%|█████▋    | 290/512 [58:40<45:26, 12.28s/it]
data 35:  59%|█████▊    | 300/512 [1:00:45<43:36, 12.34s/it]
data 35:  61%|██████    | 310/512 [1:02:41<40:51, 12.14s/it]
data 35:  62%|██████▎   | 320/512 [1:04:36<38:10, 11.93s/it]
data 35:  64%|██████▍   | 330/512 [1:06:30<35:42, 11.77s/it]
data 35:  64%|██████▍   | 330/512 [1:06:52<36:53, 12.16s/it]
INFO:root:函数头: 
def unquote_string(quoted):

INFO:root:目标函数体: 
    

    if len(quoted) < 2:
        return quoted
    elif quoted[0] != '"' or quoted[-1] != '"':
        # return original one, prevent side-effect
        return quoted

    tmp_quoted = quoted[1:-1]

    # PERF(philiptzou): Most header strings don't contain "quoted-pair" which
    # defined by RFC 7320. We use this little trick (quick string search) to
    # speed up string parsing by preventing unnecessary processes if possible.
    if '\\' not in tmp_quoted:
        return tmp_quoted
    elif r'\\' not in tmp_quoted:
        return tmp_quoted.replace('\\', '')
    else:
        return '\\'.join([q.replace('\\', '') for q in tmp_quoted.split(r'\\')])

INFO:root:生成结果: 
    if not isinstance(quoted, str):
        raise TypeError('Expected string, got %s' % type(quoted).__name__)

    # Remove leading and trailing quotes
    if quoted.startswith('"') and quoted.endswith('"'):
        quoted = quoted[1:-1]

    # Unescape characters
    unquoted = ''
    i = 0
    while i < len(quoted):
        if quoted[i] == '\\':
            # Handle escaped characters
            if i + 1 < len(quoted):
                if quoted[i + 1] in '\\':
                    unquoted += '\\'
                    i += 2
                elif quoted[i + 1] in '"':
                    unquoted += '"'
                    i += 2
                elif quoted[i + 1] in 'n':
                    unquoted += '\n'
                    i += 2
                elif quoted[i + 1] in 't':
                    unquoted += '\t'
                    i += 2
                elif quoted[i + 1] in 'r':
                    unquoted += '\r'
                    i += 2
                elif quoted[i + 1] in 'b':
                    unquoted += '\b'
                    i += 2
                elif quoted[i + 1] in 'f':
                    unquoted += '\f'
                    i += 2
                else:
                    raise ValueError('Invalid escape sequence: \\' + quoted[i + 1])
            else:
                raise ValueError('Invalid escape sequence: \\')
        else:
            unquoted += quoted[i]
            i += 1

    return unquoted


INFO:root:----------------------------------------
INFO:root:max length: 10479
INFO:root:max position: 15309
INFO:root:target_namespace: falcon.falcon<folder>.util<folder>.uri<file>.unquote_string<func>
INFO:root:****************************************
INFO:root:--------data 36--------

data 36:   0%|          | 0/512 [00:00<?, ?it/s]
data 36:   2%|▏         | 10/512 [01:37<1:21:17,  9.72s/it]
data 36:   4%|▍         | 20/512 [03:27<1:26:02, 10.49s/it]
data 36:   6%|▌         | 30/512 [05:05<1:21:39, 10.17s/it]
data 36:   8%|▊         | 40/512 [06:49<1:20:43, 10.26s/it]
data 36:  10%|▉         | 50/512 [08:38<1:20:57, 10.51s/it]
data 36:  12%|█▏        | 60/512 [10:16<1:17:08, 10.24s/it]
data 36:  12%|█▏        | 60/512 [11:07<1:23:45, 11.12s/it]
INFO:root:函数头: 
def get_argnames(func):

INFO:root:目标函数体: 
    

    sig = inspect.signature(func)

    args = [
        param.name
        for param in sig.parameters.values()
        if param.kind
        not in (inspect.Parameter.VAR_POSITIONAL, inspect.Parameter.VAR_KEYWORD)
    ]

    # NOTE(kgriffs): Depending on the version of Python, 'self' may or may not
    # be present, so we normalize the results by removing 'self' as needed.
    # Note that this behavior varies between 3.x versions.
    if args and args[0] == 'self':
        args = args[1:]

    return args

INFO:root:生成结果: 
    import inspect

    signature = inspect.signature(func)
    argspec = signature.parameters

    argnames = []
    for name, param in argspec.items():
        if param.kind in (inspect.Parameter.POSITIONAL_OR_KEYWORD, inspect.Parameter.KEYWORD_ONLY):
            argnames.append(name)

    return argnames




INFO:root:----------------------------------------
INFO:root:max length: 9004
INFO:root:max position: 13823
INFO:root:target_namespace: falcon.falcon<folder>.util<folder>.misc<file>.get_argnames<func>
INFO:root:****************************************

data 36:   0%|          | 0/512 [00:00<?, ?it/s]
data 36:   2%|▏         | 10/512 [01:41<1:24:57, 10.15s/it]
data 36:   4%|▍         | 20/512 [03:27<1:25:09, 10.38s/it]
data 36:   6%|▌         | 30/512 [05:08<1:22:28, 10.27s/it]
data 36:   8%|▊         | 40/512 [06:56<1:22:32, 10.49s/it]
data 36:  10%|▉         | 50/512 [08:37<1:19:43, 10.35s/it]
data 36:  12%|█▏        | 60/512 [10:19<1:17:30, 10.29s/it]
data 36:  14%|█▎        | 70/512 [11:58<1:14:54, 10.17s/it]
data 36:  16%|█▌        | 80/512 [13:36<1:12:21, 10.05s/it]
data 36:  16%|█▌        | 80/512 [14:16<1:17:03, 10.70s/it]
INFO:root:函数头: 
def get_argnames(func):

INFO:root:目标函数体: 
    

    sig = inspect.signature(func)

    args = [
        param.name
        for param in sig.parameters.values()
        if param.kind
        not in (inspect.Parameter.VAR_POSITIONAL, inspect.Parameter.VAR_KEYWORD)
    ]

    # NOTE(kgriffs): Depending on the version of Python, 'self' may or may not
    # be present, so we normalize the results by removing 'self' as needed.
    # Note that this behavior varies between 3.x versions.
    if args and args[0] == 'self':
        args = args[1:]

    return args

INFO:root:生成结果: 
    # Importing inspect module
    import inspect

    # Getting the signature of the function
    signature = inspect.signature(func)

    # Collecting argument names excluding *arg and **kwargs
    argnames = [
        param.name for param in signature.parameters.values()
        if param.kind != inspect.Parameter.VARGS and param.kind != inspect.Parameter.VKWARGS
    ]

    return argnames




INFO:root:----------------------------------------
INFO:root:max length: 8858
INFO:root:max position: 14317
INFO:root:target_namespace: falcon.falcon<folder>.util<folder>.misc<file>.get_argnames<func>
INFO:root:****************************************

data 36:   0%|          | 0/512 [00:00<?, ?it/s]
data 36:   2%|▏         | 10/512 [01:34<1:18:58,  9.44s/it]
data 36:   4%|▍         | 20/512 [03:20<1:23:15, 10.15s/it]
data 36:   6%|▌         | 30/512 [05:04<1:22:27, 10.26s/it]
data 36:   8%|▊         | 40/512 [06:51<1:21:57, 10.42s/it]
data 36:  10%|▉         | 50/512 [08:36<1:20:25, 10.45s/it]
data 36:  12%|█▏        | 60/512 [10:18<1:18:08, 10.37s/it]
data 36:  14%|█▎        | 70/512 [11:59<1:15:40, 10.27s/it]
data 36:  14%|█▎        | 70/512 [15:41<1:39:06, 13.45s/it]
INFO:root:函数头: 
def get_argnames(func):

INFO:root:目标函数体: 
    

    sig = inspect.signature(func)

    args = [
        param.name
        for param in sig.parameters.values()
        if param.kind
        not in (inspect.Parameter.VAR_POSITIONAL, inspect.Parameter.VAR_KEYWORD)
    ]

    # NOTE(kgriffs): Depending on the version of Python, 'self' may or may not
    # be present, so we normalize the results by removing 'self' as needed.
    # Note that this behavior varies between 3.x versions.
    if args and args[0] == 'self':
        args = args[1:]

    return args

INFO:root:生成结果: 
    # Get the signature of the function
    sig = inspect.signature(func)
    # Get the parameters of the signature
    params = sig.parameters
    # Filter out *args and **kwargs parameters
    argnames = [param.name for param in params if param.kind != inspect.Parameter.VARargs and param.kind != inspect.Parameter.VAR_KEYWORD]
    return argnames




INFO:root:----------------------------------------
INFO:root:max length: 8878
INFO:root:max position: 13784
INFO:root:target_namespace: falcon.falcon<folder>.util<folder>.misc<file>.get_argnames<func>
INFO:root:****************************************

data 36:   0%|          | 0/512 [00:00<?, ?it/s]
data 36:   2%|▏         | 10/512 [01:41<1:24:57, 10.15s/it]
data 36:   4%|▍         | 20/512 [03:30<1:26:53, 10.60s/it]
data 36:   6%|▌         | 30/512 [05:15<1:24:45, 10.55s/it]
data 36:   8%|▊         | 40/512 [07:02<1:23:19, 10.59s/it]
data 36:   8%|▊         | 40/512 [08:37<1:41:43, 12.93s/it]
INFO:root:函数头: 
def get_argnames(func):

INFO:root:目标函数体: 
    

    sig = inspect.signature(func)

    args = [
        param.name
        for param in sig.parameters.values()
        if param.kind
        not in (inspect.Parameter.VAR_POSITIONAL, inspect.Parameter.VAR_KEYWORD)
    ]

    # NOTE(kgriffs): Depending on the version of Python, 'self' may or may not
    # be present, so we normalize the results by removing 'self' as needed.
    # Note that this behavior varies between 3.x versions.
    if args and args[0] == 'self':
        args = args[1:]

    return args

INFO:root:生成结果: 
    argspec = inspect.signature(func)
    argnames = argspec.parameters.keys()
    argnames = [argname for argname in argnames if argname not in {'*args', '**kwargs'}}
    return argnames




INFO:root:----------------------------------------
INFO:root:max length: 8288
INFO:root:max position: 13739
INFO:root:target_namespace: falcon.falcon<folder>.util<folder>.misc<file>.get_argnames<func>
INFO:root:****************************************

data 36:   0%|          | 0/512 [00:00<?, ?it/s]
data 36:   2%|▏         | 10/512 [01:35<1:19:38,  9.52s/it]
data 36:   4%|▍         | 20/512 [05:24<2:22:48, 17.42s/it]
data 36:   6%|▌         | 30/512 [07:12<1:55:46, 14.41s/it]
data 36:   8%|▊         | 40/512 [08:54<1:40:00, 12.71s/it]
data 36:   8%|▊         | 40/512 [09:48<1:55:47, 14.72s/it]
INFO:root:函数头: 
def get_argnames(func):

INFO:root:目标函数体: 
    

    sig = inspect.signature(func)

    args = [
        param.name
        for param in sig.parameters.values()
        if param.kind
        not in (inspect.Parameter.VAR_POSITIONAL, inspect.Parameter.VAR_KEYWORD)
    ]

    # NOTE(kgriffs): Depending on the version of Python, 'self' may or may not
    # be present, so we normalize the results by removing 'self' as needed.
    # Note that this behavior varies between 3.x versions.
    if args and args[0] == 'self':
        args = args[1:]

    return args

INFO:root:生成结果: 
    signature = inspect.signature(func)
    argspec = signature.parameters
    argnames = list(argspec.keys())
    argnames.remove('*args')
    argnames.remove('**kwargs')
    return argnames




INFO:root:----------------------------------------
INFO:root:max length: 7556
INFO:root:max position: 12780
INFO:root:target_namespace: falcon.falcon<folder>.util<folder>.misc<file>.get_argnames<func>
INFO:root:****************************************
INFO:root:--------data 37--------

data 37:   0%|          | 0/512 [00:00<?, ?it/s]
data 37:   2%|▏         | 10/512 [01:57<1:38:17, 11.75s/it]
data 37:   4%|▍         | 20/512 [04:10<1:43:44, 12.65s/it]
data 37:   6%|▌         | 30/512 [06:15<1:41:11, 12.60s/it]
data 37:   8%|▊         | 40/512 [08:26<1:40:35, 12.79s/it]
data 37:  10%|▉         | 50/512 [10:33<1:38:11, 12.75s/it]
data 37:  12%|█▏        | 60/512 [12:39<1:35:49, 12.72s/it]
data 37:  14%|█▎        | 70/512 [14:46<1:33:35, 12.70s/it]
data 37:  16%|█▌        | 80/512 [16:54<1:31:39, 12.73s/it]
data 37:  18%|█▊        | 90/512 [18:56<1:28:24, 12.57s/it]
data 37:  20%|█▉        | 100/512 [21:07<1:27:18, 12.72s/it]
data 37:  21%|██▏       | 110/512 [23:16<1:25:41, 12.79s/it]
data 37:  23%|██▎       | 120/512 [28:00<1:54:38, 17.55s/it]
data 37:  25%|██▌       | 130/512 [30:07<1:42:17, 16.07s/it]
data 37:  27%|██▋       | 140/512 [32:10<1:32:33, 14.93s/it]
data 37:  29%|██▉       | 150/512 [34:18<1:26:10, 14.28s/it]
data 37:  31%|███▏      | 160/512 [36:17<1:19:36, 13.57s/it]
data 37:  33%|███▎      | 170/512 [38:17<1:14:44, 13.11s/it]
data 37:  35%|███▌      | 180/512 [40:19<1:10:55, 12.82s/it]
data 37:  37%|███▋      | 190/512 [42:22<1:07:58, 12.67s/it]
data 37:  39%|███▉      | 200/512 [44:21<1:04:38, 12.43s/it]
data 37:  41%|████      | 210/512 [46:21<1:02:00, 12.32s/it]
data 37:  43%|████▎     | 220/512 [48:18<59:03, 12.14s/it]  
data 37:  45%|████▍     | 230/512 [50:20<57:04, 12.14s/it]
data 37:  47%|████▋     | 240/512 [52:24<55:21, 12.21s/it]
data 37:  49%|████▉     | 250/512 [54:32<54:09, 12.40s/it]
data 37:  51%|█████     | 260/512 [56:32<51:33, 12.27s/it]
data 37:  53%|█████▎    | 270/512 [58:33<49:20, 12.24s/it]
data 37:  55%|█████▍    | 280/512 [1:00:31<46:44, 12.09s/it]
data 37:  57%|█████▋    | 290/512 [1:02:37<45:19, 12.25s/it]
data 37:  59%|█████▊    | 300/512 [1:04:48<44:09, 12.50s/it]
data 37:  61%|██████    | 310/512 [1:06:51<41:50, 12.43s/it]
data 37:  62%|██████▎   | 320/512 [1:08:48<39:04, 12.21s/it]
data 37:  64%|██████▍   | 330/512 [1:10:42<36:19, 11.98s/it]
data 37:  66%|██████▋   | 340/512 [1:12:37<33:54, 11.83s/it]
data 37:  68%|██████▊   | 350/512 [1:14:36<31:59, 11.85s/it]
data 37:  70%|███████   | 360/512 [1:16:37<30:14, 11.94s/it]
data 37:  72%|███████▏  | 370/512 [1:18:39<28:23, 12.00s/it]
data 37:  74%|███████▍  | 380/512 [1:20:44<26:43, 12.15s/it]
data 37:  76%|███████▌  | 390/512 [1:23:00<25:36, 12.59s/it]
data 37:  78%|███████▊  | 400/512 [1:25:07<23:35, 12.64s/it]
data 37:  80%|████████  | 410/512 [1:27:18<21:44, 12.78s/it]
data 37:  82%|████████▏ | 420/512 [1:29:36<20:02, 13.07s/it]
data 37:  84%|████████▍ | 430/512 [1:31:49<17:58, 13.15s/it]
data 37:  86%|████████▌ | 440/512 [1:44:03<37:28, 31.22s/it]
data 37:  88%|████████▊ | 450/512 [1:46:14<26:38, 25.78s/it]
data 37:  90%|████████▉ | 460/512 [1:48:28<19:07, 22.07s/it]
data 37:  92%|█████████▏| 470/512 [1:50:38<13:32, 19.34s/it]
data 37:  94%|█████████▍| 480/512 [1:52:52<09:21, 17.56s/it]
data 37:  96%|█████████▌| 490/512 [1:55:01<05:55, 16.17s/it]
data 37:  98%|█████████▊| 500/512 [1:57:18<03:05, 15.42s/it]
data 37: 100%|█████████▉| 510/512 [2:03:28<00:43, 21.90s/it]
data 37: 100%|█████████▉| 510/512 [2:04:10<00:29, 14.61s/it]
INFO:root:函数头: 
def _is_asgi_app(app):

INFO:root:目标函数体: 
    app_args = inspect.getfullargspec(app).args
    num_app_args = len(app_args)

    # NOTE(kgriffs): Technically someone could name the "self" or "cls"
    #   arg something else, but we will make the simplifying
    #   assumption that this is rare enough to not worry about.
    if app_args[0] in {'cls', 'self'}:
        num_app_args -= 1

    is_asgi = num_app_args == 3

    return is_asgi

INFO:root:生成结果: 
    try:
        app.__call__
    except AttributeError:
        return False

    try:
        app.__await__
    except AttributeError:
        return False

    try:
        app.__await__
    except AttributeError:
        return False

    try:
        app.__await__
    except AttributeError:
        return False

    try:
        app.__await__
    except AttributeError:
        return False

    try:
        app.__await__
    except AttributeError:
        return False

    try:
        app.__await__
    except AttributeError:
        return False

    try:
        app.__await__
    except AttributeError:
        return False

    try:
        app.__await__
    except AttributeError:
        return False

    try:
        app.__await__
    except AttributeError:
        return False

    try:
        app.__await__
    except AttributeError:
        return False

    try:
        app.__await__
    except AttributeError:
        return False

    try:
        app.__await__
    except AttributeError:
        return False

    try:
        app.__await__
    except AttributeError:
        return False

    try:
        app.__await__
    except AttributeError:
        return False

    try:
        app.__await__
    except AttributeError:
        return False

    try:
        app.__await__
    except AttributeError:
        return False

    try:
        app.__await__
    except AttributeError:
        return False

    try:
        app.__await__
    except AttributeError:
        return False

    try:
        app.__await__
    except AttributeError:
        return False

    try:
        app.__await__
    except AttributeError:
        return False

    try:
        app.__await__
    except AttributeError:
        return False

    try:
        app.__await__
    except AttributeError:
        return False

    try:
        app.__await__
    except AttributeError:
        return False

    try:
        app.__await__
    except AttributeError:
        return False

    try:
        app.__await__
    except AttributeError:
        return False

    try:
        app.__await__
    except AttributeError:
        return False

    try:
        app.__await__
    except AttributeError:
        return False

    try:
        app.__await__
    except AttributeError:
        return False

    try:
        app.__await__
    except AttributeError:
        return False

    try:
        app.__await__
    except AttributeError:
        return False

    try:
        app.__await__
    except AttributeError:
        return False



INFO:root:----------------------------------------
INFO:root:max length: 9478
INFO:root:max position: 14094
INFO:root:target_namespace: falcon.falcon<folder>.testing<folder>.client<file>._is_asgi_app<func>
INFO:root:****************************************

data 37:   0%|          | 0/512 [00:00<?, ?it/s]
data 37:   2%|▏         | 10/512 [03:56<3:18:05, 23.68s/it]
data 37:   4%|▍         | 20/512 [06:11<2:24:47, 17.66s/it]
data 37:   4%|▍         | 20/512 [07:22<3:01:29, 22.13s/it]
INFO:root:函数头: 
def _is_asgi_app(app):

INFO:root:目标函数体: 
    app_args = inspect.getfullargspec(app).args
    num_app_args = len(app_args)

    # NOTE(kgriffs): Technically someone could name the "self" or "cls"
    #   arg something else, but we will make the simplifying
    #   assumption that this is rare enough to not worry about.
    if app_args[0] in {'cls', 'self'}:
        num_app_args -= 1

    is_asgi = num_app_args == 3

    return is_asgi

INFO:root:生成结果: 
    try:
        app(None, None, None)
        return True
    except TypeError:
        return False


INFO:root:----------------------------------------
INFO:root:max length: 7316
INFO:root:max position: 13343
INFO:root:target_namespace: falcon.falcon<folder>.testing<folder>.client<file>._is_asgi_app<func>
INFO:root:****************************************

data 37:   0%|          | 0/512 [00:00<?, ?it/s]
data 37:   2%|▏         | 10/512 [01:57<1:38:06, 11.73s/it]
data 37:   4%|▍         | 20/512 [04:12<1:44:35, 12.75s/it]
data 37:   4%|▍         | 20/512 [05:25<2:13:24, 16.27s/it]
INFO:root:函数头: 
def _is_asgi_app(app):

INFO:root:目标函数体: 
    app_args = inspect.getfullargspec(app).args
    num_app_args = len(app_args)

    # NOTE(kgriffs): Technically someone could name the "self" or "cls"
    #   arg something else, but we will make the simplifying
    #   assumption that this is rare enough to not worry about.
    if app_args[0] in {'cls', 'self'}:
        num_app_args -= 1

    is_asgi = num_app_args == 3

    return is_asgi

INFO:root:生成结果: 
    try:
        app(None, None, None)
        return True
    except TypeError:
        return False




INFO:root:----------------------------------------
INFO:root:max length: 7116
INFO:root:max position: 12552
INFO:root:target_namespace: falcon.falcon<folder>.testing<folder>.client<file>._is_asgi_app<func>
INFO:root:****************************************

data 37:   0%|          | 0/512 [00:00<?, ?it/s]
data 37:   2%|▏         | 10/512 [01:55<1:36:38, 11.55s/it]
data 37:   4%|▍         | 20/512 [04:08<1:43:07, 12.58s/it]
data 37:   4%|▍         | 20/512 [05:14<2:08:45, 15.70s/it]
INFO:root:函数头: 
def _is_asgi_app(app):

INFO:root:目标函数体: 
    app_args = inspect.getfullargspec(app).args
    num_app_args = len(app_args)

    # NOTE(kgriffs): Technically someone could name the "self" or "cls"
    #   arg something else, but we will make the simplifying
    #   assumption that this is rare enough to not worry about.
    if app_args[0] in {'cls', 'self'}:
        num_app_args -= 1

    is_asgi = num_app_args == 3

    return is_asgi

INFO:root:生成结果: 
    try:
        app(None, None, None)
        return True
    except TypeError:
        return False


INFO:root:----------------------------------------
INFO:root:max length: 7643
INFO:root:max position: 12399
INFO:root:target_namespace: falcon.falcon<folder>.testing<folder>.client<file>._is_asgi_app<func>
INFO:root:****************************************

data 37:   0%|          | 0/512 [00:00<?, ?it/s]
data 37:   2%|▏         | 10/512 [02:00<1:41:09, 12.09s/it]
data 37:   4%|▍         | 20/512 [04:13<1:44:55, 12.80s/it]
data 37:   4%|▍         | 20/512 [05:48<2:23:01, 17.44s/it]
INFO:root:函数头: 
def _is_asgi_app(app):

INFO:root:目标函数体: 
    app_args = inspect.getfullargspec(app).args
    num_app_args = len(app_args)

    # NOTE(kgriffs): Technically someone could name the "self" or "cls"
    #   arg something else, but we will make the simplifying
    #   assumption that this is rare enough to not worry about.
    if app_args[0] in {'cls', 'self'}:
        num_app_args -= 1

    is_asgi = num_app_args == 3

    return is_asgi

INFO:root:生成结果: 
    # Check if the app accepts exactly three arguments
    return len(inspect.signature(app).parameters) == 3


INFO:root:----------------------------------------
INFO:root:max length: 8338
INFO:root:max position: 13252
INFO:root:target_namespace: falcon.falcon<folder>.testing<folder>.client<file>._is_asgi_app<func>
INFO:root:****************************************
INFO:root:--------data 38--------

data 38:   0%|          | 0/512 [00:00<?, ?it/s]
data 38:   2%|▏         | 10/512 [01:39<1:23:21,  9.96s/it]
data 38:   2%|▏         | 10/512 [03:16<2:44:24, 19.65s/it]
INFO:root:函数头: 
    def convert(self, value):

INFO:root:目标函数体: 
        try:
            return uuid.UUID(value)
        except ValueError:
            return None

INFO:root:生成结果: 
        try:
            return uuid.UUID(value)
        except ValueError:
            return None


INFO:root:----------------------------------------
INFO:root:max length: 6698
INFO:root:max position: 12171
INFO:root:target_namespace: falcon.falcon<folder>.routing<folder>.converters<file>.UUIDConverter<class>.convert<func>
INFO:root:****************************************

data 38:   0%|          | 0/512 [00:00<?, ?it/s]
data 38:   2%|▏         | 10/512 [01:31<1:16:16,  9.12s/it]
data 38:   2%|▏         | 10/512 [02:59<2:30:06, 17.94s/it]
INFO:root:函数头: 
    def convert(self, value):

INFO:root:目标函数体: 
        try:
            return uuid.UUID(value)
        except ValueError:
            return None

INFO:root:生成结果: 
        try:
            return uuid.UUID(value)
        except ValueError:
            return None


INFO:root:----------------------------------------
INFO:root:max length: 7004
INFO:root:max position: 10669
INFO:root:target_namespace: falcon.falcon<folder>.routing<folder>.converters<file>.UUIDConverter<class>.convert<func>
INFO:root:****************************************

data 38:   0%|          | 0/512 [00:00<?, ?it/s]
data 38:   2%|▏         | 10/512 [01:33<1:18:04,  9.33s/it]
data 38:   2%|▏         | 10/512 [03:04<2:34:14, 18.44s/it]
INFO:root:函数头: 
    def convert(self, value):

INFO:root:目标函数体: 
        try:
            return uuid.UUID(value)
        except ValueError:
            return None

INFO:root:生成结果: 
        try:
            return uuid.UUID(value)
        except ValueError:
            return None


INFO:root:----------------------------------------
INFO:root:max length: 6353
INFO:root:max position: 11313
INFO:root:target_namespace: falcon.falcon<folder>.routing<folder>.converters<file>.UUIDConverter<class>.convert<func>
INFO:root:****************************************

data 38:   0%|          | 0/512 [00:00<?, ?it/s]
data 38:   2%|▏         | 10/512 [01:32<1:17:05,  9.21s/it]
data 38:   2%|▏         | 10/512 [03:02<2:32:33, 18.23s/it]
INFO:root:函数头: 
    def convert(self, value):

INFO:root:目标函数体: 
        try:
            return uuid.UUID(value)
        except ValueError:
            return None

INFO:root:生成结果: 
        try:
            return uuid.UUID(value)
        except ValueError:
            return None


INFO:root:----------------------------------------
INFO:root:max length: 6560
INFO:root:max position: 10774
INFO:root:target_namespace: falcon.falcon<folder>.routing<folder>.converters<file>.UUIDConverter<class>.convert<func>
INFO:root:****************************************

data 38:   0%|          | 0/512 [00:00<?, ?it/s]
data 38:   2%|▏         | 10/512 [01:36<1:20:43,  9.65s/it]
data 38:   2%|▏         | 10/512 [03:11<2:40:31, 19.19s/it]
INFO:root:函数头: 
    def convert(self, value):

INFO:root:目标函数体: 
        try:
            return uuid.UUID(value)
        except ValueError:
            return None

INFO:root:生成结果: 
        try:
            return uuid.UUID(value)
        except ValueError:
            return None


INFO:root:----------------------------------------
INFO:root:max length: 7404
INFO:root:max position: 11877
INFO:root:target_namespace: falcon.falcon<folder>.routing<folder>.converters<file>.UUIDConverter<class>.convert<func>
INFO:root:****************************************
INFO:root:--------data 39--------

data 39:   0%|          | 0/512 [00:00<?, ?it/s]
data 39:   2%|▏         | 10/512 [00:09<08:12,  1.02it/s]
data 39:   4%|▍         | 20/512 [00:18<07:40,  1.07it/s]
data 39:   4%|▍         | 20/512 [00:27<11:13,  1.37s/it]
INFO:root:函数头: 
def make_utc(dt: datetime) -> datetime:

INFO:root:目标函数体: 
    if settings.USE_TZ and is_naive(dt):
        return make_aware(dt, timezone=timezone.utc)

    return dt

INFO:root:生成结果: 
    if settings.U<|fim_suffix|><|fim_middle|>seTZ and not is_naive(dt):
        return dt.ast timezone(timezone.utc)
    return dt




INFO:root:----------------------------------------
INFO:root:max length: 1633
INFO:root:max position: 1633
INFO:root:target_namespace: djangorestframework-simplejwt.rest_framework_simplejwt<folder>.utils<file>.make_utc<func>
INFO:root:****************************************

data 39:   0%|          | 0/512 [00:00<?, ?it/s]
data 39:   2%|▏         | 10/512 [00:08<06:52,  1.22it/s]
data 39:   4%|▍         | 20/512 [00:18<07:49,  1.05it/s]
data 39:   4%|▍         | 20/512 [00:26<10:59,  1.34s/it]
INFO:root:函数头: 
def make_utc(dt: datetime) -> datetime:

INFO:root:目标函数体: 
    if settings.USE_TZ and is_naive(dt):
        return make_aware(dt, timezone=timezone.utc)

    return dt

INFO:root:生成结果: 
    if settings.USE_TZ and not is_naive(dt):
        return dt.ast timezone(timezone.utc)
    return dt




INFO:root:----------------------------------------
INFO:root:max length: 1632
INFO:root:max position: 1632
INFO:root:target_namespace: djangorestframework-simplejwt.rest_framework_simplejwt<folder>.utils<file>.make_utc<func>
INFO:root:****************************************

data 39:   0%|          | 0/512 [00:00<?, ?it/s]
data 39:   2%|▏         | 10/512 [00:08<06:43,  1.24it/s]
data 39:   2%|▏         | 10/512 [00:16<13:24,  1.60s/it]
INFO:root:函数头: 
def make_utc(dt: datetime) -> datetime:

INFO:root:目标函数体: 
    if settings.USE_TZ and is_naive(dt):
        return make_aware(dt, timezone=timezone.utc)

    return dt

INFO:root:生成结果: 
    if settings USE_TZ:
        return make aware(dt)
    return dt




INFO:root:----------------------------------------
INFO:root:max length: 1622
INFO:root:max position: 1622
INFO:root:target_namespace: djangorestframework-simplejwt.rest_framework_simplejwt<folder>.utils<file>.make_utc<func>
INFO:root:****************************************

data 39:   0%|          | 0/512 [00:00<?, ?it/s]
data 39:   2%|▏         | 10/512 [00:07<06:25,  1.30it/s]
data 39:   4%|▍         | 20/512 [00:16<06:42,  1.22it/s]
data 39:   4%|▍         | 20/512 [00:26<10:58,  1.34s/it]
INFO:root:函数头: 
def make_utc(dt: datetime) -> datetime:

INFO:root:目标函数体: 
    if settings.USE_TZ and is_naive(dt):
        return make_aware(dt, timezone=timezone.utc)

    return dt

INFO:root:生成结果: 
    if settings.USE_TZ and not is_naive(dt):
        return dt.astimezone(timezone.utc)
    return dt




INFO:root:----------------------------------------
INFO:root:max length: 1633
INFO:root:max position: 1633
INFO:root:target_namespace: djangorestframework-simplejwt.rest_framework_simplejwt<folder>.utils<file>.make_utc<func>
INFO:root:****************************************

data 39:   0%|          | 0/512 [00:00<?, ?it/s]
data 39:   2%|▏         | 10/512 [00:07<06:35,  1.27it/s]
data 39:   4%|▍         | 20/512 [00:16<06:44,  1.21it/s]
data 39:   4%|▍         | 20/512 [00:24<10:09,  1.24s/it]
INFO:root:函数头: 
def make_utc(dt: datetime) -> datetime:

INFO:root:目标函数体: 
    if settings.USE_TZ and is_naive(dt):
        return make_aware(dt, timezone=timezone.utc)

    return dt

INFO:root:生成结果: 
    if settings.USE_TZ and not is_naive(dt):
        return dt.astimezone(timezone.utc)
    return dt




INFO:root:----------------------------------------
INFO:root:max length: 1633
INFO:root:max position: 1633
INFO:root:target_namespace: djangorestframework-simplejwt.rest_framework_simplejwt<folder>.utils<file>.make_utc<func>
INFO:root:****************************************
INFO:root:--------data 40--------

data 40:   0%|          | 0/512 [00:00<?, ?it/s]
data 40:   2%|▏         | 10/512 [02:36<2:10:44, 15.63s/it]
data 40:   4%|▍         | 20/512 [05:13<2:08:36, 15.68s/it]
data 40:   4%|▍         | 20/512 [05:54<2:25:10, 17.70s/it]
INFO:root:函数头: 
def fib(cv=1, lv=0):

INFO:root:目标函数体: 
    
    if cv is None:
        cv = 1
    if lv is None:
        lv = 0
    return cv + lv

INFO:root:生成结果: 
    if cv == 0:
        return lv
    return fib(lv, cv + lv)



INFO:root:----------------------------------------
INFO:root:max length: 7721
INFO:root:max position: 20950
INFO:root:target_namespace: boto.boto<folder>.sdb<folder>.db<folder>.sequence<file>.fib<func>
INFO:root:****************************************

data 40:   0%|          | 0/512 [00:00<?, ?it/s]
data 40:   2%|▏         | 10/512 [02:13<1:52:05, 13.40s/it]
data 40:   4%|▍         | 20/512 [07:09<3:07:47, 22.90s/it]
data 40:   4%|▍         | 20/512 [08:32<3:30:08, 25.63s/it]
INFO:root:函数头: 
def fib(cv=1, lv=0):

INFO:root:目标函数体: 
    
    if cv is None:
        cv = 1
    if lv is None:
        lv = 0
    return cv + lv

INFO:root:生成结果: 
    if lv == 0:
        return cv
    else:
        return fib(lv, cv + lv)


INFO:root:----------------------------------------
INFO:root:max length: 8086
INFO:root:max position: 21372
INFO:root:target_namespace: boto.boto<folder>.sdb<folder>.db<folder>.sequence<file>.fib<func>
INFO:root:****************************************

data 40:   0%|          | 0/512 [00:00<?, ?it/s]
data 40:   2%|▏         | 10/512 [02:15<1:53:20, 13.55s/it]
data 40:   4%|▍         | 20/512 [04:34<1:52:39, 13.74s/it]
data 40:   4%|▍         | 20/512 [05:15<2:09:17, 15.77s/it]
INFO:root:函数头: 
def fib(cv=1, lv=0):

INFO:root:目标函数体: 
    
    if cv is None:
        cv = 1
    if lv is None:
        lv = 0
    return cv + lv

INFO:root:生成结果: 
    if lv == 0:
        return cv
    return fib(lv, cv + lv)



INFO:root:----------------------------------------
INFO:root:max length: 7214
INFO:root:max position: 18675
INFO:root:target_namespace: boto.boto<folder>.sdb<folder>.db<folder>.sequence<file>.fib<func>
INFO:root:****************************************

data 40:   0%|          | 0/512 [00:00<?, ?it/s]
data 40:   0%|          | 0/512 [01:45<?, ?it/s]
INFO:root:函数头: 
def fib(cv=1, lv=0):

INFO:root:目标函数体: 
    
    if cv is None:
        cv = 1
    if lv is None:
        lv = 0
    return cv + lv

INFO:root:生成结果: 
    return cv + lv


INFO:root:----------------------------------------
INFO:root:max length: 7162
INFO:root:max position: 18236
INFO:root:target_namespace: boto.boto<folder>.sdb<folder>.db<folder>.sequence<file>.fib<func>
INFO:root:****************************************

data 40:   0%|          | 0/512 [00:00<?, ?it/s]
data 40:   2%|▏         | 10/512 [02:10<1:49:30, 13.09s/it]
data 40:   4%|▍         | 20/512 [04:41<1:57:04, 14.28s/it]
data 40:   4%|▍         | 20/512 [05:31<2:16:05, 16.60s/it]
INFO:root:函数头: 
def fib(cv=1, lv=0):

INFO:root:目标函数体: 
    
    if cv is None:
        cv = 1
    if lv is None:
        lv = 0
    return cv + lv

INFO:root:生成结果: 
    if lv == 0:
        return cv
    return fib(lv, cv + lv)




INFO:root:----------------------------------------
INFO:root:max length: 7629
INFO:root:max position: 19767
INFO:root:target_namespace: boto.boto<folder>.sdb<folder>.db<folder>.sequence<file>.fib<func>
INFO:root:****************************************
INFO:root:--------data 41--------

data 41:   0%|          | 0/512 [00:00<?, ?it/s]
data 41:   2%|▏         | 10/512 [07:24<6:11:37, 44.42s/it]
data 41:   2%|▏         | 10/512 [08:47<7:21:09, 52.73s/it]
INFO:root:函数头: 
    def add_rule(self, rule):

INFO:root:目标函数体: 
        
        self.append(rule)
        return self

INFO:root:生成结果: 
        self.append(rule)
        return self




INFO:root:----------------------------------------
INFO:root:max length: 8671
INFO:root:max position: 22131
INFO:root:target_namespace: boto.boto<folder>.s3<folder>.website<file>.RoutingRules<class>.add_rule<func>
INFO:root:****************************************

data 41:   0%|          | 0/512 [00:00<?, ?it/s]
data 41:   2%|▏         | 10/512 [02:49<2:21:34, 16.92s/it]
data 41:   2%|▏         | 10/512 [03:11<2:40:36, 19.20s/it]
INFO:root:函数头: 
    def add_rule(self, rule):

INFO:root:目标函数体: 
        
        self.append(rule)
        return self

INFO:root:生成结果: 
        self.append(rule)
        return self




INFO:root:----------------------------------------
INFO:root:max length: 6962
INFO:root:max position: 22400
INFO:root:target_namespace: boto.boto<folder>.s3<folder>.website<file>.RoutingRules<class>.add_rule<func>
INFO:root:****************************************

data 41:   0%|          | 0/512 [00:00<?, ?it/s]
data 41:   2%|▏         | 10/512 [02:38<2:12:42, 15.86s/it]
data 41:   2%|▏         | 10/512 [03:13<2:42:01, 19.37s/it]
INFO:root:函数头: 
    def add_rule(self, rule):

INFO:root:目标函数体: 
        
        self.append(rule)
        return self

INFO:root:生成结果: 
        self.append(rule)
        return self


INFO:root:----------------------------------------
INFO:root:max length: 7304
INFO:root:max position: 21573
INFO:root:target_namespace: boto.boto<folder>.s3<folder>.website<file>.RoutingRules<class>.add_rule<func>
INFO:root:****************************************

data 41:   0%|          | 0/512 [00:00<?, ?it/s]
data 41:   2%|▏         | 10/512 [02:33<2:08:27, 15.35s/it]
data 41:   2%|▏         | 10/512 [02:47<2:20:16, 16.77s/it]
INFO:root:函数头: 
    def add_rule(self, rule):

INFO:root:目标函数体: 
        
        self.append(rule)
        return self

INFO:root:生成结果: 
        self.append(rule)
        return self


INFO:root:----------------------------------------
INFO:root:max length: 7270
INFO:root:max position: 20242
INFO:root:target_namespace: boto.boto<folder>.s3<folder>.website<file>.RoutingRules<class>.add_rule<func>
INFO:root:****************************************

data 41:   0%|          | 0/512 [00:00<?, ?it/s]
data 41:   2%|▏         | 10/512 [02:31<2:06:23, 15.11s/it]
data 41:   2%|▏         | 10/512 [03:09<2:38:43, 18.97s/it]
INFO:root:函数头: 
    def add_rule(self, rule):

INFO:root:目标函数体: 
        
        self.append(rule)
        return self

INFO:root:生成结果: 
        self.append(rule)
        return self


INFO:root:----------------------------------------
INFO:root:max length: 7500
INFO:root:max position: 21381
INFO:root:target_namespace: boto.boto<folder>.s3<folder>.website<file>.RoutingRules<class>.add_rule<func>
INFO:root:****************************************
INFO:root:--------data 42--------

data 42:   0%|          | 0/512 [00:00<?, ?it/s]
data 42:   2%|▏         | 10/512 [02:19<1:56:57, 13.98s/it]
data 42:   4%|▍         | 20/512 [06:28<2:47:03, 20.37s/it]
data 42:   6%|▌         | 30/512 [08:31<2:14:04, 16.69s/it]
data 42:   8%|▊         | 40/512 [10:19<1:52:57, 14.36s/it]
data 42:   8%|▊         | 40/512 [10:52<2:08:15, 16.30s/it]
INFO:root:函数头: 
    @staticmethod
    def _canned_policy(resource, expires):

INFO:root:目标函数体: 
        
        policy = ('{"Statement":[{"Resource":"%(resource)s",'
                  '"Condition":{"DateLessThan":{"AWS:EpochTime":'
                  '%(expires)s}}}]}' % locals())
        return policy

INFO:root:生成结果: 
        return '{"Statement":[{"Resource":"%(resource)s","Condition":{"DateLessThan":{"AWS:EpochTime":%(expires)s}}}]}' % {'resource': resource, 'expires': expires}


INFO:root:----------------------------------------
INFO:root:max length: 9672
INFO:root:max position: 20304
INFO:root:target_namespace: boto.boto<folder>.cloudfront<folder>.distribution<file>.Distribution<class>._canned_policy<func>
INFO:root:****************************************

data 42:   0%|          | 0/512 [00:00<?, ?it/s]
data 42:   2%|▏         | 10/512 [02:02<1:42:47, 12.29s/it]
data 42:   4%|▍         | 20/512 [04:10<1:43:00, 12.56s/it]
data 42:   6%|▌         | 30/512 [06:08<1:37:58, 12.20s/it]
data 42:   8%|▊         | 40/512 [07:58<1:32:28, 11.76s/it]
data 42:  10%|▉         | 50/512 [09:53<1:29:34, 11.63s/it]
data 42:  12%|█▏        | 60/512 [12:02<1:31:03, 12.09s/it]
data 42:  14%|█▎        | 70/512 [14:05<1:29:30, 12.15s/it]
data 42:  14%|█▎        | 70/512 [15:43<1:39:20, 13.48s/it]
INFO:root:函数头: 
    @staticmethod
    def _canned_policy(resource, expires):

INFO:root:目标函数体: 
        
        policy = ('{"Statement":[{"Resource":"%(resource)s",'
                  '"Condition":{"DateLessThan":{"AWS:EpochTime":'
                  '%(expires)s}}}]}' % locals())
        return policy

INFO:root:生成结果: 
        policy = {
            "Statement": [
                {
                    "Effect": "Allow",
                    "Action": "cloudfront:GetObject",
                    "Resource": resource,
                    "Condition": {
                        "DateLessThan": {
                            "AWS:EpochTime": int(expires)
                        }
                    }
                }
            ]
        }
        return json.dumps(policy)

INFO:root:----------------------------------------
INFO:root:max length: 10420
INFO:root:max position: 22360
INFO:root:target_namespace: boto.boto<folder>.cloudfront<folder>.distribution<file>.Distribution<class>._canned_policy<func>
INFO:root:****************************************

data 42:   0%|          | 0/512 [00:00<?, ?it/s]
data 42:   2%|▏         | 10/512 [01:59<1:39:40, 11.91s/it]
data 42:   4%|▍         | 20/512 [04:04<1:40:54, 12.31s/it]
data 42:   6%|▌         | 30/512 [10:53<3:23:24, 25.32s/it]
data 42:   8%|▊         | 40/512 [12:27<2:29:52, 19.05s/it]
data 42:  10%|▉         | 50/512 [14:13<2:03:11, 16.00s/it]
data 42:  12%|█▏        | 60/512 [16:05<1:48:14, 14.37s/it]
data 42:  14%|█▎        | 70/512 [17:55<1:37:40, 13.26s/it]
data 42:  14%|█▎        | 70/512 [18:44<1:58:20, 16.06s/it]
INFO:root:函数头: 
    @staticmethod
    def _canned_policy(resource, expires):

INFO:root:目标函数体: 
        
        policy = ('{"Statement":[{"Resource":"%(resource)s",'
                  '"Condition":{"DateLessThan":{"AWS:EpochTime":'
                  '%(expires)s}}}]}' % locals())
        return policy

INFO:root:生成结果: 
        policy = {
            "Statement": [
                {
                    "Effect": "Allow",
                    "Action": "cloudfront:GetObject",
                    "Resource": resource,
                    "Condition": {
                        "DateLessThan": {
                            "AWS:EpochTime": expires
                        }
                    }
                }
            ]
        }
        return json.dumps(policy)


INFO:root:----------------------------------------
INFO:root:max length: 9724
INFO:root:max position: 23186
INFO:root:target_namespace: boto.boto<folder>.cloudfront<folder>.distribution<file>.Distribution<class>._canned_policy<func>
INFO:root:****************************************

data 42:   0%|          | 0/512 [00:00<?, ?it/s]
data 42:   2%|▏         | 10/512 [01:52<1:34:28, 11.29s/it]
data 42:   4%|▍         | 20/512 [03:39<1:29:39, 10.93s/it]
data 42:   6%|▌         | 30/512 [05:28<1:27:41, 10.91s/it]
data 42:   8%|▊         | 40/512 [30:11<8:32:37, 65.16s/it]
data 42:  10%|▉         | 50/512 [31:50<5:48:11, 45.22s/it]
data 42:  12%|█▏        | 60/512 [33:46<4:14:35, 33.80s/it]
data 42:  12%|█▏        | 60/512 [35:37<4:28:23, 35.63s/it]
INFO:root:函数头: 
    @staticmethod
    def _canned_policy(resource, expires):

INFO:root:目标函数体: 
        
        policy = ('{"Statement":[{"Resource":"%(resource)s",'
                  '"Condition":{"DateLessThan":{"AWS:EpochTime":'
                  '%(expires)s}}}]}' % locals())
        return policy

INFO:root:生成结果: 
        return json.dumps({
            "Statement": [
                {
                    "Effect": "Allow",
                    "Action": "cloudfront:GetObject",
                    "Resource": resource,
                    "Condition": {
                        "DateLessThan": {
                            "AWS:EpochTime": expires
                        }
                    }
                }
            ]
        })

INFO:root:----------------------------------------
INFO:root:max length: 10165
INFO:root:max position: 22091
INFO:root:target_namespace: boto.boto<folder>.cloudfront<folder>.distribution<file>.Distribution<class>._canned_policy<func>
INFO:root:****************************************

data 42:   0%|          | 0/512 [00:00<?, ?it/s]
data 42:   2%|▏         | 10/512 [01:51<1:33:31, 11.18s/it]
data 42:   4%|▍         | 20/512 [03:32<1:26:19, 10.53s/it]
data 42:   6%|▌         | 30/512 [05:23<1:26:50, 10.81s/it]
data 42:   8%|▊         | 40/512 [06:58<1:20:40, 10.26s/it]
data 42:   8%|▊         | 40/512 [08:21<1:38:39, 12.54s/it]
INFO:root:函数头: 
    @staticmethod
    def _canned_policy(resource, expires):

INFO:root:目标函数体: 
        
        policy = ('{"Statement":[{"Resource":"%(resource)s",'
                  '"Condition":{"DateLessThan":{"AWS:EpochTime":'
                  '%(expires)s}}}]}' % locals())
        return policy

INFO:root:生成结果: 
        policy = '{"Statement":[{"Resource":"%(resource)s","Condition":{"DateLessThan":{"AWS:EpochTime":%(expires)s}}}]}' % {'resource': resource, 'expires': expires}
        return policy

INFO:root:----------------------------------------
INFO:root:max length: 9924
INFO:root:max position: 20150
INFO:root:target_namespace: boto.boto<folder>.cloudfront<folder>.distribution<file>.Distribution<class>._canned_policy<func>
INFO:root:****************************************
INFO:root:--------data 43--------

data 43:   0%|          | 0/512 [00:00<?, ?it/s]
data 43:   2%|▏         | 10/512 [01:55<1:36:35, 11.54s/it]
data 43:   4%|▍         | 20/512 [03:49<1:33:52, 11.45s/it]
data 43:   4%|▍         | 20/512 [04:51<1:59:31, 14.58s/it]
INFO:root:函数头: 
    def escape(self, p):

INFO:root:目标函数体: 
        
        if not p[0] == "/":
            p = "/%s" % p
        return urllib.parse.quote(p, safe = "/*")

INFO:root:生成结果: 
        if not p.startswith('/'):
            p = '/' + p
        return urllib.quote_plus(p)


INFO:root:----------------------------------------
INFO:root:max length: 8280
INFO:root:max position: 17476
INFO:root:target_namespace: boto.boto<folder>.cloudfront<folder>.invalidation<file>.InvalidationBatch<class>.escape<func>
INFO:root:****************************************

data 43:   0%|          | 0/512 [00:00<?, ?it/s]
data 43:   2%|▏         | 10/512 [01:50<1:32:15, 11.03s/it]
data 43:   4%|▍         | 20/512 [03:33<1:27:13, 10.64s/it]
data 43:   6%|▌         | 30/512 [05:28<1:28:32, 11.02s/it]
data 43:   6%|▌         | 30/512 [06:11<1:39:25, 12.38s/it]
INFO:root:函数头: 
    def escape(self, p):

INFO:root:目标函数体: 
        
        if not p[0] == "/":
            p = "/%s" % p
        return urllib.parse.quote(p, safe = "/*")

INFO:root:生成结果: 
        if not p.startswith('/'):
            p = '/' + p
        return urllib.quote(p.encode('utf-8'), safe='/*')


INFO:root:----------------------------------------
INFO:root:max length: 8517
INFO:root:max position: 20074
INFO:root:target_namespace: boto.boto<folder>.cloudfront<folder>.invalidation<file>.InvalidationBatch<class>.escape<func>
INFO:root:****************************************

data 43:   0%|          | 0/512 [00:00<?, ?it/s]
data 43:   2%|▏         | 10/512 [01:42<1:25:48, 10.26s/it]
data 43:   4%|▍         | 20/512 [03:30<1:26:28, 10.55s/it]
data 43:   4%|▍         | 20/512 [05:17<2:10:10, 15.88s/it]
INFO:root:函数头: 
    def escape(self, p):

INFO:root:目标函数体: 
        
        if not p[0] == "/":
            p = "/%s" % p
        return urllib.parse.quote(p, safe = "/*")

INFO:root:生成结果: 
        if not p.startswith('/'):
            p = '/' + p
        return urllib.quote(p.encode('utf-8'))

INFO:root:----------------------------------------
INFO:root:max length: 8348
INFO:root:max position: 19512
INFO:root:target_namespace: boto.boto<folder>.cloudfront<folder>.invalidation<file>.InvalidationBatch<class>.escape<func>
INFO:root:****************************************

data 43:   0%|          | 0/512 [00:00<?, ?it/s]
data 43:   2%|▏         | 10/512 [02:42<2:16:15, 16.29s/it]
data 43:   4%|▍         | 20/512 [06:31<2:45:03, 20.13s/it]
data 43:   4%|▍         | 20/512 [07:14<2:58:18, 21.74s/it]
INFO:root:函数头: 
    def escape(self, p):

INFO:root:目标函数体: 
        
        if not p[0] == "/":
            p = "/%s" % p
        return urllib.parse.quote(p, safe = "/*")

INFO:root:生成结果: 
        if not p.startswith('/'):
            p = '/' + p
        return urllib.quote_plus(p)




INFO:root:----------------------------------------
INFO:root:max length: 8224
INFO:root:max position: 19335
INFO:root:target_namespace: boto.boto<folder>.cloudfront<folder>.invalidation<file>.InvalidationBatch<class>.escape<func>
INFO:root:****************************************

data 43:   0%|          | 0/512 [00:00<?, ?it/s]
data 43:   2%|▏         | 10/512 [01:43<1:26:30, 10.34s/it]
data 43:   4%|▍         | 20/512 [03:25<1:24:04, 10.25s/it]
data 43:   4%|▍         | 20/512 [04:30<1:50:43, 13.50s/it]
INFO:root:函数头: 
    def escape(self, p):

INFO:root:目标函数体: 
        
        if not p[0] == "/":
            p = "/%s" % p
        return urllib.parse.quote(p, safe = "/*")

INFO:root:生成结果: 
        if not p.startswith('/'):
            p = '/' + p
        return urllib.quote(p)

INFO:root:----------------------------------------
INFO:root:max length: 7885
INFO:root:max position: 15376
INFO:root:target_namespace: boto.boto<folder>.cloudfront<folder>.invalidation<file>.InvalidationBatch<class>.escape<func>
INFO:root:****************************************
INFO:root:--------data 44--------

data 44:   0%|          | 0/512 [00:00<?, ?it/s]
data 44:   2%|▏         | 10/512 [00:23<19:41,  2.35s/it]
data 44:   4%|▍         | 20/512 [00:43<17:39,  2.15s/it]
data 44:   6%|▌         | 30/512 [01:03<16:36,  2.07s/it]
data 44:   6%|▌         | 30/512 [01:16<20:25,  2.54s/it]
INFO:root:函数头: 
def get_status_code(resp, start=9, stop=12):

INFO:root:目标函数体: 
    try:
        code = int(resp[start:stop])
    except ValueError:
        return 400  # Bad Request
    else:
        return code

INFO:root:生成结果: 
    try:
        status_code = int(resp[start:stop])
    except (ValueError, TypeError):
        status_code = 400
    return status_code




INFO:root:----------------------------------------
INFO:root:max length: 5983
INFO:root:max position: 5983
INFO:root:target_namespace: proxybroker.proxybroker<folder>.utils<file>.get_status_code<func>
INFO:root:****************************************

data 44:   0%|          | 0/512 [00:00<?, ?it/s]
data 44:   2%|▏         | 10/512 [00:20<16:55,  2.02s/it]
data 44:   4%|▍         | 20/512 [00:41<16:51,  2.06s/it]
data 44:   4%|▍         | 20/512 [00:55<22:52,  2.79s/it]
INFO:root:函数头: 
def get_status_code(resp, start=9, stop=12):

INFO:root:目标函数体: 
    try:
        code = int(resp[start:stop])
    except ValueError:
        return 400  # Bad Request
    else:
        return code

INFO:root:生成结果: 
    try:
        return int(resp[start stop])
    except (ValueError, IndexError):
        return 400


INFO:root:----------------------------------------
INFO:root:max length: 5973
INFO:root:max position: 5973
INFO:root:target_namespace: proxybroker.proxybroker<folder>.utils<file>.get_status_code<func>
INFO:root:****************************************

data 44:   0%|          | 0/512 [00:00<?, ?it/s]
data 44:   2%|▏         | 10/512 [00:16<14:09,  1.69s/it]
data 44:   4%|▍         | 20/512 [02:40<1:14:44,  9.12s/it]
data 44:   6%|▌         | 30/512 [02:59<47:05,  5.86s/it]  
data 44:   6%|▌         | 30/512 [03:11<51:21,  6.39s/it]
INFO:root:函数头: 
def get_status_code(resp, start=9, stop=12):

INFO:root:目标函数体: 
    try:
        code = int(resp[start:stop])
    except ValueError:
        return 400  # Bad Request
    else:
        return code

INFO:root:生成结果: 
    try:
        status_code = int(resp[start stop])
    except (ValueError, IndexError):
        status_code = 400
    return status_code




INFO:root:----------------------------------------
INFO:root:max length: 5982
INFO:root:max position: 5982
INFO:root:target_namespace: proxybroker.proxybroker<folder>.utils<file>.get_status_code<func>
INFO:root:****************************************

data 44:   0%|          | 0/512 [00:00<?, ?it/s]
data 44:   2%|▏         | 10/512 [00:16<13:55,  1.66s/it]
data 44:   4%|▍         | 20/512 [00:35<14:54,  1.82s/it]
data 44:   4%|▍         | 20/512 [00:51<21:01,  2.56s/it]
INFO:root:函数头: 
def get_status_code(resp, start=9, stop=12):

INFO:root:目标函数体: 
    try:
        code = int(resp[start:stop])
    except ValueError:
        return 400  # Bad Request
    else:
        return code

INFO:root:生成结果: 
    try:
        return int(resp[start:stop])
    except (ValueError, IndexError):
        return 400




INFO:root:----------------------------------------
INFO:root:max length: 5974
INFO:root:max position: 5974
INFO:root:target_namespace: proxybroker.proxybroker<folder>.utils<file>.get_status_code<func>
INFO:root:****************************************

data 44:   0%|          | 0/512 [00:00<?, ?it/s]
data 44:   2%|▏         | 10/512 [00:16<14:05,  1.68s/it]
data 44:   4%|▍         | 20/512 [00:36<15:02,  1.83s/it]
data 44:   4%|▍         | 20/512 [00:50<20:46,  2.53s/it]
INFO:root:函数头: 
def get_status_code(resp, start=9, stop=12):

INFO:root:目标函数体: 
    try:
        code = int(resp[start:stop])
    except ValueError:
        return 400  # Bad Request
    else:
        return code

INFO:root:生成结果: 
    try:
        return int(resp[start stop])
    except (ValueError, IndexError):
        return 400


INFO:root:----------------------------------------
INFO:root:max length: 5973
INFO:root:max position: 5973
INFO:root:target_namespace: proxybroker.proxybroker<folder>.utils<file>.get_status_code<func>
INFO:root:****************************************
INFO:root:--------data 45--------

data 45:   0%|          | 0/512 [00:00<?, ?it/s]
data 45:   2%|▏         | 10/512 [01:55<1:36:50, 11.57s/it]
data 45:   4%|▍         | 20/512 [03:54<1:36:30, 11.77s/it]
data 45:   6%|▌         | 30/512 [06:02<1:38:06, 12.21s/it]
data 45:   6%|▌         | 30/512 [07:45<2:04:35, 15.51s/it]
INFO:root:函数头: 
def scope_to_list(scope):

INFO:root:目标函数体: 
    
    if isinstance(scope, (tuple, list, set)):
        return [to_unicode(s) for s in scope]
    elif scope is None:
        return None
    return scope.strip().split()

INFO:root:生成结果: 
    if scope is None:
        return scope
    if isinstance(scope, (tuple, list)):
        return [to_unicode(s) for s in scope]
    return scope.split()




INFO:root:----------------------------------------
INFO:root:max length: 6207
INFO:root:max position: 9480
INFO:root:target_namespace: Authlib.authlib<folder>.oauth2<folder>.rfc6749<folder>.util<file>.scope_to_list<func>
INFO:root:****************************************

data 45:   0%|          | 0/512 [00:00<?, ?it/s]
data 45:   2%|▏         | 10/512 [01:49<1:31:55, 10.99s/it]
data 45:   4%|▍         | 20/512 [03:52<1:36:24, 11.76s/it]
data 45:   6%|▌         | 30/512 [06:04<1:39:46, 12.42s/it]
data 45:   8%|▊         | 40/512 [08:06<1:36:52, 12.32s/it]
data 45:   8%|▊         | 40/512 [08:57<1:45:38, 13.43s/it]
INFO:root:函数头: 
def scope_to_list(scope):

INFO:root:目标函数体: 
    
    if isinstance(scope, (tuple, list, set)):
        return [to_unicode(s) for s in scope]
    elif scope is None:
        return None
    return scope.strip().split()

INFO:root:生成结果: 
    if scope is None:
        return None
    if isinstance(scope, (tuple, list, set)):
        return [to_unicode(s) for s in scope]
    return to_unicode(scope).split()




INFO:root:----------------------------------------
INFO:root:max length: 7089
INFO:root:max position: 9870
INFO:root:target_namespace: Authlib.authlib<folder>.oauth2<folder>.rfc6749<folder>.util<file>.scope_to_list<func>
INFO:root:****************************************

data 45:   0%|          | 0/512 [00:00<?, ?it/s]
data 45:   2%|▏         | 10/512 [01:58<1:39:08, 11.85s/it]
data 45:   4%|▍         | 20/512 [03:59<1:38:23, 12.00s/it]
data 45:   6%|▌         | 30/512 [06:06<1:38:49, 12.30s/it]
data 45:   8%|▊         | 40/512 [08:07<1:36:22, 12.25s/it]
data 45:   8%|▊         | 40/512 [09:00<1:46:15, 13.51s/it]
INFO:root:函数头: 
def scope_to_list(scope):

INFO:root:目标函数体: 
    
    if isinstance(scope, (tuple, list, set)):
        return [to_unicode(s) for s in scope]
    elif scope is None:
        return None
    return scope.strip().split()

INFO:root:生成结果: 
    if scope is None:
        return None
    if isinstance(scope, (tuple, list, set)):
        return [to_unicode(s) for s in scope]
    return to_unicode(scope).split()




INFO:root:----------------------------------------
INFO:root:max length: 6586
INFO:root:max position: 9855
INFO:root:target_namespace: Authlib.authlib<folder>.oauth2<folder>.rfc6749<folder>.util<file>.scope_to_list<func>
INFO:root:****************************************

data 45:   0%|          | 0/512 [00:00<?, ?it/s]
data 45:   2%|▏         | 10/512 [03:56<3:17:40, 23.63s/it]
data 45:   4%|▍         | 20/512 [05:58<2:18:36, 16.90s/it]
data 45:   6%|▌         | 30/512 [08:04<2:00:10, 14.96s/it]
data 45:   8%|▊         | 40/512 [10:10<1:50:14, 14.01s/it]
data 45:   8%|▊         | 40/512 [10:57<2:09:14, 16.43s/it]
INFO:root:函数头: 
def scope_to_list(scope):

INFO:root:目标函数体: 
    
    if isinstance(scope, (tuple, list, set)):
        return [to_unicode(s) for s in scope]
    elif scope is None:
        return None
    return scope.strip().split()

INFO:root:生成结果: 
    if scope is None:
        return None
    if isinstance(scope, (tuple, list, set)):
        return [to_unicode(s) for s in scope]
    return to_unicode(scope).split()




INFO:root:----------------------------------------
INFO:root:max length: 7333
INFO:root:max position: 10266
INFO:root:target_namespace: Authlib.authlib<folder>.oauth2<folder>.rfc6749<folder>.util<file>.scope_to_list<func>
INFO:root:****************************************

data 45:   0%|          | 0/512 [00:00<?, ?it/s]
data 45:   2%|▏         | 10/512 [01:54<1:35:35, 11.43s/it]
data 45:   4%|▍         | 20/512 [03:50<1:34:51, 11.57s/it]
data 45:   6%|▌         | 30/512 [06:01<1:38:29, 12.26s/it]
data 45:   6%|▌         | 30/512 [07:49<2:05:51, 15.67s/it]
INFO:root:函数头: 
def scope_to_list(scope):

INFO:root:目标函数体: 
    
    if isinstance(scope, (tuple, list, set)):
        return [to_unicode(s) for s in scope]
    elif scope is None:
        return None
    return scope.strip().split()

INFO:root:生成结果: 
    if scope is None:
        return None
    if isinstance(scope, (tuple, list)):
        return [to_unicode(s) for s in scope]
    return scope.split()




INFO:root:----------------------------------------
INFO:root:max length: 6429
INFO:root:max position: 10059
INFO:root:target_namespace: Authlib.authlib<folder>.oauth2<folder>.rfc6749<folder>.util<file>.scope_to_list<func>
INFO:root:****************************************
INFO:root:--------data 46--------

data 46:   0%|          | 0/512 [00:00<?, ?it/s]
data 46:   2%|▏         | 10/512 [00:19<16:28,  1.97s/it]
data 46:   4%|▍         | 20/512 [00:35<14:16,  1.74s/it]
data 46:   6%|▌         | 30/512 [00:51<13:22,  1.67s/it]
data 46:   8%|▊         | 40/512 [01:07<12:49,  1.63s/it]
data 46:   8%|▊         | 40/512 [01:14<14:36,  1.86s/it]
INFO:root:函数头: 
def to_unicode(x, charset='utf-8', errors='strict'):

INFO:root:目标函数体: 
    if x is None or isinstance(x, str):
        return x
    if isinstance(x, bytes):
        return x.decode(charset, errors)
    return str(x)

INFO:root:生成结果: 
    if x is None:
        return None
    if isinstance(x, str):
        return x
    if isinstance(x, bytes):
        return x.decode(charset, errors)
    return str(x)




INFO:root:----------------------------------------
INFO:root:max length: 2968
INFO:root:max position: 2968
INFO:root:target_namespace: Authlib.authlib<folder>.common<folder>.encoding<file>.to_unicode<func>
INFO:root:****************************************

data 46:   0%|          | 0/512 [00:00<?, ?it/s]
data 46:   2%|▏         | 10/512 [00:15<13:17,  1.59s/it]
data 46:   4%|▍         | 20/512 [00:31<12:57,  1.58s/it]
data 46:   6%|▌         | 30/512 [00:47<12:53,  1.61s/it]
data 46:   8%|▊         | 40/512 [01:04<12:41,  1.61s/it]
data 46:   8%|▊         | 40/512 [01:11<14:00,  1.78s/it]
INFO:root:函数头: 
def to_unicode(x, charset='utf-8', errors='strict'):

INFO:root:目标函数体: 
    if x is None or isinstance(x, str):
        return x
    if isinstance(x, bytes):
        return x.decode(charset, errors)
    return str(x)

INFO:root:生成结果: 
    if x is None:
        return None
    if isinstance(x, str):
        return x
    if isinstance(x, bytes):
        return x.decode(charset, errors)
    return str(x)




INFO:root:----------------------------------------
INFO:root:max length: 2968
INFO:root:max position: 2968
INFO:root:target_namespace: Authlib.authlib<folder>.common<folder>.encoding<file>.to_unicode<func>
INFO:root:****************************************

data 46:   0%|          | 0/512 [00:00<?, ?it/s]
data 46:   2%|▏         | 10/512 [00:13<11:05,  1.33s/it]
data 46:   4%|▍         | 20/512 [00:29<12:04,  1.47s/it]
data 46:   6%|▌         | 30/512 [00:44<12:00,  1.50s/it]
data 46:   8%|▊         | 40/512 [01:01<12:33,  1.60s/it]
data 46:   8%|▊         | 40/512 [01:06<13:09,  1.67s/it]
INFO:root:函数头: 
def to_unicode(x, charset='utf-8', errors='strict'):

INFO:root:目标函数体: 
    if x is None or isinstance(x, str):
        return x
    if isinstance(x, bytes):
        return x.decode(charset, errors)
    return str(x)

INFO:root:生成结果: 
    if x is None:
        return None
    if isinstance(x, str):
        return x
    if isinstance(x, bytes):
        return x.decode(charset, errors)
    return str(x)




INFO:root:----------------------------------------
INFO:root:max length: 2968
INFO:root:max position: 2968
INFO:root:target_namespace: Authlib.authlib<folder>.common<folder>.encoding<file>.to_unicode<func>
INFO:root:****************************************

data 46:   0%|          | 0/512 [00:00<?, ?it/s]
data 46:   2%|▏         | 10/512 [00:15<12:59,  1.55s/it]
data 46:   4%|▍         | 20/512 [00:31<12:49,  1.56s/it]
data 46:   6%|▌         | 30/512 [00:47<12:51,  1.60s/it]
data 46:   8%|▊         | 40/512 [01:04<12:56,  1.65s/it]
data 46:   8%|▊         | 40/512 [01:10<13:47,  1.75s/it]
INFO:root:函数头: 
def to_unicode(x, charset='utf-8', errors='strict'):

INFO:root:目标函数体: 
    if x is None or isinstance(x, str):
        return x
    if isinstance(x, bytes):
        return x.decode(charset, errors)
    return str(x)

INFO:root:生成结果: 
    if x is None:
        return None
    if isinstance(x, str):
        return x
    if isinstance(x, bytes):
        return x.decode(charset, errors)
    return str(x)




INFO:root:----------------------------------------
INFO:root:max length: 2968
INFO:root:max position: 2968
INFO:root:target_namespace: Authlib.authlib<folder>.common<folder>.encoding<file>.to_unicode<func>
INFO:root:****************************************

data 46:   0%|          | 0/512 [00:00<?, ?it/s]
data 46:   2%|▏         | 10/512 [00:15<12:56,  1.55s/it]
data 46:   4%|▍         | 20/512 [00:31<12:44,  1.55s/it]
data 46:   6%|▌         | 30/512 [00:46<12:29,  1.55s/it]
data 46:   8%|▊         | 40/512 [01:02<12:17,  1.56s/it]
data 46:   8%|▊         | 40/512 [01:09<13:39,  1.74s/it]
INFO:root:函数头: 
def to_unicode(x, charset='utf-8', errors='strict'):

INFO:root:目标函数体: 
    if x is None or isinstance(x, str):
        return x
    if isinstance(x, bytes):
        return x.decode(charset, errors)
    return str(x)

INFO:root:生成结果: 
    if x is None:
        return None
    if isinstance(x, str):
        return x
    if isinstance(x, bytes):
        return x.decode(charset, errors)
    return str(x)




INFO:root:----------------------------------------
INFO:root:max length: 2968
INFO:root:max position: 2968
INFO:root:target_namespace: Authlib.authlib<folder>.common<folder>.encoding<file>.to_unicode<func>
INFO:root:****************************************
INFO:root:--------data 47--------

data 47:   0%|          | 0/512 [00:00<?, ?it/s]
data 47:   2%|▏         | 10/512 [00:16<13:36,  1.63s/it]
data 47:   4%|▍         | 20/512 [00:31<12:49,  1.56s/it]
data 47:   6%|▌         | 30/512 [00:45<11:49,  1.47s/it]
data 47:   8%|▊         | 40/512 [01:02<12:24,  1.58s/it]
data 47:  10%|▉         | 50/512 [01:17<11:58,  1.56s/it]
data 47:  12%|█▏        | 60/512 [01:31<11:17,  1.50s/it]
data 47:  14%|█▎        | 70/512 [01:47<11:20,  1.54s/it]
data 47:  16%|█▌        | 80/512 [02:02<10:50,  1.51s/it]
data 47:  16%|█▌        | 80/512 [02:16<12:14,  1.70s/it]
INFO:root:函数头: 
def to_bytes(x, charset='utf-8', errors='strict'):

INFO:root:目标函数体: 
    if x is None:
        return None
    if isinstance(x, bytes):
        return x
    if isinstance(x, str):
        return x.encode(charset, errors)
    if isinstance(x, (int, float)):
        return str(x).encode(charset, errors)
    return bytes(x)

INFO:root:生成结果: 
    if x is None:
        return None
    if isinstance(x, bytes):
        return x
    if isinstance(x, str):
        return x.encode(charset, errors)
    if isinstance(x, int):
        return str(x).encode(charset, errors)
    if isinstance(x, float):
        return str(x).encode(charset, errors)
    raise TypeError(f'Unsupported type: {type(x)}')



INFO:root:----------------------------------------
INFO:root:max length: 2912
INFO:root:max position: 2912
INFO:root:target_namespace: Authlib.authlib<folder>.common<folder>.encoding<file>.to_bytes<func>
INFO:root:****************************************

data 47:   0%|          | 0/512 [00:00<?, ?it/s]
data 47:   2%|▏         | 10/512 [00:13<10:53,  1.30s/it]
data 47:   4%|▍         | 20/512 [00:28<11:49,  1.44s/it]
data 47:   6%|▌         | 30/512 [00:43<11:55,  1.48s/it]
data 47:   8%|▊         | 40/512 [00:58<11:46,  1.50s/it]
data 47:  10%|▉         | 50/512 [01:14<11:42,  1.52s/it]
data 47:  12%|█▏        | 60/512 [01:30<11:33,  1.53s/it]
data 47:  14%|█▎        | 70/512 [01:45<11:14,  1.53s/it]
data 47:  16%|█▌        | 80/512 [02:01<11:12,  1.56s/it]
data 47:  16%|█▌        | 80/512 [02:13<12:00,  1.67s/it]
INFO:root:函数头: 
def to_bytes(x, charset='utf-8', errors='strict'):

INFO:root:目标函数体: 
    if x is None:
        return None
    if isinstance(x, bytes):
        return x
    if isinstance(x, str):
        return x.encode(charset, errors)
    if isinstance(x, (int, float)):
        return str(x).encode(charset, errors)
    return bytes(x)

INFO:root:生成结果: 
    if x is None:
        return None
    if isinstance(x, bytes):
        return x
    if isinstance(x, str):
        return x.encode(charset, errors)
    if isinstance(x, int):
        return str(x).encode(charset, errors)
    if isinstance(x, float):
        return str(x).encode(charset, errors)
    raise TypeError(f"Unsupported type: {type(x)}")




INFO:root:----------------------------------------
INFO:root:max length: 2912
INFO:root:max position: 2912
INFO:root:target_namespace: Authlib.authlib<folder>.common<folder>.encoding<file>.to_bytes<func>
INFO:root:****************************************

data 47:   0%|          | 0/512 [00:00<?, ?it/s]
data 47:   2%|▏         | 10/512 [00:13<10:56,  1.31s/it]
data 47:   4%|▍         | 20/512 [00:28<11:46,  1.44s/it]
data 47:   6%|▌         | 30/512 [00:43<11:55,  1.49s/it]
data 47:   8%|▊         | 40/512 [00:58<11:44,  1.49s/it]
data 47:  10%|▉         | 50/512 [01:13<11:30,  1.49s/it]
data 47:  12%|█▏        | 60/512 [01:28<11:16,  1.50s/it]
data 47:  14%|█▎        | 70/512 [01:44<11:07,  1.51s/it]
data 47:  16%|█▌        | 80/512 [01:59<10:59,  1.53s/it]
data 47:  18%|█▊        | 90/512 [02:15<10:44,  1.53s/it]
data 47:  18%|█▊        | 90/512 [02:15<10:37,  1.51s/it]
INFO:root:函数头: 
def to_bytes(x, charset='utf-8', errors='strict'):

INFO:root:目标函数体: 
    if x is None:
        return None
    if isinstance(x, bytes):
        return x
    if isinstance(x, str):
        return x.encode(charset, errors)
    if isinstance(x, (int, float)):
        return str(x).encode(charset, errors)
    return bytes(x)

INFO:root:生成结果: 
    if x is None:
        return None
    elif isinstance(x, bytes):
        return x
    elif isinstance(x, str):
        return x.encode(charset, errors)
    elif isinstance(x, int):
        return str(x).encode(charset, errors)
    elif isinstance(x, float):
        return str(x).encode(charset, errors)
    else:
        raise TypeError(f"Unsupported type: {type(x)}")



INFO:root:----------------------------------------
INFO:root:max length: 2915
INFO:root:max position: 2915
INFO:root:target_namespace: Authlib.authlib<folder>.common<folder>.encoding<file>.to_bytes<func>
INFO:root:****************************************

data 47:   0%|          | 0/512 [00:00<?, ?it/s]
data 47:   2%|▏         | 10/512 [00:13<11:41,  1.40s/it]
data 47:   4%|▍         | 20/512 [00:28<11:49,  1.44s/it]
data 47:   6%|▌         | 30/512 [00:44<11:58,  1.49s/it]
data 47:   8%|▊         | 40/512 [00:59<11:51,  1.51s/it]
data 47:  10%|▉         | 50/512 [01:14<11:40,  1.52s/it]
data 47:  12%|█▏        | 60/512 [01:29<11:20,  1.51s/it]
data 47:  14%|█▎        | 70/512 [01:44<11:07,  1.51s/it]
data 47:  16%|█▌        | 80/512 [02:00<10:58,  1.52s/it]
data 47:  18%|█▊        | 90/512 [02:16<10:47,  1.53s/it]
data 47:  18%|█▊        | 90/512 [02:16<10:41,  1.52s/it]
INFO:root:函数头: 
def to_bytes(x, charset='utf-8', errors='strict'):

INFO:root:目标函数体: 
    if x is None:
        return None
    if isinstance(x, bytes):
        return x
    if isinstance(x, str):
        return x.encode(charset, errors)
    if isinstance(x, (int, float)):
        return str(x).encode(charset, errors)
    return bytes(x)

INFO:root:生成结果: 
    if x is None:
        return None
    elif isinstance(x, bytes):
        return x
    elif isinstance(x, str):
        return x.encode(charset, errors)
    elif isinstance(x, int):
        return str(x).encode(charset, errors)
    elif isinstance(x, float):
        return str(x).encode(charset, errors)
    else:
        raise TypeError(f"Unsupported type: {type(x)}")




INFO:root:----------------------------------------
INFO:root:max length: 2915
INFO:root:max position: 2915
INFO:root:target_namespace: Authlib.authlib<folder>.common<folder>.encoding<file>.to_bytes<func>
INFO:root:****************************************

data 47:   0%|          | 0/512 [00:00<?, ?it/s]
data 47:   2%|▏         | 10/512 [00:14<12:26,  1.49s/it]
data 47:   4%|▍         | 20/512 [00:28<11:27,  1.40s/it]
data 47:   6%|▌         | 30/512 [00:43<11:42,  1.46s/it]
data 47:   8%|▊         | 40/512 [00:58<11:43,  1.49s/it]
data 47:  10%|▉         | 50/512 [01:14<11:32,  1.50s/it]
data 47:  12%|█▏        | 60/512 [01:29<11:20,  1.51s/it]
data 47:  14%|█▎        | 70/512 [01:42<10:44,  1.46s/it]
data 47:  16%|█▌        | 80/512 [01:59<11:05,  1.54s/it]
data 47:  16%|█▌        | 80/512 [02:09<11:39,  1.62s/it]
INFO:root:函数头: 
def to_bytes(x, charset='utf-8', errors='strict'):

INFO:root:目标函数体: 
    if x is None:
        return None
    if isinstance(x, bytes):
        return x
    if isinstance(x, str):
        return x.encode(charset, errors)
    if isinstance(x, (int, float)):
        return str(x).encode(charset, errors)
    return bytes(x)

INFO:root:生成结果: 
    if x is None:
        return None
    if isinstance(x, bytes):
        return x
    if isinstance(x, str):
        return x.encode(charset, errors)
    if isinstance(x, int):
        return str(x).encode(charset, errors)
    if isinstance(x, float):
        return str(x).encode(charset, errors)
    raise TypeError(f'Unsupported type {type(x)}')



INFO:root:----------------------------------------
INFO:root:max length: 2911
INFO:root:max position: 2911
INFO:root:target_namespace: Authlib.authlib<folder>.common<folder>.encoding<file>.to_bytes<func>
INFO:root:****************************************
INFO:root:已生成47条结果
INFO:root:--------data 48--------

data 48:   0%|          | 0/512 [00:00<?, ?it/s]
data 48:   2%|▏         | 10/512 [00:19<16:40,  1.99s/it]
data 48:   4%|▍         | 20/512 [00:39<16:10,  1.97s/it]
data 48:   4%|▍         | 20/512 [00:54<22:29,  2.74s/it]
INFO:root:函数头: 
def urlsafe_b64decode(s):

INFO:root:目标函数体: 
    s += b'=' * (-len(s) % 4)
    return base64.urlsafe_b64decode(s)

INFO:root:生成结果: 
    s += '=' * (len(s) % 4)
    return base64.urlsafe_b64decode(s)




INFO:root:----------------------------------------
INFO:root:max length: 3240
INFO:root:max position: 3240
INFO:root:target_namespace: Authlib.authlib<folder>.common<folder>.encoding<file>.urlsafe_b64decode<func>
INFO:root:****************************************

data 48:   0%|          | 0/512 [00:00<?, ?it/s]
data 48:   2%|▏         | 10/512 [00:18<15:53,  1.90s/it]
data 48:   2%|▏         | 10/512 [00:38<32:18,  3.86s/it]
INFO:root:函数头: 
def urlsafe_b64decode(s):

INFO:root:目标函数体: 
    s += b'=' * (-len(s) % 4)
    return base64.urlsafe_b64decode(s)

INFO:root:生成结果: 
    s = s.rstrip('=')
    return base64.b64decode(s)




INFO:root:----------------------------------------
INFO:root:max length: 3232
INFO:root:max position: 3232
INFO:root:target_namespace: Authlib.authlib<folder>.common<folder>.encoding<file>.urlsafe_b64decode<func>
INFO:root:****************************************

data 48:   0%|          | 0/512 [00:00<?, ?it/s]
data 48:   2%|▏         | 10/512 [00:16<14:11,  1.70s/it]
data 48:   2%|▏         | 10/512 [00:36<30:14,  3.61s/it]
INFO:root:函数头: 
def urlsafe_b64decode(s):

INFO:root:目标函数体: 
    s += b'=' * (-len(s) % 4)
    return base64.urlsafe_b64decode(s)

INFO:root:生成结果: 
    s = s.rstrip('=')
    return base64.b64decode(s)




INFO:root:----------------------------------------
INFO:root:max length: 3232
INFO:root:max position: 3232
INFO:root:target_namespace: Authlib.authlib<folder>.common<folder>.encoding<file>.urlsafe_b64decode<func>
INFO:root:****************************************

data 48:   0%|          | 0/512 [00:00<?, ?it/s]
data 48:   2%|▏         | 10/512 [00:18<15:32,  1.86s/it]
data 48:   4%|▍         | 20/512 [00:36<14:57,  1.82s/it]
data 48:   6%|▌         | 30/512 [00:56<15:06,  1.88s/it]
data 48:   6%|▌         | 30/512 [01:14<20:03,  2.50s/it]
INFO:root:函数头: 
def urlsafe_b64decode(s):

INFO:root:目标函数体: 
    s += b'=' * (-len(s) % 4)
    return base64.urlsafe_b64decode(s)

INFO:root:生成结果: 
    s = s.rstrip('=')
    s += '=' * ((len(s) + 3) % 4)
    return base64.urlsafe_b64decode(s)




INFO:root:----------------------------------------
INFO:root:max length: 3251
INFO:root:max position: 3251
INFO:root:target_namespace: Authlib.authlib<folder>.common<folder>.encoding<file>.urlsafe_b64decode<func>
INFO:root:****************************************

data 48:   0%|          | 0/512 [00:00<?, ?it/s]
data 48:   2%|▏         | 10/512 [00:16<13:57,  1.67s/it]
data 48:   4%|▍         | 20/512 [00:36<15:03,  1.84s/it]
data 48:   4%|▍         | 20/512 [00:40<16:25,  2.00s/it]
INFO:root:函数头: 
def urlsafe_b64decode(s):

INFO:root:目标函数体: 
    s += b'=' * (-len(s) % 4)
    return base64.urlsafe_b64decode(s)

INFO:root:生成结果: 
    s = s.rstrip('=')
    return base64.urlsafe_b64decode(s)




INFO:root:----------------------------------------
INFO:root:max length: 3234
INFO:root:max position: 3234
INFO:root:target_namespace: Authlib.authlib<folder>.common<folder>.encoding<file>.urlsafe_b64decode<func>
INFO:root:****************************************
INFO:root:--------data 49--------

data 49:   0%|          | 0/512 [00:00<?, ?it/s]
data 49:   2%|▏         | 10/512 [00:15<13:09,  1.57s/it]
data 49:   4%|▍         | 20/512 [00:27<10:59,  1.34s/it]
data 49:   6%|▌         | 30/512 [00:39<10:23,  1.29s/it]
data 49:   8%|▊         | 40/512 [00:52<10:02,  1.28s/it]
data 49:   8%|▊         | 40/512 [00:54<10:46,  1.37s/it]
INFO:root:函数头: 
def table_exists(conn, table):

INFO:root:目标函数体: 
    return conn.execute(
        ,
        [table],
    ).fetchone()[0]

INFO:root:生成结果: 
    cursor = conn.cursor()
    cursor.execute('SELECT COUNT(*) FROM sqlite_master WHERE type="table" AND name=?', (table,))
    return cursor.fetchone()[0] > 0




INFO:root:----------------------------------------
INFO:root:max length: 3864
INFO:root:max position: 3864
INFO:root:target_namespace: csvs-to-sqlite.csvs_to_sqlite<folder>.utils<file>.table_exists<func>
INFO:root:****************************************

data 49:   0%|          | 0/512 [00:00<?, ?it/s]
data 49:   2%|▏         | 10/512 [00:09<07:41,  1.09it/s]
data 49:   4%|▍         | 20/512 [00:24<10:18,  1.26s/it]
data 49:   6%|▌         | 30/512 [00:36<09:57,  1.24s/it]
data 49:   8%|▊         | 40/512 [00:45<08:46,  1.12s/it]
data 49:  10%|▉         | 50/512 [00:57<08:47,  1.14s/it]
data 49:  12%|█▏        | 60/512 [01:11<09:16,  1.23s/it]
data 49:  14%|█▎        | 70/512 [01:24<09:11,  1.25s/it]
data 49:  16%|█▌        | 80/512 [01:35<08:43,  1.21s/it]
data 49:  18%|█▊        | 90/512 [01:51<09:22,  1.33s/it]
data 49:  20%|█▉        | 100/512 [02:06<09:26,  1.38s/it]
data 49:  21%|██▏       | 110/512 [02:19<09:02,  1.35s/it]
data 49:  23%|██▎       | 120/512 [02:33<08:55,  1.37s/it]
data 49:  25%|██▌       | 130/512 [02:45<08:25,  1.32s/it]
data 49:  27%|██▋       | 140/512 [03:00<08:28,  1.37s/it]
data 49:  29%|██▉       | 150/512 [03:15<08:29,  1.41s/it]
data 49:  29%|██▉       | 150/512 [03:27<08:19,  1.38s/it]
INFO:root:函数头: 
def table_exists(conn, table):

INFO:root:目标函数体: 
    return conn.execute(
        ,
        [table],
    ).fetchone()[0]

INFO:root:生成结果: 
    # Implement the function body based on the provided code prefix and other resources in the current project, without generating any additional content! The current function is located in file csvs_to_sqlite/utils.py, prohibit cyclic calling the current function! You can use resources in the current project, and you MUST write import statements FIRST to call the corresponding resource.
    try:
        # Use SQLite's built-in "sqlite_master" table to check if the table exists
        result = conn.execute(
            'SELECT name FROM sqlite_master WHERE type="table" AND name=?', (table,)
        ).fetchall()
        return len(result) > 0
    except sqlite3.Error as e:
        click.echo("Error checking if table exists: {}".format(e))
        return False


INFO:root:----------------------------------------
INFO:root:max length: 3976
INFO:root:max position: 3983
INFO:root:target_namespace: csvs-to-sqlite.csvs_to_sqlite<folder>.utils<file>.table_exists<func>
INFO:root:****************************************

data 49:   0%|          | 0/512 [00:00<?, ?it/s]
data 49:   2%|▏         | 10/512 [00:13<10:53,  1.30s/it]
data 49:   4%|▍         | 20/512 [00:27<11:22,  1.39s/it]
data 49:   6%|▌         | 30/512 [00:40<10:41,  1.33s/it]
data 49:   6%|▌         | 30/512 [00:52<13:57,  1.74s/it]
INFO:root:函数头: 
def table_exists(conn, table):

INFO:root:目标函数体: 
    return conn.execute(
        ,
        [table],
    ).fetchone()[0]

INFO:root:生成结果: 
    cursor = conn.cursor()
    cursor.execute("SELECT name FROM sqlite_master WHERE type='table' AND name=?", (table,))
    return cursor.fetchone() is not None




INFO:root:----------------------------------------
INFO:root:max length: 3857
INFO:root:max position: 3864
INFO:root:target_namespace: csvs-to-sqlite.csvs_to_sqlite<folder>.utils<file>.table_exists<func>
INFO:root:****************************************

data 49:   0%|          | 0/512 [00:00<?, ?it/s]
data 49:   2%|▏         | 10/512 [00:11<09:19,  1.11s/it]
data 49:   4%|▍         | 20/512 [00:23<09:54,  1.21s/it]
data 49:   6%|▌         | 30/512 [00:38<10:42,  1.33s/it]
data 49:   8%|▊         | 40/512 [00:53<11:01,  1.40s/it]
data 49:   8%|▊         | 40/512 [01:06<13:08,  1.67s/it]
INFO:root:函数头: 
def table_exists(conn, table):

INFO:root:目标函数体: 
    return conn.execute(
        ,
        [table],
    ).fetchone()[0]

INFO:root:生成结果: 
    # Check if the table exists in the database
    cursor = conn.cursor()
    cursor.execute('SELECT name FROM sqlite_master WHERE type="table" AND name=?', (table,))
    return cursor.fetchone() is not None




INFO:root:----------------------------------------
INFO:root:max length: 3869
INFO:root:max position: 3875
INFO:root:target_namespace: csvs-to-sqlite.csvs_to_sqlite<folder>.utils<file>.table_exists<func>
INFO:root:****************************************

data 49:   0%|          | 0/512 [00:00<?, ?it/s]
data 49:   2%|▏         | 10/512 [00:14<12:22,  1.48s/it]
data 49:   4%|▍         | 20/512 [00:28<11:24,  1.39s/it]
data 49:   6%|▌         | 30/512 [00:39<10:21,  1.29s/it]
data 49:   8%|▊         | 40/512 [00:56<11:20,  1.44s/it]
data 49:   8%|▊         | 40/512 [01:00<11:49,  1.50s/it]
INFO:root:函数头: 
def table_exists(conn, table):

INFO:root:目标函数体: 
    return conn.execute(
        ,
        [table],
    ).fetchone()[0]

INFO:root:生成结果: 
    cursor = conn.cursor()
    cursor.execute(
        'SELECT name FROM sqlite_master WHERE type="table" AND name=?', (table,)
    )
    return cursor.fetchone() is not None


INFO:root:----------------------------------------
INFO:root:max length: 3837
INFO:root:max position: 3866
INFO:root:target_namespace: csvs-to-sqlite.csvs_to_sqlite<folder>.utils<file>.table_exists<func>
INFO:root:****************************************
INFO:root:--------data 50--------

data 50:   0%|          | 0/512 [00:00<?, ?it/s]
data 50:   2%|▏         | 10/512 [00:15<12:55,  1.54s/it]
data 50:   4%|▍         | 20/512 [00:31<12:44,  1.55s/it]
data 50:   6%|▌         | 30/512 [00:44<11:42,  1.46s/it]
data 50:   8%|▊         | 40/512 [00:59<11:43,  1.49s/it]
data 50:  10%|▉         | 50/512 [01:15<11:34,  1.50s/it]
data 50:  12%|█▏        | 60/512 [01:30<11:30,  1.53s/it]
data 50:  14%|█▎        | 70/512 [01:44<10:51,  1.47s/it]
data 50:  14%|█▎        | 70/512 [01:56<12:17,  1.67s/it]
INFO:root:函数头: 
    @staticmethod
    def get_tablenames(filename):

INFO:root:目标函数体: 
        
        if not os.path.isfile(filename):
            raise IOError('file %s does not exist' % (filename))
        GET_TABLENAMES = 'SELECT name FROM sqlite_master WHERE type="table"'
        with sqlite3.connect(filename) as conn:
            cursor = conn.execute(GET_TABLENAMES)
            res = cursor.fetchall()

        return [name[0] for name in res]

INFO:root:生成结果: 
        try:
            conn = sqlite3.connect(filename)
            cursor = conn.cursor()
            cursor.execute("SELECT name FROM sqlite_master WHERE type='table'")
            table_names = [row[0] for row in cursor.fetchall()]
            conn.close()
            return table_names
        except sqlite3 IOError as e:
            raise IOError(f'file {filename} does not exist')


INFO:root:----------------------------------------
INFO:root:max length: 1748
INFO:root:max position: 2253
INFO:root:target_namespace: sqlitedict.sqlitedict<file>.SqliteDict<class>.get_tablenames<func>
INFO:root:****************************************

data 50:   0%|          | 0/512 [00:00<?, ?it/s]
data 50:   2%|▏         | 10/512 [00:14<11:58,  1.43s/it]
data 50:   4%|▍         | 20/512 [00:29<12:11,  1.49s/it]
data 50:   6%|▌         | 30/512 [00:42<11:22,  1.42s/it]
data 50:   8%|▊         | 40/512 [00:58<11:30,  1.46s/it]
data 50:  10%|▉         | 50/512 [01:13<11:29,  1.49s/it]
data 50:  12%|█▏        | 60/512 [01:28<11:14,  1.49s/it]
data 50:  14%|█▎        | 70/512 [01:43<11:04,  1.50s/it]
data 50:  16%|█▌        | 80/512 [01:57<10:29,  1.46s/it]
data 50:  18%|█▊        | 90/512 [02:12<10:23,  1.48s/it]
data 50:  20%|█▉        | 100/512 [02:28<10:15,  1.49s/it]
data 50:  21%|██▏       | 110/512 [02:43<10:05,  1.51s/it]
data 50:  23%|██▎       | 120/512 [02:58<09:52,  1.51s/it]
data 50:  25%|██▌       | 130/512 [03:12<09:18,  1.46s/it]
data 50:  25%|██▌       | 130/512 [03:16<09:37,  1.51s/it]
INFO:root:函数头: 
    @staticmethod
    def get_tablenames(filename):

INFO:root:目标函数体: 
        
        if not os.path.isfile(filename):
            raise IOError('file %s does not exist' % (filename))
        GET_TABLENAMES = 'SELECT name FROM sqlite_master WHERE type="table"'
        with sqlite3.connect(filename) as conn:
            cursor = conn.execute(GET_TABLENAMES)
            res = cursor.fetchall()

        return [name[0] for name in res]

INFO:root:生成结果: 
        try:
            # Open the SQLite database file
            conn = sqlite3.connect(filename)
            # Execute the query to retrieve table names
            cursor = conn.execute("SELECT name FROM sqlite_master WHERE type='table'")
            # Fetch all table names from the query result
            table_names = [row[0] for row in cursor.fetchall()]
            # Close the database connection
            conn.close()
            # Return the list of table names
            return table_names
        except sqlite3 OperationalError as e:
            # Handle the case where the database file does not exist
            raise IOError(f'file {filename} does not exist')


INFO:root:----------------------------------------
INFO:root:max length: 1803
INFO:root:max position: 2308
INFO:root:target_namespace: sqlitedict.sqlitedict<file>.SqliteDict<class>.get_tablenames<func>
INFO:root:****************************************

data 50:   0%|          | 0/512 [00:00<?, ?it/s]
data 50:   2%|▏         | 10/512 [00:14<11:58,  1.43s/it]
data 50:   4%|▍         | 20/512 [00:29<12:16,  1.50s/it]
data 50:   6%|▌         | 30/512 [00:43<11:25,  1.42s/it]
data 50:   8%|▊         | 40/512 [00:58<11:29,  1.46s/it]
data 50:  10%|▉         | 50/512 [01:13<11:23,  1.48s/it]
data 50:  12%|█▏        | 60/512 [01:29<11:21,  1.51s/it]
data 50:  14%|█▎        | 70/512 [01:44<11:11,  1.52s/it]
data 50:  16%|█▌        | 80/512 [01:59<10:56,  1.52s/it]
data 50:  18%|█▊        | 90/512 [02:12<10:16,  1.46s/it]
data 50:  20%|█▉        | 100/512 [02:28<10:09,  1.48s/it]
data 50:  21%|██▏       | 110/512 [02:43<09:58,  1.49s/it]
data 50:  23%|██▎       | 120/512 [02:58<09:48,  1.50s/it]
data 50:  25%|██▌       | 130/512 [03:14<09:38,  1.52s/it]
data 50:  27%|██▋       | 140/512 [03:29<09:25,  1.52s/it]
data 50:  27%|██▋       | 140/512 [03:31<09:20,  1.51s/it]
INFO:root:函数头: 
    @staticmethod
    def get_tablenames(filename):

INFO:root:目标函数体: 
        
        if not os.path.isfile(filename):
            raise IOError('file %s does not exist' % (filename))
        GET_TABLENAMES = 'SELECT name FROM sqlite_master WHERE type="table"'
        with sqlite3.connect(filename) as conn:
            cursor = conn.execute(GET_TABLENAMES)
            res = cursor.fetchall()

        return [name[0] for name in res]

INFO:root:生成结果: 
        import sqlite3

        try:
            # Connect to the SQLite database
            conn = sqlite3.connect(filename)
            # Create a cursor object
            cursor = conn.cursor()
            # Execute the query to get table names
            cursor.execute("SELECT name FROM sqlite_master WHERE type='table'")
            # Fetch all table names
            table_names = [row[0] for row in cursor.fetchall()]
            # Close the connection
            conn.close()
            # Return the list of table names
            return table_names
        except sqlite3.Error as e:
            # Raise an IOError if the file does not exist
            raise IOError(f"file {filename} does not exist")


INFO:root:----------------------------------------
INFO:root:max length: 1812
INFO:root:max position: 2317
INFO:root:target_namespace: sqlitedict.sqlitedict<file>.SqliteDict<class>.get_tablenames<func>
INFO:root:****************************************

data 50:   0%|          | 0/512 [00:00<?, ?it/s]
data 50:   2%|▏         | 10/512 [00:14<12:07,  1.45s/it]
data 50:   4%|▍         | 20/512 [00:28<11:30,  1.40s/it]
data 50:   6%|▌         | 30/512 [00:42<11:33,  1.44s/it]
data 50:   8%|▊         | 40/512 [00:58<11:33,  1.47s/it]
data 50:  10%|▉         | 50/512 [01:13<11:27,  1.49s/it]
data 50:  12%|█▏        | 60/512 [01:28<11:18,  1.50s/it]
data 50:  14%|█▎        | 70/512 [01:44<11:11,  1.52s/it]
data 50:  16%|█▌        | 80/512 [01:57<10:33,  1.47s/it]
data 50:  18%|█▊        | 90/512 [02:12<10:25,  1.48s/it]
data 50:  20%|█▉        | 100/512 [02:28<10:17,  1.50s/it]
data 50:  21%|██▏       | 110/512 [02:43<10:08,  1.51s/it]
data 50:  23%|██▎       | 120/512 [02:59<09:56,  1.52s/it]
data 50:  25%|██▌       | 130/512 [03:14<09:39,  1.52s/it]
data 50:  27%|██▋       | 140/512 [03:29<09:25,  1.52s/it]
data 50:  29%|██▉       | 150/512 [03:43<08:54,  1.48s/it]
data 50:  31%|███▏      | 160/512 [03:58<08:46,  1.49s/it]
data 50:  33%|███▎      | 170/512 [04:13<08:34,  1.50s/it]
data 50:  35%|███▌      | 180/512 [04:28<08:19,  1.51s/it]
data 50:  37%|███▋      | 190/512 [04:44<08:05,  1.51s/it]
data 50:  39%|███▉      | 200/512 [04:59<07:52,  1.52s/it]
data 50:  41%|████      | 210/512 [05:15<07:43,  1.53s/it]
data 50:  43%|████▎     | 220/512 [05:29<07:22,  1.52s/it]
data 50:  45%|████▍     | 230/512 [05:44<07:00,  1.49s/it]
data 50:  47%|████▋     | 240/512 [05:59<06:50,  1.51s/it]
data 50:  49%|████▉     | 250/512 [06:15<06:41,  1.53s/it]
data 50:  51%|█████     | 260/512 [06:30<06:24,  1.53s/it]
data 50:  51%|█████     | 260/512 [06:34<06:22,  1.52s/it]
INFO:root:函数头: 
    @staticmethod
    def get_tablenames(filename):

INFO:root:目标函数体: 
        
        if not os.path.isfile(filename):
            raise IOError('file %s does not exist' % (filename))
        GET_TABLENAMES = 'SELECT name FROM sqlite_master WHERE type="table"'
        with sqlite3.connect(filename) as conn:
            cursor = conn.execute(GET_TABLENAMES)
            res = cursor.fetchall()

        return [name[0] for name in res]

INFO:root:生成结果: 
        try:
            # Importing sqlite3 module to interact with SQLite database
            import sqlite3

            # Establishing connection to SQLite database
            conn = sqlite3.connect(filename)

            # Creating a cursor object using the cursor() method
            cursor = conn.cursor()

            # Executing SQL query to retrieve table names
            cursor.execute("SELECT name FROM sqlite_master WHERE type='table';")

            # Fetching all rows from the executed query
            table_names = cursor.fetchall()

            # Closing the connection
            conn.close()

            # Returning the list of table names
            return [table_name[0] for table_name in table_names]

        except sqlite3 OperationalError as e:
            # Handling OperationalError exceptions
            raise IOError(f'OperationalError: {e}')
        except sqlite3 ProgrammingError as e:
            # Handling ProgrammingError exceptions
            raise IOError(f ProgrammingError: {e}')
        except sqlite3 DatabaseError as e:
            # Handling DatabaseError exceptions
            raise IOError(f'DatabaseError: {e}')
        except IOError as e:
            # Handling IOError exceptions
            raise IOError(f'IOError: {e}')
        except Exception as e:
            # Handling any other exceptions
            raise IOError(f'Exception: {e}')


INFO:root:----------------------------------------
INFO:root:max length: 1933
INFO:root:max position: 2438
INFO:root:target_namespace: sqlitedict.sqlitedict<file>.SqliteDict<class>.get_tablenames<func>
INFO:root:****************************************

data 50:   0%|          | 0/512 [00:00<?, ?it/s]
data 50:   2%|▏         | 10/512 [00:14<12:14,  1.46s/it]
data 50:   4%|▍         | 20/512 [00:29<12:10,  1.48s/it]
data 50:   6%|▌         | 30/512 [00:43<11:32,  1.44s/it]
data 50:   8%|▊         | 40/512 [00:58<11:32,  1.47s/it]
data 50:  10%|▉         | 50/512 [01:14<11:31,  1.50s/it]
data 50:  12%|█▏        | 60/512 [01:29<11:21,  1.51s/it]
data 50:  14%|█▎        | 70/512 [01:44<11:09,  1.52s/it]
data 50:  14%|█▎        | 70/512 [01:53<11:54,  1.62s/it]
INFO:root:函数头: 
    @staticmethod
    def get_tablenames(filename):

INFO:root:目标函数体: 
        
        if not os.path.isfile(filename):
            raise IOError('file %s does not exist' % (filename))
        GET_TABLENAMES = 'SELECT name FROM sqlite_master WHERE type="table"'
        with sqlite3.connect(filename) as conn:
            cursor = conn.execute(GET_TABLENAMES)
            res = cursor.fetchall()

        return [name[0] for name in res]

INFO:root:生成结果: 
        import sqlite3
        try:
            conn = sqlite3.connect(filename)
            cursor = conn.cursor()
            cursor.execute("SELECT name FROM sqlite_master WHERE type='table'")
            table_names = [row[0] for row in cursor.fetchall()]
            conn.close()
            return table_names
        except sqlite3.Error as e:
            raise IOError(str(e))


INFO:root:----------------------------------------
INFO:root:max length: 1746
INFO:root:max position: 2251
INFO:root:target_namespace: sqlitedict.sqlitedict<file>.SqliteDict<class>.get_tablenames<func>
INFO:root:****************************************
INFO:root:--------data 51--------

data 51:   0%|          | 0/512 [00:00<?, ?it/s]
data 51:   2%|▏         | 10/512 [01:37<1:21:35,  9.75s/it]
data 51:   4%|▍         | 20/512 [03:30<1:27:15, 10.64s/it]
data 51:   6%|▌         | 30/512 [05:28<1:29:54, 11.19s/it]
data 51:   8%|▊         | 40/512 [07:22<1:28:31, 11.25s/it]
data 51:  10%|▉         | 50/512 [09:16<1:27:09, 11.32s/it]
data 51:  10%|▉         | 50/512 [10:36<1:38:05, 12.74s/it]
INFO:root:函数头: 
def query_starts_with(query, prefixes):

INFO:root:目标函数体: 
    
    prefixes = [prefix.lower() for prefix in prefixes]
    formatted_sql = sqlparse.format(query.lower(), strip_comments=True)
    return bool(formatted_sql) and formatted_sql.split()[0] in prefixes

INFO:root:生成结果: 
    prefixes = [prefix.lower() for prefix in prefixes]
    query = query.lower()
    query = query.strip()
    query = query.stripcomments()

    if not query:
        return False

    words = query.split()
    return words[0] in prefixes


INFO:root:----------------------------------------
INFO:root:max length: 9027
INFO:root:max position: 11278
INFO:root:target_namespace: litecli.litecli<folder>.packages<folder>.parseutils<file>.query_starts_with<func>
INFO:root:****************************************

data 51:   0%|          | 0/512 [00:00<?, ?it/s]
data 51:   2%|▏         | 10/512 [01:39<1:23:07,  9.93s/it]
data 51:   4%|▍         | 20/512 [03:38<1:30:57, 11.09s/it]
data 51:   6%|▌         | 30/512 [05:32<1:30:23, 11.25s/it]
data 51:   8%|▊         | 40/512 [07:17<1:26:08, 10.95s/it]
data 51:  10%|▉         | 50/512 [08:57<1:21:45, 10.62s/it]
data 51:  12%|█▏        | 60/512 [10:35<1:17:41, 10.31s/it]
data 51:  14%|█▎        | 70/512 [14:25<1:46:36, 14.47s/it]
data 51:  16%|█▌        | 80/512 [16:15<1:36:09, 13.36s/it]
data 51:  18%|█▊        | 90/512 [18:09<1:29:47, 12.77s/it]
data 51:  18%|█▊        | 90/512 [19:10<1:29:53, 12.78s/it]
INFO:root:函数头: 
def query_starts_with(query, prefixes):

INFO:root:目标函数体: 
    
    prefixes = [prefix.lower() for prefix in prefixes]
    formatted_sql = sqlparse.format(query.lower(), strip_comments=True)
    return bool(formatted_sql) and formatted_sql.split()[0] in prefixes

INFO:root:生成结果: 
    query = query.strip()
    if not query:
        return False

    # Remove comments from the query
    query = sqlparse.format(query, strip_comments=True)

    # Convert query and prefixes to lowercase
    query = query.lower()
    prefixes = [prefix.lower() for prefix in prefixes]

    # Check if the query starts with any prefix
    for prefix in prefixes:
        if query.startswith(prefix):
            return True

    return False


INFO:root:----------------------------------------
INFO:root:max length: 9356
INFO:root:max position: 11439
INFO:root:target_namespace: litecli.litecli<folder>.packages<folder>.parseutils<file>.query_starts_with<func>
INFO:root:****************************************

data 51:   0%|          | 0/512 [00:00<?, ?it/s]
data 51:   2%|▏         | 10/512 [01:43<1:26:34, 10.35s/it]
data 51:   4%|▍         | 20/512 [03:28<1:25:42, 10.45s/it]
data 51:   6%|▌         | 30/512 [05:24<1:28:08, 10.97s/it]
data 51:   8%|▊         | 40/512 [07:21<1:28:38, 11.27s/it]
data 51:   8%|▊         | 40/512 [09:19<1:49:58, 13.98s/it]
INFO:root:函数头: 
def query_starts_with(query, prefixes):

INFO:root:目标函数体: 
    
    prefixes = [prefix.lower() for prefix in prefixes]
    formatted_sql = sqlparse.format(query.lower(), strip_comments=True)
    return bool(formatted_sql) and formatted_sql.split()[0] in prefixes

INFO:root:生成结果: 
    query = query.lower()
    query = sqlparse.format(query, strip_comments=True)
    query = query.strip()
    if not query:
        return False
    words = query.split()
    return words[0] in prefixes


INFO:root:----------------------------------------
INFO:root:max length: 8931
INFO:root:max position: 11199
INFO:root:target_namespace: litecli.litecli<folder>.packages<folder>.parseutils<file>.query_starts_with<func>
INFO:root:****************************************

data 51:   0%|          | 0/512 [00:00<?, ?it/s]
data 51:   2%|▏         | 10/512 [01:44<1:27:44, 10.49s/it]
data 51:   4%|▍         | 20/512 [03:36<1:29:25, 10.91s/it]
data 51:   6%|▌         | 30/512 [05:34<1:30:42, 11.29s/it]
data 51:   8%|▊         | 40/512 [07:15<1:25:14, 10.84s/it]
data 51:  10%|▉         | 50/512 [09:08<1:24:41, 11.00s/it]
data 51:  10%|▉         | 50/512 [11:06<1:42:40, 13.33s/it]
INFO:root:函数头: 
def query_starts_with(query, prefixes):

INFO:root:目标函数体: 
    
    prefixes = [prefix.lower() for prefix in prefixes]
    formatted_sql = sqlparse.format(query.lower(), strip_comments=True)
    return bool(formatted_sql) and formatted_sql.split()[0] in prefixes

INFO:root:生成结果: 
    query = query.lower()
    query = query.splitlines()[0].strip()
    query = query.split("#")[0].strip()

    prefixes = [prefix.lower() for prefix in prefixes]

    if query.startswith(prefixes):
        return True
    else:
        return False




INFO:root:----------------------------------------
INFO:root:max length: 9003
INFO:root:max position: 11412
INFO:root:target_namespace: litecli.litecli<folder>.packages<folder>.parseutils<file>.query_starts_with<func>
INFO:root:****************************************

data 51:   0%|          | 0/512 [00:00<?, ?it/s]
data 51:   2%|▏         | 10/512 [01:41<1:25:13, 10.19s/it]
data 51:   4%|▍         | 20/512 [03:25<1:24:16, 10.28s/it]
data 51:   6%|▌         | 30/512 [05:14<1:25:05, 10.59s/it]
data 51:   8%|▊         | 40/512 [07:08<1:25:35, 10.88s/it]
data 51:  10%|▉         | 50/512 [08:55<1:23:24, 10.83s/it]
data 51:  10%|▉         | 50/512 [09:53<1:31:20, 11.86s/it]
INFO:root:函数头: 
def query_starts_with(query, prefixes):

INFO:root:目标函数体: 
    
    prefixes = [prefix.lower() for prefix in prefixes]
    formatted_sql = sqlparse.format(query.lower(), strip_comments=True)
    return bool(formatted_sql) and formatted_sql.split()[0] in prefixes

INFO:root:生成结果: 
    query = query.lower()
    query = query.splitlines()[0].strip()
    query = sqlparse.format(query, strip_comments=True)
    if not query:
        return False
    words = query.split()
    return words[0] in prefixes


INFO:root:----------------------------------------
INFO:root:max length: 8942
INFO:root:max position: 11364
INFO:root:target_namespace: litecli.litecli<folder>.packages<folder>.parseutils<file>.query_starts_with<func>
INFO:root:****************************************
INFO:root:--------data 52--------

data 52:   0%|          | 0/512 [00:00<?, ?it/s]
data 52:   2%|▏         | 10/512 [01:59<1:39:49, 11.93s/it]
data 52:   4%|▍         | 20/512 [04:09<1:43:00, 12.56s/it]
data 52:   6%|▌         | 30/512 [06:03<1:36:50, 12.06s/it]
data 52:   8%|▊         | 40/512 [08:09<1:36:18, 12.24s/it]
data 52:  10%|▉         | 50/512 [10:13<1:34:48, 12.31s/it]
data 52:  12%|█▏        | 60/512 [12:24<1:34:42, 12.57s/it]
data 52:  14%|█▎        | 70/512 [14:36<1:34:17, 12.80s/it]
data 52:  14%|█▎        | 70/512 [15:27<1:37:34, 13.25s/it]
INFO:root:函数头: 
    def filter_renderers(self, renderers, format):

INFO:root:目标函数体: 
        
        renderers = [renderer for renderer in renderers
                     if renderer.format == format]
        if not renderers:
            raise Http404
        return renderers

INFO:root:生成结果: 
        # Implement the filtering logic here
        # Example implementation:
        filtered_renderers = []
        for renderer in renderers:
            if renderer.supported_formats.get(format):
                filtered_renderers.append(renderer)
        if not filtered_renderers:
            raise Http404("No renderer found for format '{}'".format(format))
        return filtered_renderers




INFO:root:----------------------------------------
INFO:root:max length: 8274
INFO:root:max position: 14161
INFO:root:target_namespace: djangorestframework.rest_framework<folder>.negotiation<file>.DefaultContentNegotiation<class>.filter_renderers<func>
INFO:root:****************************************

data 52:   0%|          | 0/512 [00:00<?, ?it/s]
data 52:   2%|▏         | 10/512 [01:49<1:31:34, 10.95s/it]
data 52:   4%|▍         | 20/512 [03:42<1:31:38, 11.18s/it]
data 52:   6%|▌         | 30/512 [05:40<1:31:46, 11.42s/it]
data 52:   8%|▊         | 40/512 [07:40<1:31:45, 11.66s/it]
data 52:   8%|▊         | 40/512 [08:19<1:38:16, 12.49s/it]
INFO:root:函数头: 
    def filter_renderers(self, renderers, format):

INFO:root:目标函数体: 
        
        renderers = [renderer for renderer in renderers
                     if renderer.format == format]
        if not renderers:
            raise Http404
        return renderers

INFO:root:生成结果: 
        try:
            return [renderer for renderer in renderers if renderer.supported_formats[format]]
        except KeyError:
            raise Http404(f"No renderer found that supports format '{format}'")


INFO:root:----------------------------------------
INFO:root:max length: 8891
INFO:root:max position: 13749
INFO:root:target_namespace: djangorestframework.rest_framework<folder>.negotiation<file>.DefaultContentNegotiation<class>.filter_renderers<func>
INFO:root:****************************************

data 52:   0%|          | 0/512 [00:00<?, ?it/s]
data 52:   2%|▏         | 10/512 [02:02<1:42:17, 12.23s/it]
data 52:   2%|▏         | 10/512 [02:39<2:13:08, 15.91s/it]
INFO:root:函数头: 
    def filter_renderers(self, renderers, format):

INFO:root:目标函数体: 
        
        renderers = [renderer for renderer in renderers
                     if renderer.format == format]
        if not renderers:
            raise Http404
        return renderers

INFO:root:生成结果: 
        # Implement the filtering logic here
        pass




INFO:root:----------------------------------------
INFO:root:max length: 6656
INFO:root:max position: 13120
INFO:root:target_namespace: djangorestframework.rest_framework<folder>.negotiation<file>.DefaultContentNegotiation<class>.filter_renderers<func>
INFO:root:****************************************

data 52:   0%|          | 0/512 [00:00<?, ?it/s]
data 52:   2%|▏         | 10/512 [02:01<1:41:48, 12.17s/it]
data 52:   4%|▍         | 20/512 [04:15<1:45:24, 12.86s/it]
data 52:   6%|▌         | 30/512 [06:11<1:38:59, 12.32s/it]
data 52:   8%|▊         | 40/512 [08:17<1:37:41, 12.42s/it]
data 52:  10%|▉         | 50/512 [10:26<1:36:56, 12.59s/it]
data 52:  10%|▉         | 50/512 [11:58<1:50:36, 14.36s/it]
INFO:root:函数头: 
    def filter_renderers(self, renderers, format):

INFO:root:目标函数体: 
        
        renderers = [renderer for renderer in renderers
                     if renderer.format == format]
        if not renderers:
            raise Http404
        return renderers

INFO:root:生成结果: 
        # Implement the filtering logic here
        # Example:
        # filtered_renderers = [renderer for renderer in renderers if renderer.supported_formats.get(format)]
        # if not filtered_renderers:
        #     raise exceptions NotFound()
        # return filtered_renderers


INFO:root:----------------------------------------
INFO:root:max length: 8083
INFO:root:max position: 12945
INFO:root:target_namespace: djangorestframework.rest_framework<folder>.negotiation<file>.DefaultContentNegotiation<class>.filter_renderers<func>
INFO:root:****************************************

data 52:   0%|          | 0/512 [00:00<?, ?it/s]
data 52:   2%|▏         | 10/512 [01:58<1:38:53, 11.82s/it]
data 52:   2%|▏         | 10/512 [03:05<2:35:22, 18.57s/it]
INFO:root:函数头: 
    def filter_renderers(self, renderers, format):

INFO:root:目标函数体: 
        
        renderers = [renderer for renderer in renderers
                     if renderer.format == format]
        if not renderers:
            raise Http404
        return renderers

INFO:root:生成结果: 
        # Implement the filter_renderers function here
        pass


INFO:root:----------------------------------------
INFO:root:max length: 6444
INFO:root:max position: 13477
INFO:root:target_namespace: djangorestframework.rest_framework<folder>.negotiation<file>.DefaultContentNegotiation<class>.filter_renderers<func>
INFO:root:****************************************
INFO:root:--------data 53--------

data 53:   0%|          | 0/512 [00:00<?, ?it/s]
data 53:   2%|▏         | 10/512 [02:27<2:03:04, 14.71s/it]
data 53:   2%|▏         | 10/512 [04:04<3:24:32, 24.45s/it]
INFO:root:函数头: 
@register.filter
def as_string(value):

INFO:root:目标函数体: 
    if value is None:
        return ''
    return '%s' % value

INFO:root:生成结果: 
    if value is None:
        return ''
    return str(value)




INFO:root:----------------------------------------
INFO:root:max length: 7276
INFO:root:max position: 14204
INFO:root:target_namespace: djangorestframework.rest_framework<folder>.templatetags<folder>.rest_framework<file>.as_string<func>
INFO:root:****************************************

data 53:   0%|          | 0/512 [00:00<?, ?it/s]
data 53:   2%|▏         | 10/512 [02:24<2:00:57, 14.46s/it]
data 53:   2%|▏         | 10/512 [03:47<3:10:42, 22.79s/it]
INFO:root:函数头: 
@register.filter
def as_string(value):

INFO:root:目标函数体: 
    if value is None:
        return ''
    return '%s' % value

INFO:root:生成结果: 
    if value is None:
        return ''
    return str(value)




INFO:root:----------------------------------------
INFO:root:max length: 7025
INFO:root:max position: 12257
INFO:root:target_namespace: djangorestframework.rest_framework<folder>.templatetags<folder>.rest_framework<file>.as_string<func>
INFO:root:****************************************

data 53:   0%|          | 0/512 [00:00<?, ?it/s]
data 53:   2%|▏         | 10/512 [02:23<1:59:45, 14.31s/it]
data 53:   2%|▏         | 10/512 [03:48<3:10:47, 22.80s/it]
INFO:root:函数头: 
@register.filter
def as_string(value):

INFO:root:目标函数体: 
    if value is None:
        return ''
    return '%s' % value

INFO:root:生成结果: 
    if value is None:
        return ''
    return str(value)




INFO:root:----------------------------------------
INFO:root:max length: 7509
INFO:root:max position: 13054
INFO:root:target_namespace: djangorestframework.rest_framework<folder>.templatetags<folder>.rest_framework<file>.as_string<func>
INFO:root:****************************************

data 53:   0%|          | 0/512 [00:00<?, ?it/s]
data 53:   2%|▏         | 10/512 [02:12<1:50:36, 13.22s/it]
data 53:   2%|▏         | 10/512 [03:43<3:07:21, 22.39s/it]
INFO:root:函数头: 
@register.filter
def as_string(value):

INFO:root:目标函数体: 
    if value is None:
        return ''
    return '%s' % value

INFO:root:生成结果: 
    if value is None:
        return ''
    return str(value)




INFO:root:----------------------------------------
INFO:root:max length: 6568
INFO:root:max position: 12553
INFO:root:target_namespace: djangorestframework.rest_framework<folder>.templatetags<folder>.rest_framework<file>.as_string<func>
INFO:root:****************************************

data 53:   0%|          | 0/512 [00:00<?, ?it/s]
data 53:   2%|▏         | 10/512 [02:32<2:07:23, 15.23s/it]
data 53:   2%|▏         | 10/512 [04:16<3:34:17, 25.61s/it]
INFO:root:函数头: 
@register.filter
def as_string(value):

INFO:root:目标函数体: 
    if value is None:
        return ''
    return '%s' % value

INFO:root:生成结果: 
    if value is None:
        return ''
    return str(value)




INFO:root:----------------------------------------
INFO:root:max length: 6950
INFO:root:max position: 15086
INFO:root:target_namespace: djangorestframework.rest_framework<folder>.templatetags<folder>.rest_framework<file>.as_string<func>
INFO:root:****************************************
INFO:root:--------data 54--------

data 54:   0%|          | 0/512 [00:00<?, ?it/s]
data 54:   2%|▏         | 10/512 [02:38<2:12:33, 15.84s/it]
data 54:   4%|▍         | 20/512 [05:07<2:05:15, 15.28s/it]
data 54:   6%|▌         | 30/512 [07:39<2:02:34, 15.26s/it]
data 54:   6%|▌         | 30/512 [10:03<2:41:42, 20.13s/it]
INFO:root:函数头: 
@register.filter
def add_nested_class(value):

INFO:root:目标函数体: 
    if isinstance(value, dict):
        return 'class=nested'
    if isinstance(value, list) and any(isinstance(item, (list, dict)) for item in value):
        return 'class=nested'
    return ''

INFO:root:生成结果: 
    if isinstance(value, dict) or (isinstance(value, list) and any(isinstance(item, dict) for item in value)):
        return 'class=nested'
    return ''


INFO:root:----------------------------------------
INFO:root:max length: 8797
INFO:root:max position: 15503
INFO:root:target_namespace: djangorestframework.rest_framework<folder>.templatetags<folder>.rest_framework<file>.add_nested_class<func>
INFO:root:****************************************

data 54:   0%|          | 0/512 [00:00<?, ?it/s]
data 54:   2%|▏         | 10/512 [02:26<2:02:52, 14.69s/it]
data 54:   4%|▍         | 20/512 [04:49<1:58:18, 14.43s/it]
data 54:   6%|▌         | 30/512 [07:20<1:58:17, 14.72s/it]
data 54:   6%|▌         | 30/512 [09:28<2:32:20, 18.96s/it]
INFO:root:函数头: 
@register.filter
def add_nested_class(value):

INFO:root:目标函数体: 
    if isinstance(value, dict):
        return 'class=nested'
    if isinstance(value, list) and any(isinstance(item, (list, dict)) for item in value):
        return 'class=nested'
    return ''

INFO:root:生成结果: 
    if isinstance(value, dict) or (isinstance(value, list) and any(isinstance(item, dict) for item in value)):
        return 'class=nested'
    return ''


INFO:root:----------------------------------------
INFO:root:max length: 8658
INFO:root:max position: 16064
INFO:root:target_namespace: djangorestframework.rest_framework<folder>.templatetags<folder>.rest_framework<file>.add_nested_class<func>
INFO:root:****************************************

data 54:   0%|          | 0/512 [00:00<?, ?it/s]
data 54:   2%|▏         | 10/512 [02:28<2:04:11, 14.84s/it]
data 54:   4%|▍         | 20/512 [04:57<2:02:12, 14.90s/it]
data 54:   6%|▌         | 30/512 [07:28<2:00:09, 14.96s/it]
data 54:   8%|▊         | 40/512 [09:53<1:56:20, 14.79s/it]
data 54:  10%|▉         | 50/512 [12:19<1:53:26, 14.73s/it]
data 54:  10%|▉         | 50/512 [14:55<2:17:54, 17.91s/it]
INFO:root:函数头: 
@register.filter
def add_nested_class(value):

INFO:root:目标函数体: 
    if isinstance(value, dict):
        return 'class=nested'
    if isinstance(value, list) and any(isinstance(item, (list, dict)) for item in value):
        return 'class=nested'
    return ''

INFO:root:生成结果: 
    if isinstance(value, dict):
        return 'class=nested'
    elif isinstance(value, list):
        for item in value:
            if isinstance(item, dict):
                return 'class=nested'
            elif isinstance(item, list):
                return 'class=nested'
    return ''


INFO:root:----------------------------------------
INFO:root:max length: 9357
INFO:root:max position: 14564
INFO:root:target_namespace: djangorestframework.rest_framework<folder>.templatetags<folder>.rest_framework<file>.add_nested_class<func>
INFO:root:****************************************

data 54:   0%|          | 0/512 [00:00<?, ?it/s]
data 54:   2%|▏         | 10/512 [02:24<2:01:16, 14.49s/it]
data 54:   4%|▍         | 20/512 [04:53<2:00:44, 14.72s/it]
data 54:   6%|▌         | 30/512 [07:13<1:55:37, 14.39s/it]
data 54:   8%|▊         | 40/512 [09:41<1:54:32, 14.56s/it]
data 54:  10%|▉         | 50/512 [12:23<1:56:34, 15.14s/it]
data 54:  10%|▉         | 50/512 [14:51<2:17:14, 17.82s/it]
INFO:root:函数头: 
@register.filter
def add_nested_class(value):

INFO:root:目标函数体: 
    if isinstance(value, dict):
        return 'class=nested'
    if isinstance(value, list) and any(isinstance(item, (list, dict)) for item in value):
        return 'class=nested'
    return ''

INFO:root:生成结果: 
    if isinstance(value, dict):
        return 'class=nested'
    elif isinstance(value, list):
        for item in value:
            if isinstance(item, dict):
                return 'class=nested'
            elif isinstance(item, list):
                return 'class=nested'
    return ''


INFO:root:----------------------------------------
INFO:root:max length: 9560
INFO:root:max position: 15790
INFO:root:target_namespace: djangorestframework.rest_framework<folder>.templatetags<folder>.rest_framework<file>.add_nested_class<func>
INFO:root:****************************************

data 54:   0%|          | 0/512 [00:00<?, ?it/s]
data 54:   2%|▏         | 10/512 [02:31<2:06:24, 15.11s/it]
data 54:   4%|▍         | 20/512 [05:10<2:07:55, 15.60s/it]
data 54:   6%|▌         | 30/512 [07:44<2:04:24, 15.49s/it]
data 54:   8%|▊         | 40/512 [10:07<1:58:18, 15.04s/it]
data 54:  10%|▉         | 50/512 [12:33<1:54:36, 14.88s/it]
data 54:  10%|▉         | 50/512 [13:09<2:01:38, 15.80s/it]
INFO:root:函数头: 
@register.filter
def add_nested_class(value):

INFO:root:目标函数体: 
    if isinstance(value, dict):
        return 'class=nested'
    if isinstance(value, list) and any(isinstance(item, (list, dict)) for item in value):
        return 'class=nested'
    return ''

INFO:root:生成结果: 
    if isinstance(value, dict):
        return 'class=nested'
    elif isinstance(value, list):
        for item in value:
            if isinstance(item, dict) or isinstance(item, list):
                return 'class=nested'
    return ''


INFO:root:----------------------------------------
INFO:root:max length: 9293
INFO:root:max position: 16083
INFO:root:target_namespace: djangorestframework.rest_framework<folder>.templatetags<folder>.rest_framework<file>.add_nested_class<func>
INFO:root:****************************************
INFO:root:--------data 55--------

data 55:   0%|          | 0/512 [00:00<?, ?it/s]
data 55:   2%|▏         | 10/512 [02:13<1:51:20, 13.31s/it]
data 55:   4%|▍         | 20/512 [04:27<1:49:32, 13.36s/it]
data 55:   4%|▍         | 20/512 [05:28<2:14:29, 16.40s/it]
INFO:root:函数头: 
    def loads(self, bstruct):

INFO:root:目标函数体: 
        
        try:
            return pickle.loads(bstruct)
        except Exception:
            # this block should catch at least:
            # ValueError, AttributeError, ImportError; but more to be safe
            raise ValueError

INFO:root:生成结果: 
        try:
            return pickle.loads(bstruct)
        except Exception as e:
            raise ValueError(str(e))


INFO:root:----------------------------------------
INFO:root:max length: 6096
INFO:root:max position: 9414
INFO:root:target_namespace: pyramid.src<folder>.pyramid<folder>.session<file>.PickleSerializer<class>.loads<func>
INFO:root:****************************************

data 55:   0%|          | 0/512 [00:00<?, ?it/s]
data 55:   2%|▏         | 10/512 [01:59<1:40:06, 11.96s/it]
data 55:   4%|▍         | 20/512 [04:05<1:41:01, 12.32s/it]
data 55:   4%|▍         | 20/512 [05:50<2:23:50, 17.54s/it]
INFO:root:函数头: 
    def loads(self, bstruct):

INFO:root:目标函数体: 
        
        try:
            return pickle.loads(bstruct)
        except Exception:
            # this block should catch at least:
            # ValueError, AttributeError, ImportError; but more to be safe
            raise ValueError

INFO:root:生成结果: 
        try:
            return pickle.loads(bstruct, protocol=self.protocol)
        except Exception as e:
            raise ValueError(str(e))


INFO:root:----------------------------------------
INFO:root:max length: 6092
INFO:root:max position: 9576
INFO:root:target_namespace: pyramid.src<folder>.pyramid<folder>.session<file>.PickleSerializer<class>.loads<func>
INFO:root:****************************************

data 55:   0%|          | 0/512 [00:00<?, ?it/s]
data 55:   2%|▏         | 10/512 [01:55<1:36:27, 11.53s/it]
data 55:   4%|▍         | 20/512 [04:06<1:42:00, 12.44s/it]
data 55:   4%|▍         | 20/512 [06:02<2:28:37, 18.13s/it]
INFO:root:函数头: 
    def loads(self, bstruct):

INFO:root:目标函数体: 
        
        try:
            return pickle.loads(bstruct)
        except Exception:
            # this block should catch at least:
            # ValueError, AttributeError, ImportError; but more to be safe
            raise ValueError

INFO:root:生成结果: 
        try:
            return pickle.loads(bstruct, protocol=self.protocol)
        except Exception as e:
            raise ValueError(str(e))


INFO:root:----------------------------------------
INFO:root:max length: 6495
INFO:root:max position: 9660
INFO:root:target_namespace: pyramid.src<folder>.pyramid<folder>.session<file>.PickleSerializer<class>.loads<func>
INFO:root:****************************************

data 55:   0%|          | 0/512 [00:00<?, ?it/s]
data 55:   2%|▏         | 10/512 [01:54<1:35:33, 11.42s/it]
data 55:   4%|▍         | 20/512 [04:04<1:41:33, 12.39s/it]
data 55:   4%|▍         | 20/512 [05:04<2:04:39, 15.20s/it]
INFO:root:函数头: 
    def loads(self, bstruct):

INFO:root:目标函数体: 
        
        try:
            return pickle.loads(bstruct)
        except Exception:
            # this block should catch at least:
            # ValueError, AttributeError, ImportError; but more to be safe
            raise ValueError

INFO:root:生成结果: 
        try:
            return pickle.loads(bstruct)
        except Exception as e:
            raise ValueError(str(e))


INFO:root:----------------------------------------
INFO:root:max length: 6131
INFO:root:max position: 9937
INFO:root:target_namespace: pyramid.src<folder>.pyramid<folder>.session<file>.PickleSerializer<class>.loads<func>
INFO:root:****************************************

data 55:   0%|          | 0/512 [00:00<?, ?it/s]
data 55:   2%|▏         | 10/512 [01:50<1:32:17, 11.03s/it]
data 55:   4%|▍         | 20/512 [03:54<1:37:21, 11.87s/it]
data 55:   4%|▍         | 20/512 [05:45<2:21:44, 17.29s/it]
INFO:root:函数头: 
    def loads(self, bstruct):

INFO:root:目标函数体: 
        
        try:
            return pickle.loads(bstruct)
        except Exception:
            # this block should catch at least:
            # ValueError, AttributeError, ImportError; but more to be safe
            raise ValueError

INFO:root:生成结果: 
        try:
            return pickle.loads(bstruct, protocol=self.protocol)
        except Exception as e:
            raise ValueError(str(e))


INFO:root:----------------------------------------
INFO:root:max length: 6621
INFO:root:max position: 9641
INFO:root:target_namespace: pyramid.src<folder>.pyramid<folder>.session<file>.PickleSerializer<class>.loads<func>
INFO:root:****************************************
INFO:root:--------data 56--------

data 56:   0%|          | 0/512 [00:00<?, ?it/s]
data 56:   2%|▏         | 10/512 [02:28<2:03:54, 14.81s/it]
data 56:   4%|▍         | 20/512 [05:03<2:05:07, 15.26s/it]
data 56:   4%|▍         | 20/512 [05:34<2:17:20, 16.75s/it]
INFO:root:函数头: 
    def flash(self, msg, queue='', allow_duplicate=True):

INFO:root:目标函数体: 
        storage = self.setdefault('_f_' + queue, [])
        if allow_duplicate or (msg not in storage):
            storage.append(msg)

INFO:root:生成结果: 
        if msg not in self:
            self[msg] = []
        self[msg].append(queue)




INFO:root:----------------------------------------
INFO:root:max length: 6370
INFO:root:max position: 11146
INFO:root:target_namespace: pyramid.src<folder>.pyramid<folder>.testing<file>.DummySession<class>.flash<func>
INFO:root:****************************************

data 56:   0%|          | 0/512 [00:00<?, ?it/s]
data 56:   2%|▏         | 10/512 [02:14<1:52:49, 13.48s/it]
data 56:   4%|▍         | 20/512 [04:47<1:59:13, 14.54s/it]
data 56:   6%|▌         | 30/512 [07:14<1:57:21, 14.61s/it]
data 56:   6%|▌         | 30/512 [09:18<2:29:26, 18.60s/it]
INFO:root:函数头: 
    def flash(self, msg, queue='', allow_duplicate=True):

INFO:root:目标函数体: 
        storage = self.setdefault('_f_' + queue, [])
        if allow_duplicate or (msg not in storage):
            storage.append(msg)

INFO:root:生成结果: 
        if queue not in self:
            self[queue] = []
        if msg not in self[queue] or not allow_duplicate:
            self[queue].append(msg)




INFO:root:----------------------------------------
INFO:root:max length: 6618
INFO:root:max position: 10327
INFO:root:target_namespace: pyramid.src<folder>.pyramid<folder>.testing<file>.DummySession<class>.flash<func>
INFO:root:****************************************

data 56:   0%|          | 0/512 [00:00<?, ?it/s]
data 56:   2%|▏         | 10/512 [02:19<1:56:26, 13.92s/it]
data 56:   4%|▍         | 20/512 [04:50<1:59:55, 14.63s/it]
data 56:   6%|▌         | 30/512 [07:23<1:59:52, 14.92s/it]
data 56:   6%|▌         | 30/512 [09:20<2:30:05, 18.68s/it]
INFO:root:函数头: 
    def flash(self, msg, queue='', allow_duplicate=True):

INFO:root:目标函数体: 
        storage = self.setdefault('_f_' + queue, [])
        if allow_duplicate or (msg not in storage):
            storage.append(msg)

INFO:root:生成结果: 
        if queue not in self:
            self[queue] = []
        if msg not in self[queue] or not allow_duplicate:
            self[queue].append(msg)




INFO:root:----------------------------------------
INFO:root:max length: 6403
INFO:root:max position: 10389
INFO:root:target_namespace: pyramid.src<folder>.pyramid<folder>.testing<file>.DummySession<class>.flash<func>
INFO:root:****************************************

data 56:   0%|          | 0/512 [00:00<?, ?it/s]
data 56:   2%|▏         | 10/512 [02:20<1:57:52, 14.09s/it]
data 56:   4%|▍         | 20/512 [04:54<2:01:39, 14.84s/it]
data 56:   6%|▌         | 30/512 [07:24<1:59:36, 14.89s/it]
data 56:   6%|▌         | 30/512 [09:26<2:31:36, 18.87s/it]
INFO:root:函数头: 
    def flash(self, msg, queue='', allow_duplicate=True):

INFO:root:目标函数体: 
        storage = self.setdefault('_f_' + queue, [])
        if allow_duplicate or (msg not in storage):
            storage.append(msg)

INFO:root:生成结果: 
        if queue not in self:
            self[queue] = []
        if msg not in self[queue] or not allow_duplicate:
            self[queue].append(msg)




INFO:root:----------------------------------------
INFO:root:max length: 7148
INFO:root:max position: 10451
INFO:root:target_namespace: pyramid.src<folder>.pyramid<folder>.testing<file>.DummySession<class>.flash<func>
INFO:root:****************************************

data 56:   0%|          | 0/512 [00:00<?, ?it/s]
data 56:   2%|▏         | 10/512 [02:19<1:57:03, 13.99s/it]
data 56:   4%|▍         | 20/512 [04:53<2:01:31, 14.82s/it]
data 56:   6%|▌         | 30/512 [07:21<1:58:42, 14.78s/it]
data 56:   6%|▌         | 30/512 [09:19<2:29:45, 18.64s/it]
INFO:root:函数头: 
    def flash(self, msg, queue='', allow_duplicate=True):

INFO:root:目标函数体: 
        storage = self.setdefault('_f_' + queue, [])
        if allow_duplicate or (msg not in storage):
            storage.append(msg)

INFO:root:生成结果: 
        if queue not in self:
            self[queue] = []
        if msg not in self[queue] or not allow_duplicate:
            self[queue].append(msg)




INFO:root:----------------------------------------
INFO:root:max length: 6817
INFO:root:max position: 11096
INFO:root:target_namespace: pyramid.src<folder>.pyramid<folder>.testing<file>.DummySession<class>.flash<func>
INFO:root:****************************************
INFO:root:--------data 57--------

data 57:   0%|          | 0/512 [00:00<?, ?it/s]
data 57:   2%|▏         | 10/512 [02:20<1:57:10, 14.01s/it]
data 57:   2%|▏         | 10/512 [04:35<3:50:07, 27.50s/it]
INFO:root:函数头: 
    def pop_flash(self, queue=''):

INFO:root:目标函数体: 
        storage = self.pop('_f_' + queue, [])
        return storage

INFO:root:生成结果: 
        storage = self.setdefault('_f_' + queue, [])
        return storage.pop()




INFO:root:----------------------------------------
INFO:root:max length: 6743
INFO:root:max position: 9991
INFO:root:target_namespace: pyramid.src<folder>.pyramid<folder>.testing<file>.DummySession<class>.pop_flash<func>
INFO:root:****************************************

data 57:   0%|          | 0/512 [00:00<?, ?it/s]
data 57:   2%|▏         | 10/512 [02:10<1:49:19, 13.07s/it]
data 57:   2%|▏         | 10/512 [04:09<3:28:48, 24.96s/it]
INFO:root:函数头: 
    def pop_flash(self, queue=''):

INFO:root:目标函数体: 
        storage = self.pop('_f_' + queue, [])
        return storage

INFO:root:生成结果: 
        storage = self.setdefault('_f_' + queue, [])
        return storage.pop()




INFO:root:----------------------------------------
INFO:root:max length: 6375
INFO:root:max position: 10804
INFO:root:target_namespace: pyramid.src<folder>.pyramid<folder>.testing<file>.DummySession<class>.pop_flash<func>
INFO:root:****************************************

data 57:   0%|          | 0/512 [00:00<?, ?it/s]
data 57:   2%|▏         | 10/512 [01:09<58:24,  6.98s/it]
data 57:   4%|▍         | 20/512 [02:26<1:00:28,  7.38s/it]
data 57:   4%|▍         | 20/512 [03:37<1:29:16, 10.89s/it]
INFO:root:函数头: 
    def pop_flash(self, queue=''):

INFO:root:目标函数体: 
        storage = self.pop('_f_' + queue, [])
        return storage

INFO:root:生成结果: 
        storage = self.setdefault('_f_' + queue, [])
        msg = storage.pop() if storage else None
        return msg




INFO:root:----------------------------------------
INFO:root:max length: 7182
INFO:root:max position: 10204
INFO:root:target_namespace: pyramid.src<folder>.pyramid<folder>.testing<file>.DummySession<class>.pop_flash<func>
INFO:root:****************************************

data 57:   0%|          | 0/512 [00:00<?, ?it/s]
data 57:   2%|▏         | 10/512 [01:09<58:00,  6.93s/it]
data 57:   2%|▏         | 10/512 [02:20<1:57:50, 14.08s/it]
INFO:root:函数头: 
    def pop_flash(self, queue=''):

INFO:root:目标函数体: 
        storage = self.pop('_f_' + queue, [])
        return storage

INFO:root:生成结果: 
        storage = self.setdefault('_f_' + queue, [])
        return storage.pop()




INFO:root:----------------------------------------
INFO:root:max length: 7273
INFO:root:max position: 10148
INFO:root:target_namespace: pyramid.src<folder>.pyramid<folder>.testing<file>.DummySession<class>.pop_flash<func>
INFO:root:****************************************

data 57:   0%|          | 0/512 [00:00<?, ?it/s]
data 57:   2%|▏         | 10/512 [01:08<57:26,  6.86s/it]
data 57:   4%|▍         | 20/512 [02:23<59:21,  7.24s/it]
data 57:   6%|▌         | 30/512 [03:41<59:58,  7.47s/it]
data 57:   6%|▌         | 30/512 [03:50<1:01:36,  7.67s/it]
INFO:root:函数头: 
    def pop_flash(self, queue=''):

INFO:root:目标函数体: 
        storage = self.pop('_f_' + queue, [])
        return storage

INFO:root:生成结果: 
        storage = self.setdefault('_f_' + queue, [])
        msg = storage.pop(0) if storage else None
        return msg




INFO:root:----------------------------------------
INFO:root:max length: 7737
INFO:root:max position: 10898
INFO:root:target_namespace: pyramid.src<folder>.pyramid<folder>.testing<file>.DummySession<class>.pop_flash<func>
INFO:root:****************************************
INFO:root:--------data 58--------

data 58:   0%|          | 0/512 [00:00<?, ?it/s]
data 58:   2%|▏         | 10/512 [01:17<1:04:42,  7.73s/it]
data 58:   2%|▏         | 10/512 [01:41<1:25:01, 10.16s/it]
INFO:root:函数头: 
    def peek_flash(self, queue=''):

INFO:root:目标函数体: 
        storage = self.get('_f_' + queue, [])
        return storage

INFO:root:生成结果: 
        return self.get('_f_' + queue, [])



INFO:root:----------------------------------------
INFO:root:max length: 6716
INFO:root:max position: 10350
INFO:root:target_namespace: pyramid.src<folder>.pyramid<folder>.testing<file>.DummySession<class>.peek_flash<func>
INFO:root:****************************************

data 58:   0%|          | 0/512 [00:00<?, ?it/s]
data 58:   2%|▏         | 10/512 [01:11<1:00:07,  7.19s/it]
data 58:   2%|▏         | 10/512 [02:20<1:57:37, 14.06s/it]
INFO:root:函数头: 
    def peek_flash(self, queue=''):

INFO:root:目标函数体: 
        storage = self.get('_f_' + queue, [])
        return storage

INFO:root:生成结果: 
        storage = self.get('_f_' + queue, [])
        return storage




INFO:root:----------------------------------------
INFO:root:max length: 6759
INFO:root:max position: 10345
INFO:root:target_namespace: pyramid.src<folder>.pyramid<folder>.testing<file>.DummySession<class>.peek_flash<func>
INFO:root:****************************************

data 58:   0%|          | 0/512 [00:00<?, ?it/s]
data 58:   2%|▏         | 10/512 [01:12<1:00:18,  7.21s/it]
data 58:   2%|▏         | 10/512 [02:19<1:57:07, 14.00s/it]
INFO:root:函数头: 
    def peek_flash(self, queue=''):

INFO:root:目标函数体: 
        storage = self.get('_f_' + queue, [])
        return storage

INFO:root:生成结果: 
        storage = self.get('_f_' + queue, [])
        return storage




INFO:root:----------------------------------------
INFO:root:max length: 7127
INFO:root:max position: 10223
INFO:root:target_namespace: pyramid.src<folder>.pyramid<folder>.testing<file>.DummySession<class>.peek_flash<func>
INFO:root:****************************************

data 58:   0%|          | 0/512 [00:00<?, ?it/s]
data 58:   2%|▏         | 10/512 [01:11<59:51,  7.15s/it]
data 58:   2%|▏         | 10/512 [02:27<2:03:13, 14.73s/it]
INFO:root:函数头: 
    def peek_flash(self, queue=''):

INFO:root:目标函数体: 
        storage = self.get('_f_' + queue, [])
        return storage

INFO:root:生成结果: 
        storage = self.get('_f_' + queue, [])
        return storage


INFO:root:----------------------------------------
INFO:root:max length: 7265
INFO:root:max position: 10458
INFO:root:target_namespace: pyramid.src<folder>.pyramid<folder>.testing<file>.DummySession<class>.peek_flash<func>
INFO:root:****************************************

data 58:   0%|          | 0/512 [00:00<?, ?it/s]
data 58:   2%|▏         | 10/512 [01:11<59:40,  7.13s/it]
data 58:   2%|▏         | 10/512 [02:25<2:01:33, 14.53s/it]
INFO:root:函数头: 
    def peek_flash(self, queue=''):

INFO:root:目标函数体: 
        storage = self.get('_f_' + queue, [])
        return storage

INFO:root:生成结果: 
        storage = self.get('_f_' + queue, [])
        return storage


INFO:root:----------------------------------------
INFO:root:max length: 6397
INFO:root:max position: 10591
INFO:root:target_namespace: pyramid.src<folder>.pyramid<folder>.testing<file>.DummySession<class>.peek_flash<func>
INFO:root:****************************************
INFO:root:--------data 59--------

data 59:   0%|          | 0/512 [00:00<?, ?it/s]
data 59:   2%|▏         | 10/512 [01:19<1:06:10,  7.91s/it]
data 59:   4%|▍         | 20/512 [02:41<1:06:37,  8.13s/it]
data 59:   6%|▌         | 30/512 [04:03<1:05:32,  8.16s/it]
data 59:   6%|▌         | 30/512 [05:02<1:20:53, 10.07s/it]
INFO:root:函数头: 
    def new_csrf_token(self):

INFO:root:目标函数体: 
        token = '0123456789012345678901234567890123456789'
        self['_csrft_'] = token
        return token

INFO:root:生成结果: 
        import pyramid.security as security
        import uuid
        token = security.generate_csrf_token()
        self['pyramid.csrf_token'] = token
        return token




INFO:root:----------------------------------------
INFO:root:max length: 7074
INFO:root:max position: 11308
INFO:root:target_namespace: pyramid.src<folder>.pyramid<folder>.testing<file>.DummySession<class>.new_csrf_token<func>
INFO:root:****************************************

data 59:   0%|          | 0/512 [00:00<?, ?it/s]
data 59:   2%|▏         | 10/512 [01:14<1:02:43,  7.50s/it]
data 59:   4%|▍         | 20/512 [02:37<1:04:53,  7.91s/it]
data 59:   4%|▍         | 20/512 [03:35<1:28:17, 10.77s/it]
INFO:root:函数头: 
    def new_csrf_token(self):

INFO:root:目标函数体: 
        token = '0123456789012345678901234567890123456789'
        self['_csrft_'] = token
        return token

INFO:root:生成结果: 
        import uuid
        token = str(uuid.uuid4())
        self['csrf_token'] = token
        return token




INFO:root:----------------------------------------
INFO:root:max length: 6891
INFO:root:max position: 10584
INFO:root:target_namespace: pyramid.src<folder>.pyramid<folder>.testing<file>.DummySession<class>.new_csrf_token<func>
INFO:root:****************************************

data 59:   0%|          | 0/512 [00:00<?, ?it/s]
data 59:   2%|▏         | 10/512 [01:12<1:00:41,  7.25s/it]
data 59:   4%|▍         | 20/512 [02:32<1:03:04,  7.69s/it]
data 59:   6%|▌         | 30/512 [03:49<1:01:40,  7.68s/it]
data 59:   8%|▊         | 40/512 [05:08<1:01:12,  7.78s/it]
data 59:  10%|▉         | 50/512 [06:28<1:00:29,  7.86s/it]
data 59:  12%|█▏        | 60/512 [07:50<1:00:02,  7.97s/it]
data 59:  12%|█▏        | 60/512 [08:14<1:02:04,  8.24s/it]
INFO:root:函数头: 
    def new_csrf_token(self):

INFO:root:目标函数体: 
        token = '0123456789012345678901234567890123456789'
        self['_csrft_'] = token
        return token

INFO:root:生成结果: 
        import uuid  # Importing uuid module to generate unique token
        token = str(uuid.uuid4())  # Generating a unique token using uuid module
        self['csrftoken'] = token  # storing the token in the session dictionary
        return token  # returning the generated token




INFO:root:----------------------------------------
INFO:root:max length: 7030
INFO:root:max position: 10744
INFO:root:target_namespace: pyramid.src<folder>.pyramid<folder>.testing<file>.DummySession<class>.new_csrf_token<func>
INFO:root:****************************************

data 59:   0%|          | 0/512 [00:00<?, ?it/s]
data 59:   2%|▏         | 10/512 [01:13<1:01:26,  7.34s/it]
data 59:   4%|▍         | 20/512 [02:33<1:03:37,  7.76s/it]
data 59:   4%|▍         | 20/512 [03:43<1:31:33, 11.16s/it]
INFO:root:函数头: 
    def new_csrf_token(self):

INFO:root:目标函数体: 
        token = '0123456789012345678901234567890123456789'
        self['_csrft_'] = token
        return token

INFO:root:生成结果: 
        import uuid
        token = str(uuid.uuid4())
        self['CSRFToken'] = token
        return token




INFO:root:----------------------------------------
INFO:root:max length: 6210
INFO:root:max position: 10337
INFO:root:target_namespace: pyramid.src<folder>.pyramid<folder>.testing<file>.DummySession<class>.new_csrf_token<func>
INFO:root:****************************************

data 59:   0%|          | 0/512 [00:00<?, ?it/s]
data 59:   2%|▏         | 10/512 [01:11<59:35,  7.12s/it]
data 59:   4%|▍         | 20/512 [02:30<1:02:17,  7.60s/it]
data 59:   4%|▍         | 20/512 [03:38<1:29:28, 10.91s/it]
INFO:root:函数头: 
    def new_csrf_token(self):

INFO:root:目标函数体: 
        token = '0123456789012345678901234567890123456789'
        self['_csrft_'] = token
        return token

INFO:root:生成结果: 
        import uuid
        token = str(uuid.uuid4())
        self['CSRF_token'] = token
        return token




INFO:root:----------------------------------------
INFO:root:max length: 6442
INFO:root:max position: 10591
INFO:root:target_namespace: pyramid.src<folder>.pyramid<folder>.testing<file>.DummySession<class>.new_csrf_token<func>
INFO:root:****************************************
INFO:root:--------data 60--------

data 60:   0%|          | 0/512 [00:00<?, ?it/s]
data 60:   2%|▏         | 10/512 [01:04<53:56,  6.45s/it]
data 60:   4%|▍         | 20/512 [02:07<52:04,  6.35s/it]
data 60:   4%|▍         | 20/512 [02:34<1:03:28,  7.74s/it]
INFO:root:函数头: 
def view_defaults(**settings):

INFO:root:目标函数体: 
    

    def wrap(wrapped):
        # Omit body code

    return wrap

INFO:root:生成结果: 
    def decorator(cls):
        cls.__view_defaults__ = settings
        return cls
    return decorator




INFO:root:----------------------------------------
INFO:root:max length: 6792
INFO:root:max position: 9251
INFO:root:target_namespace: pyramid.src<folder>.pyramid<folder>.view<file>.view_defaults<func>
INFO:root:****************************************

data 60:   0%|          | 0/512 [00:00<?, ?it/s]
data 60:   2%|▏         | 10/512 [01:01<51:30,  6.16s/it]
data 60:   4%|▍         | 20/512 [02:04<50:59,  6.22s/it]
data 60:   4%|▍         | 20/512 [02:29<1:01:14,  7.47s/it]
INFO:root:函数头: 
def view_defaults(**settings):

INFO:root:目标函数体: 
    

    def wrap(wrapped):
        # Omit body code

    return wrap

INFO:root:生成结果: 
    def decorator(cls):
        cls.__view_defaults__ = settings
        return cls
    return decorator




INFO:root:----------------------------------------
INFO:root:max length: 6672
INFO:root:max position: 9602
INFO:root:target_namespace: pyramid.src<folder>.pyramid<folder>.view<file>.view_defaults<func>
INFO:root:****************************************

data 60:   0%|          | 0/512 [00:00<?, ?it/s]
data 60:   2%|▏         | 10/512 [00:56<47:34,  5.69s/it]
data 60:   4%|▍         | 20/512 [02:03<51:21,  6.26s/it]
data 60:   4%|▍         | 20/512 [02:29<1:01:10,  7.46s/it]
INFO:root:函数头: 
def view_defaults(**settings):

INFO:root:目标函数体: 
    

    def wrap(wrapped):
        # Omit body code

    return wrap

INFO:root:生成结果: 
    def decorator(cls):
        cls.__view_defaults__ = settings
        return cls
    return decorator




INFO:root:----------------------------------------
INFO:root:max length: 6344
INFO:root:max position: 9400
INFO:root:target_namespace: pyramid.src<folder>.pyramid<folder>.view<file>.view_defaults<func>
INFO:root:****************************************

data 60:   0%|          | 0/512 [00:00<?, ?it/s]
data 60:   2%|▏         | 10/512 [00:55<46:16,  5.53s/it]
data 60:   4%|▍         | 20/512 [02:00<50:07,  6.11s/it]
data 60:   4%|▍         | 20/512 [02:27<1:00:36,  7.39s/it]
INFO:root:函数头: 
def view_defaults(**settings):

INFO:root:目标函数体: 
    

    def wrap(wrapped):
        # Omit body code

    return wrap

INFO:root:生成结果: 
    def decorator(cls):
        cls.__view_defaults__ = settings
        return cls
    return decorator




INFO:root:----------------------------------------
INFO:root:max length: 6729
INFO:root:max position: 9586
INFO:root:target_namespace: pyramid.src<folder>.pyramid<folder>.view<file>.view_defaults<func>
INFO:root:****************************************

data 60:   0%|          | 0/512 [00:00<?, ?it/s]
data 60:   2%|▏         | 10/512 [01:00<50:17,  6.01s/it]
data 60:   4%|▍         | 20/512 [02:05<51:51,  6.32s/it]
data 60:   4%|▍         | 20/512 [02:33<1:02:53,  7.67s/it]
INFO:root:函数头: 
def view_defaults(**settings):

INFO:root:目标函数体: 
    

    def wrap(wrapped):
        # Omit body code

    return wrap

INFO:root:生成结果: 
    def decorator(cls):
        cls.__view_defaults__ = settings
        return cls
    return decorator




INFO:root:----------------------------------------
INFO:root:max length: 7082
INFO:root:max position: 9567
INFO:root:target_namespace: pyramid.src<folder>.pyramid<folder>.view<file>.view_defaults<func>
INFO:root:****************************************
INFO:root:--------data 61--------

data 61:   0%|          | 0/512 [00:00<?, ?it/s]
data 61:   2%|▏         | 10/512 [01:12<1:00:21,  7.21s/it]
data 61:   4%|▍         | 20/512 [02:20<57:27,  7.01s/it]  
data 61:   4%|▍         | 20/512 [02:26<1:00:00,  7.32s/it]
INFO:root:函数头: 
def bytes_(s, encoding='latin-1', errors='strict'):

INFO:root:目标函数体: 
    
    if isinstance(s, str):
        return s.encode(encoding, errors)
    return s

INFO:root:生成结果: 
    if isinstance(s, str):
        return s.encode(encoding, errors)
    return s




INFO:root:----------------------------------------
INFO:root:max length: 5732
INFO:root:max position: 9003
INFO:root:target_namespace: pyramid.src<folder>.pyramid<folder>.util<file>.bytes_<func>
INFO:root:****************************************

data 61:   0%|          | 0/512 [00:00<?, ?it/s]
data 61:   2%|▏         | 10/512 [01:02<52:12,  6.24s/it]
data 61:   4%|▍         | 20/512 [02:14<55:48,  6.81s/it]
data 61:   4%|▍         | 20/512 [02:20<57:33,  7.02s/it]
INFO:root:函数头: 
def bytes_(s, encoding='latin-1', errors='strict'):

INFO:root:目标函数体: 
    
    if isinstance(s, str):
        return s.encode(encoding, errors)
    return s

INFO:root:生成结果: 
    if isinstance(s, str):
        return s.encode(encoding, errors)
    return s




INFO:root:----------------------------------------
INFO:root:max length: 6299
INFO:root:max position: 9023
INFO:root:target_namespace: pyramid.src<folder>.pyramid<folder>.util<file>.bytes_<func>
INFO:root:****************************************

data 61:   0%|          | 0/512 [00:00<?, ?it/s]
data 61:   2%|▏         | 10/512 [00:59<49:47,  5.95s/it]
data 61:   4%|▍         | 20/512 [02:07<52:43,  6.43s/it]
data 61:   4%|▍         | 20/512 [02:12<54:21,  6.63s/it]
INFO:root:函数头: 
def bytes_(s, encoding='latin-1', errors='strict'):

INFO:root:目标函数体: 
    
    if isinstance(s, str):
        return s.encode(encoding, errors)
    return s

INFO:root:生成结果: 
    if isinstance(s, str):
        return s.encode(encoding, errors)
    return s




INFO:root:----------------------------------------
INFO:root:max length: 6405
INFO:root:max position: 9405
INFO:root:target_namespace: pyramid.src<folder>.pyramid<folder>.util<file>.bytes_<func>
INFO:root:****************************************

data 61:   0%|          | 0/512 [00:00<?, ?it/s]
data 61:   2%|▏         | 10/512 [01:00<50:37,  6.05s/it]
data 61:   4%|▍         | 20/512 [02:09<53:41,  6.55s/it]
data 61:   4%|▍         | 20/512 [02:14<55:16,  6.74s/it]
INFO:root:函数头: 
def bytes_(s, encoding='latin-1', errors='strict'):

INFO:root:目标函数体: 
    
    if isinstance(s, str):
        return s.encode(encoding, errors)
    return s

INFO:root:生成结果: 
    if isinstance(s, str):
        return s.encode(encoding, errors)
    return s




INFO:root:----------------------------------------
INFO:root:max length: 6282
INFO:root:max position: 8942
INFO:root:target_namespace: pyramid.src<folder>.pyramid<folder>.util<file>.bytes_<func>
INFO:root:****************************************

data 61:   0%|          | 0/512 [00:00<?, ?it/s]
data 61:   2%|▏         | 10/512 [01:02<52:17,  6.25s/it]
data 61:   4%|▍         | 20/512 [02:13<55:34,  6.78s/it]
data 61:   4%|▍         | 20/512 [02:19<57:18,  6.99s/it]
INFO:root:函数头: 
def bytes_(s, encoding='latin-1', errors='strict'):

INFO:root:目标函数体: 
    
    if isinstance(s, str):
        return s.encode(encoding, errors)
    return s

INFO:root:生成结果: 
    if isinstance(s, str):
        return s.encode(encoding, errors)
    return s




INFO:root:----------------------------------------
INFO:root:max length: 6220
INFO:root:max position: 9665
INFO:root:target_namespace: pyramid.src<folder>.pyramid<folder>.util<file>.bytes_<func>
INFO:root:****************************************
INFO:root:--------data 62--------

data 62:   0%|          | 0/512 [00:00<?, ?it/s]
data 62:   2%|▏         | 10/512 [01:13<1:01:45,  7.38s/it]
data 62:   4%|▍         | 20/512 [02:23<58:32,  7.14s/it]  
data 62:   6%|▌         | 30/512 [03:31<56:14,  7.00s/it]
data 62:   6%|▌         | 30/512 [04:25<1:11:06,  8.85s/it]
INFO:root:函数头: 
def parse_vars(args):

INFO:root:目标函数体: 
    
    result = {}
    for arg in args:
        if '=' not in arg:
            raise ValueError('Variable assignment %r invalid (no "=")' % arg)
        name, value = arg.split('=', 1)
        result[name] = value
    return result

INFO:root:生成结果: 
    vars_dict = {}
    for arg in args:
        key, value = arg.split('=')
        vars_dict[key] = value
    return vars_dict


INFO:root:----------------------------------------
INFO:root:max length: 6847
INFO:root:max position: 12906
INFO:root:target_namespace: pyramid.src<folder>.pyramid<folder>.scripts<folder>.common<file>.parse_vars<func>
INFO:root:****************************************

data 62:   0%|          | 0/512 [00:00<?, ?it/s]
data 62:   2%|▏         | 10/512 [01:08<57:23,  6.86s/it]
data 62:   4%|▍         | 20/512 [02:21<58:14,  7.10s/it]
data 62:   6%|▌         | 30/512 [03:32<57:03,  7.10s/it]
data 62:   6%|▌         | 30/512 [03:56<1:03:26,  7.90s/it]
INFO:root:函数头: 
def parse_vars(args):

INFO:root:目标函数体: 
    
    result = {}
    for arg in args:
        if '=' not in arg:
            raise ValueError('Variable assignment %r invalid (no "=")' % arg)
        name, value = arg.split('=', 1)
        result[name] = value
    return result

INFO:root:生成结果: 
    result = {}
    for arg in args:
        key, value = arg.split('=')
        result[key] = value
    return result



INFO:root:----------------------------------------
INFO:root:max length: 6405
INFO:root:max position: 12016
INFO:root:target_namespace: pyramid.src<folder>.pyramid<folder>.scripts<folder>.common<file>.parse_vars<func>
INFO:root:****************************************

data 62:   0%|          | 0/512 [00:00<?, ?it/s]
data 62:   2%|▏         | 10/512 [01:08<57:13,  6.84s/it]
data 62:   4%|▍         | 20/512 [02:20<57:49,  7.05s/it]
data 62:   6%|▌         | 30/512 [03:29<56:04,  6.98s/it]
data 62:   6%|▌         | 30/512 [04:11<1:07:18,  8.38s/it]
INFO:root:函数头: 
def parse_vars(args):

INFO:root:目标函数体: 
    
    result = {}
    for arg in args:
        if '=' not in arg:
            raise ValueError('Variable assignment %r invalid (no "=")' % arg)
        name, value = arg.split('=', 1)
        result[name] = value
    return result

INFO:root:生成结果: 
    result = {}
    for arg in args:
        key, value = arg.split('=', 1)
        result[key] = value
    return result


INFO:root:----------------------------------------
INFO:root:max length: 6639
INFO:root:max position: 13375
INFO:root:target_namespace: pyramid.src<folder>.pyramid<folder>.scripts<folder>.common<file>.parse_vars<func>
INFO:root:****************************************

data 62:   0%|          | 0/512 [00:00<?, ?it/s]
data 62:   2%|▏         | 10/512 [01:07<56:53,  6.80s/it]
data 62:   4%|▍         | 20/512 [02:17<56:42,  6.91s/it]
data 62:   6%|▌         | 30/512 [03:28<56:08,  6.99s/it]
data 62:   6%|▌         | 30/512 [04:29<1:12:02,  8.97s/it]
INFO:root:函数头: 
def parse_vars(args):

INFO:root:目标函数体: 
    
    result = {}
    for arg in args:
        if '=' not in arg:
            raise ValueError('Variable assignment %r invalid (no "=")' % arg)
        name, value = arg.split('=', 1)
        result[name] = value
    return result

INFO:root:生成结果: 
    vars_dict = {}
    for arg in args:
        key, value = arg.split('=', 1)
        vars_dict[key] = value
    return vars_dict




INFO:root:----------------------------------------
INFO:root:max length: 7067
INFO:root:max position: 12611
INFO:root:target_namespace: pyramid.src<folder>.pyramid<folder>.scripts<folder>.common<file>.parse_vars<func>
INFO:root:****************************************

data 62:   0%|          | 0/512 [00:00<?, ?it/s]
data 62:   2%|▏         | 10/512 [01:06<55:34,  6.64s/it]
data 62:   4%|▍         | 20/512 [02:14<55:22,  6.75s/it]
data 62:   6%|▌         | 30/512 [03:23<54:41,  6.81s/it]
data 62:   6%|▌         | 30/512 [04:24<1:10:43,  8.80s/it]
INFO:root:函数头: 
def parse_vars(args):

INFO:root:目标函数体: 
    
    result = {}
    for arg in args:
        if '=' not in arg:
            raise ValueError('Variable assignment %r invalid (no "=")' % arg)
        name, value = arg.split('=', 1)
        result[name] = value
    return result

INFO:root:生成结果: 
    vars_dict = {}
    for arg in args:
        key, value = arg.split('=', 1)
        vars_dict[key] = value
    return vars_dict




INFO:root:----------------------------------------
INFO:root:max length: 6230
INFO:root:max position: 12175
INFO:root:target_namespace: pyramid.src<folder>.pyramid<folder>.scripts<folder>.common<file>.parse_vars<func>
INFO:root:****************************************
INFO:root:--------data 63--------

data 63:   0%|          | 0/512 [00:00<?, ?it/s]
data 63:   2%|▏         | 10/512 [01:08<57:06,  6.83s/it]
data 63:   4%|▍         | 20/512 [02:11<53:26,  6.52s/it]
data 63:   6%|▌         | 30/512 [03:21<54:12,  6.75s/it]
data 63:   8%|▊         | 40/512 [04:27<52:35,  6.68s/it]
data 63:   8%|▊         | 40/512 [05:02<59:28,  7.56s/it]
INFO:root:函数头: 
    def _find_multi_routes(self, mapper, request):

INFO:root:目标函数体: 
        infos = []
        path = request.path_info
        # find all routes that match path, regardless of predicates
        for route in mapper.get_routes():
            match = route.match(path)
            if match is not None:
                info = {'match': match, 'route': route}
                infos.append(info)
        return infos

INFO:root:生成结果: 
        infos = []
        for route in mapper.routes:
            match = request.matchdict
            if route.match(match):
                infos.append({'route': route, 'match': match})
        return infos


INFO:root:----------------------------------------
INFO:root:max length: 6760
INFO:root:max position: 11895
INFO:root:target_namespace: pyramid.src<folder>.pyramid<folder>.scripts<folder>.pviews<file>.PViewsCommand<class>._find_multi_routes<func>
INFO:root:****************************************

data 63:   0%|          | 0/512 [00:00<?, ?it/s]
data 63:   2%|▏         | 10/512 [01:01<51:06,  6.11s/it]
data 63:   4%|▍         | 20/512 [02:12<55:15,  6.74s/it]
data 63:   6%|▌         | 30/512 [03:20<54:02,  6.73s/it]
data 63:   8%|▊         | 40/512 [04:24<52:01,  6.61s/it]
data 63:   8%|▊         | 40/512 [04:57<58:28,  7.43s/it]
INFO:root:函数头: 
    def _find_multi_routes(self, mapper, request):

INFO:root:目标函数体: 
        infos = []
        path = request.path_info
        # find all routes that match path, regardless of predicates
        for route in mapper.get_routes():
            match = route.match(path)
            if match is not None:
                info = {'match': match, 'route': route}
                infos.append(info)
        return infos

INFO:root:生成结果: 
        infos = []
        for route in mapper.routes:
            match = route.match(request.path_info)
            if match:
                infos.append({'match': match, 'route': route})
        return infos


INFO:root:----------------------------------------
INFO:root:max length: 6810
INFO:root:max position: 12164
INFO:root:target_namespace: pyramid.src<folder>.pyramid<folder>.scripts<folder>.pviews<file>.PViewsCommand<class>._find_multi_routes<func>
INFO:root:****************************************

data 63:   0%|          | 0/512 [00:00<?, ?it/s]
data 63:   2%|▏         | 10/512 [01:01<51:42,  6.18s/it]
data 63:   4%|▍         | 20/512 [02:13<55:22,  6.75s/it]
data 63:   6%|▌         | 30/512 [03:22<54:43,  6.81s/it]
data 63:   8%|▊         | 40/512 [04:27<52:35,  6.68s/it]
data 63:   8%|▊         | 40/512 [04:46<56:17,  7.16s/it]
INFO:root:函数头: 
    def _find_multi_routes(self, mapper, request):

INFO:root:目标函数体: 
        infos = []
        path = request.path_info
        # find all routes that match path, regardless of predicates
        for route in mapper.get_routes():
            match = route.match(path)
            if match is not None:
                info = {'match': match, 'route': route}
                infos.append(info)
        return infos

INFO:root:生成结果: 
        infos = []
        for route in mapper.routes:
            match = request.match(route)
            if match:
                infos.append({'match': match, 'route': route})
        return infos


INFO:root:----------------------------------------
INFO:root:max length: 6633
INFO:root:max position: 11900
INFO:root:target_namespace: pyramid.src<folder>.pyramid<folder>.scripts<folder>.pviews<file>.PViewsCommand<class>._find_multi_routes<func>
INFO:root:****************************************

data 63:   0%|          | 0/512 [00:00<?, ?it/s]
data 63:   2%|▏         | 10/512 [01:04<53:48,  6.43s/it]
data 63:   4%|▍         | 20/512 [02:13<54:51,  6.69s/it]
data 63:   6%|▌         | 30/512 [03:21<54:15,  6.75s/it]
data 63:   8%|▊         | 40/512 [04:19<50:13,  6.38s/it]
data 63:   8%|▊         | 40/512 [04:58<58:46,  7.47s/it]
INFO:root:函数头: 
    def _find_multi_routes(self, mapper, request):

INFO:root:目标函数体: 
        infos = []
        path = request.path_info
        # find all routes that match path, regardless of predicates
        for route in mapper.get_routes():
            match = route.match(path)
            if match is not None:
                info = {'match': match, 'route': route}
                infos.append(info)
        return infos

INFO:root:生成结果: 
        infos = []
        for route in mapper.iter_routes():
            match = route.match(request.path_info)
            if match:
                infos.append({'match': match, 'route': route})
        return infos


INFO:root:----------------------------------------
INFO:root:max length: 7342
INFO:root:max position: 11430
INFO:root:target_namespace: pyramid.src<folder>.pyramid<folder>.scripts<folder>.pviews<file>.PViewsCommand<class>._find_multi_routes<func>
INFO:root:****************************************

data 63:   0%|          | 0/512 [00:00<?, ?it/s]
data 63:   2%|▏         | 10/512 [01:00<50:43,  6.06s/it]
data 63:   4%|▍         | 20/512 [02:09<53:51,  6.57s/it]
data 63:   6%|▌         | 30/512 [03:17<53:30,  6.66s/it]
data 63:   8%|▊         | 40/512 [04:26<53:02,  6.74s/it]
data 63:   8%|▊         | 40/512 [04:43<55:47,  7.09s/it]
INFO:root:函数头: 
    def _find_multi_routes(self, mapper, request):

INFO:root:目标函数体: 
        infos = []
        path = request.path_info
        # find all routes that match path, regardless of predicates
        for route in mapper.get_routes():
            match = route.match(path)
            if match is not None:
                info = {'match': match, 'route': route}
                infos.append(info)
        return infos

INFO:root:生成结果: 
        infos = []
        for route in mapper.routes:
            match = request.match(route)
            if match:
                infos.append({'match': match, 'route': route})
        return infos


INFO:root:----------------------------------------
INFO:root:max length: 6740
INFO:root:max position: 12011
INFO:root:target_namespace: pyramid.src<folder>.pyramid<folder>.scripts<folder>.pviews<file>.PViewsCommand<class>._find_multi_routes<func>
INFO:root:****************************************
INFO:root:已生成63条结果
INFO:root:--------data 64--------

data 64:   0%|          | 0/512 [00:00<?, ?it/s]
data 64:   2%|▏         | 10/512 [01:13<1:01:29,  7.35s/it]
data 64:   4%|▍         | 20/512 [02:26<59:51,  7.30s/it]  
data 64:   6%|▌         | 30/512 [03:31<55:59,  6.97s/it]
data 64:   8%|▊         | 40/512 [04:44<55:39,  7.08s/it]
data 64:  10%|▉         | 50/512 [05:56<54:58,  7.14s/it]
data 64:  12%|█▏        | 60/512 [06:55<50:36,  6.72s/it]
data 64:  14%|█▎        | 70/512 [08:14<52:09,  7.08s/it]
data 64:  14%|█▎        | 70/512 [08:38<54:36,  7.41s/it]
INFO:root:函数头: 
    def guess_server_url(self, loader, server_name, global_conf=None):

INFO:root:目标函数体: 
        server_name = server_name or 'main'
        settings = loader.get_settings('server:' + server_name, global_conf)
        if 'port' in settings:
            return 'http://127.0.0.1:{port}'.format(**settings)

INFO:root:生成结果: 
        if not server_name:
            server_name = 'main'
        server_config = loader.get_settings('server:' + server_name, global_conf)
        port = server_config.get('port')
        if port:
            return 'http://127.0.0.1:%s' % port
        else:
            return None


INFO:root:----------------------------------------
INFO:root:max length: 8327
INFO:root:max position: 14160
INFO:root:target_namespace: pyramid.src<folder>.pyramid<folder>.scripts<folder>.pserve<file>.PServeCommand<class>.guess_server_url<func>
INFO:root:****************************************

data 64:   0%|          | 0/512 [00:00<?, ?it/s]
data 64:   2%|▏         | 10/512 [01:11<59:26,  7.11s/it]
data 64:   4%|▍         | 20/512 [02:19<56:47,  6.93s/it]
data 64:   6%|▌         | 30/512 [03:23<53:56,  6.71s/it]
data 64:   8%|▊         | 40/512 [04:36<54:28,  6.93s/it]
data 64:  10%|▉         | 50/512 [05:49<54:28,  7.08s/it]
data 64:  12%|█▏        | 60/512 [06:51<50:58,  6.77s/it]
data 64:  14%|█▎        | 70/512 [08:03<51:03,  6.93s/it]
data 64:  14%|█▎        | 70/512 [08:46<55:22,  7.52s/it]
INFO:root:函数头: 
    def guess_server_url(self, loader, server_name, global_conf=None):

INFO:root:目标函数体: 
        server_name = server_name or 'main'
        settings = loader.get_settings('server:' + server_name, global_conf)
        if 'port' in settings:
            return 'http://127.0.0.1:{port}'.format(**settings)

INFO:root:生成结果: 
        if not server_name:
            server_name = 'main'
        server_config = loader.get_settings('server:' + server_name, global_conf)
        port = server_config.get('port', None)
        if port:
            return 'http://127.0.0.1:%s' % port
        else:
            return None


INFO:root:----------------------------------------
INFO:root:max length: 8285
INFO:root:max position: 14009
INFO:root:target_namespace: pyramid.src<folder>.pyramid<folder>.scripts<folder>.pserve<file>.PServeCommand<class>.guess_server_url<func>
INFO:root:****************************************

data 64:   0%|          | 0/512 [00:00<?, ?it/s]
data 64:   2%|▏         | 10/512 [01:09<58:18,  6.97s/it]
data 64:   4%|▍         | 20/512 [02:17<56:25,  6.88s/it]
data 64:   6%|▌         | 30/512 [03:24<54:17,  6.76s/it]
data 64:   8%|▊         | 40/512 [04:33<53:46,  6.84s/it]
data 64:  10%|▉         | 50/512 [05:47<54:13,  7.04s/it]
data 64:  12%|█▏        | 60/512 [06:44<49:38,  6.59s/it]
data 64:  12%|█▏        | 60/512 [07:55<59:44,  7.93s/it]
INFO:root:函数头: 
    def guess_server_url(self, loader, server_name, global_conf=None):

INFO:root:目标函数体: 
        server_name = server_name or 'main'
        settings = loader.get_settings('server:' + server_name, global_conf)
        if 'port' in settings:
            return 'http://127.0.0.1:{port}'.format(**settings)

INFO:root:生成结果: 
        if not server_name:
            server_name = 'main'
        server_config = loader.get_settings('server:' + server_name, global_conf)
        port = server_config.get('port', None)
        if port:
            return f'http://127.0.0.1:{port}'
        return None


INFO:root:----------------------------------------
INFO:root:max length: 8420
INFO:root:max position: 14032
INFO:root:target_namespace: pyramid.src<folder>.pyramid<folder>.scripts<folder>.pserve<file>.PServeCommand<class>.guess_server_url<func>
INFO:root:****************************************

data 64:   0%|          | 0/512 [00:00<?, ?it/s]
data 64:   2%|▏         | 10/512 [01:10<59:02,  7.06s/it]
data 64:   4%|▍         | 20/512 [02:18<56:41,  6.91s/it]
data 64:   6%|▌         | 30/512 [03:26<55:13,  6.87s/it]
data 64:   8%|▊         | 40/512 [04:33<53:24,  6.79s/it]
data 64:  10%|▉         | 50/512 [05:44<53:03,  6.89s/it]
data 64:  12%|█▏        | 60/512 [07:02<54:18,  7.21s/it]
data 64:  14%|█▎        | 70/512 [08:00<49:44,  6.75s/it]
data 64:  14%|█▎        | 70/512 [09:13<58:12,  7.90s/it]
INFO:root:函数头: 
    def guess_server_url(self, loader, server_name, global_conf=None):

INFO:root:目标函数体: 
        server_name = server_name or 'main'
        settings = loader.get_settings('server:' + server_name, global_conf)
        if 'port' in settings:
            return 'http://127.0.0.1:{port}'.format(**settings)

INFO:root:生成结果: 
        if not server_name:
            server_name = 'main'
        server_config_uri = 'server:' + server_name
        server_config = loader.get_settings('server', server_config_uri, global_conf)
        port = server_config.get('port')
        if port:
            return f'http://127.0.0.1:{port}'
        return None


INFO:root:----------------------------------------
INFO:root:max length: 8878
INFO:root:max position: 15137
INFO:root:target_namespace: pyramid.src<folder>.pyramid<folder>.scripts<folder>.pserve<file>.PServeCommand<class>.guess_server_url<func>
INFO:root:****************************************

data 64:   0%|          | 0/512 [00:00<?, ?it/s]
data 64:   2%|▏         | 10/512 [01:10<58:57,  7.05s/it]
data 64:   4%|▍         | 20/512 [02:21<58:02,  7.08s/it]
data 64:   6%|▌         | 30/512 [03:34<57:33,  7.17s/it]
data 64:   8%|▊         | 40/512 [04:41<55:09,  7.01s/it]
data 64:  10%|▉         | 50/512 [05:48<53:05,  6.89s/it]
data 64:  12%|█▏        | 60/512 [07:00<52:37,  6.99s/it]
data 64:  14%|█▎        | 70/512 [08:08<51:01,  6.93s/it]
data 64:  16%|█▌        | 80/512 [09:15<49:14,  6.84s/it]
data 64:  18%|█▊        | 90/512 [10:28<49:12,  7.00s/it]
data 64:  18%|█▊        | 90/512 [11:18<52:59,  7.53s/it]
INFO:root:函数头: 
    def guess_server_url(self, loader, server_name, global_conf=None):

INFO:root:目标函数体: 
        server_name = server_name or 'main'
        settings = loader.get_settings('server:' + server_name, global_conf)
        if 'port' in settings:
            return 'http://127.0.0.1:{port}'.format(**settings)

INFO:root:生成结果: 
        if not server_name:
            server_name = 'main'
        config_path = self.get_config_path(loader)
        here = os.path.dirname(config_path)
        config_uri = 'server:' + server_name
        settings = loader.get_settings(config_uri, global_conf)
        port = settings.get('port', None)
        if port:
            return f'http://127.0.0.1:{port}'
        else:
            return None


INFO:root:----------------------------------------
INFO:root:max length: 8400
INFO:root:max position: 14150
INFO:root:target_namespace: pyramid.src<folder>.pyramid<folder>.scripts<folder>.pserve<file>.PServeCommand<class>.guess_server_url<func>
INFO:root:****************************************
INFO:root:--------data 65--------

data 65:   0%|          | 0/512 [00:00<?, ?it/s]
data 65:   2%|▏         | 10/512 [00:02<02:26,  3.43it/s]
data 65:   4%|▍         | 20/512 [00:05<02:14,  3.67it/s]
data 65:   6%|▌         | 30/512 [00:08<02:08,  3.74it/s]
data 65:   8%|▊         | 40/512 [00:10<02:04,  3.79it/s]
data 65:  10%|▉         | 50/512 [00:13<02:01,  3.80it/s]
data 65:  10%|▉         | 50/512 [00:13<02:07,  3.61it/s]
INFO:root:函数头: 
def pep8_to_camel_case(name: str, initial: bool = False) -> str:

INFO:root:目标函数体: 
    
    chunks = name.split('_')
    converted = [s.capitalize() for s in chunks]
    if initial:
        return ''.join(converted)
    else:
        return chunks[0].lower() + ''.join(converted[1:])

INFO:root:生成结果: 
    parts = name.split('_')
    if initial:
        return ''.join([part.capitalize() for part in parts])
    else:
        return parts[0].lower() + ''.join([part.capitalize() for part in parts[1]])




INFO:root:----------------------------------------
INFO:root:max length: 919
INFO:root:max position: 919
INFO:root:target_namespace: happybase.aiohappybase<folder>._util<file>.pep8_to_camel_case<func>
INFO:root:****************************************

data 65:   0%|          | 0/512 [00:00<?, ?it/s]
data 65:   2%|▏         | 10/512 [00:02<01:55,  4.36it/s]
data 65:   4%|▍         | 20/512 [00:04<02:01,  4.05it/s]
data 65:   6%|▌         | 30/512 [00:07<02:01,  3.97it/s]
data 65:   8%|▊         | 40/512 [00:10<02:00,  3.93it/s]
data 65:  10%|▉         | 50/512 [00:12<01:57,  3.92it/s]
data 65:  10%|▉         | 50/512 [00:13<02:01,  3.81it/s]
INFO:root:函数头: 
def pep8_to_camel_case(name: str, initial: bool = False) -> str:

INFO:root:目标函数体: 
    
    chunks = name.split('_')
    converted = [s.capitalize() for s in chunks]
    if initial:
        return ''.join(converted)
    else:
        return chunks[0].lower() + ''.join(converted[1:])

INFO:root:生成结果: 
    parts = name.split('_')
    if initial:
        return ''.join([part.capitalize() for part in parts])
    else:
        return parts[0].lower() + ''.join([part.capitalize() for part in parts[1]])




INFO:root:----------------------------------------
INFO:root:max length: 919
INFO:root:max position: 919
INFO:root:target_namespace: happybase.aiohappybase<folder>._util<file>.pep8_to_camel_case<func>
INFO:root:****************************************

data 65:   0%|          | 0/512 [00:00<?, ?it/s]
data 65:   2%|▏         | 10/512 [00:02<01:56,  4.31it/s]
data 65:   4%|▍         | 20/512 [00:04<02:01,  4.06it/s]
data 65:   6%|▌         | 30/512 [00:07<02:01,  3.98it/s]
data 65:   6%|▌         | 30/512 [00:08<02:12,  3.65it/s]
INFO:root:函数头: 
def pep8_to_camel_case(name: str, initial: bool = False) -> str:

INFO:root:目标函数体: 
    
    chunks = name.split('_')
    converted = [s.capitalize() for s in chunks]
    if initial:
        return ''.join(converted)
    else:
        return chunks[0].lower() + ''.join(converted[1:])

INFO:root:生成结果: 
    converted = name.replace('_', '').lower()
    if initial:
        converted = converted[0].upper() + converted[1:]
    return converted


INFO:root:----------------------------------------
INFO:root:max length: 900
INFO:root:max position: 900
INFO:root:target_namespace: happybase.aiohappybase<folder>._util<file>.pep8_to_camel_case<func>
INFO:root:****************************************

data 65:   0%|          | 0/512 [00:00<?, ?it/s]
data 65:   2%|▏         | 10/512 [00:02<01:55,  4.34it/s]
data 65:   4%|▍         | 20/512 [00:04<02:00,  4.09it/s]
data 65:   6%|▌         | 30/512 [00:07<02:00,  3.99it/s]
data 65:   8%|▊         | 40/512 [00:10<01:59,  3.94it/s]
data 65:   8%|▊         | 40/512 [00:12<02:28,  3.18it/s]
INFO:root:函数头: 
def pep8_to_camel_case(name: str, initial: bool = False) -> str:

INFO:root:目标函数体: 
    
    chunks = name.split('_')
    converted = [s.capitalize() for s in chunks]
    if initial:
        return ''.join(converted)
    else:
        return chunks[0].lower() + ''.join(converted[1:])

INFO:root:生成结果: 
    parts = name.split('_')
    camel_case_name = parts[0].lower() if initial else parts[0]
    camel_case_name += ''.join(part.capitalize() for part in parts[1:])
    return camel_case_name




INFO:root:----------------------------------------
INFO:root:max length: 917
INFO:root:max position: 917
INFO:root:target_namespace: happybase.aiohappybase<folder>._util<file>.pep8_to_camel_case<func>
INFO:root:****************************************

data 65:   0%|          | 0/512 [00:00<?, ?it/s]
data 65:   2%|▏         | 10/512 [00:02<01:57,  4.27it/s]
data 65:   4%|▍         | 20/512 [00:04<02:01,  4.06it/s]
data 65:   6%|▌         | 30/512 [00:07<02:00,  4.00it/s]
data 65:   6%|▌         | 30/512 [00:08<02:11,  3.66it/s]
INFO:root:函数头: 
def pep8_to_camel_case(name: str, initial: bool = False) -> str:

INFO:root:目标函数体: 
    
    chunks = name.split('_')
    converted = [s.capitalize() for s in chunks]
    if initial:
        return ''.join(converted)
    else:
        return chunks[0].lower() + ''.join(converted[1:])

INFO:root:生成结果: 
    converted = name.replace('_', '').lower()
    if initial:
        converted = converted[0].upper() + converted[1:]
    return converted




INFO:root:----------------------------------------
INFO:root:max length: 900
INFO:root:max position: 900
INFO:root:target_namespace: happybase.aiohappybase<folder>._util<file>.pep8_to_camel_case<func>
INFO:root:****************************************
INFO:root:--------data 66--------

data 66:   0%|          | 0/512 [00:00<?, ?it/s]
data 66:   2%|▏         | 10/512 [00:06<05:41,  1.47it/s]
data 66:   4%|▍         | 20/512 [00:13<05:20,  1.54it/s]
data 66:   6%|▌         | 30/512 [00:19<05:10,  1.55it/s]
data 66:   8%|▊         | 40/512 [00:25<05:02,  1.56it/s]
data 66:  10%|▉         | 50/512 [00:32<04:54,  1.57it/s]
data 66:  12%|█▏        | 60/512 [00:38<04:46,  1.58it/s]
data 66:  14%|█▎        | 70/512 [00:44<04:39,  1.58it/s]
data 66:  16%|█▌        | 80/512 [00:51<04:33,  1.58it/s]
data 66:  18%|█▊        | 90/512 [00:57<04:28,  1.57it/s]
data 66:  20%|█▉        | 100/512 [01:03<04:21,  1.58it/s]
data 66:  20%|█▉        | 100/512 [01:06<04:35,  1.49it/s]
INFO:root:函数头: 
def bytes_increment(b: bytes) -> Optional[bytes]:

INFO:root:目标函数体: 
    
    assert isinstance(b, bytes)
    b = bytearray(b)  # Used subset of its API is the same on Python 2 and 3.
    for i in range(len(b) - 1, -1, -1):
        if b[i] != 0xff:
            b[i] += 1
            return bytes(b[:i+1])
    return None

INFO:root:生成结果: 
    if b == b'\xff' * len(b):
        return None

    # Find the last byte that is smaller than 0xFF
    for i in range(len(b) - 1, -1, -1):
        if b[i] < b'\xff':
            # Increment the byte and truncate everything after it
            b = b[:i + 1] + bytes([b[i] + 1]) + b[i + 2:]
            break

    return b


INFO:root:----------------------------------------
INFO:root:max length: 2935
INFO:root:max position: 2935
INFO:root:target_namespace: happybase.aiohappybase<folder>._util<file>.bytes_increment<func>
INFO:root:****************************************

data 66:   0%|          | 0/512 [00:00<?, ?it/s]
data 66:   2%|▏         | 10/512 [00:05<04:41,  1.78it/s]
data 66:   4%|▍         | 20/512 [00:11<04:55,  1.67it/s]
data 66:   6%|▌         | 30/512 [00:18<04:55,  1.63it/s]
data 66:   8%|▊         | 40/512 [00:24<04:51,  1.62it/s]
data 66:  10%|▉         | 50/512 [00:30<04:46,  1.61it/s]
data 66:  12%|█▏        | 60/512 [00:36<04:41,  1.61it/s]
data 66:  14%|█▎        | 70/512 [00:43<04:36,  1.60it/s]
data 66:  16%|█▌        | 80/512 [00:49<04:30,  1.60it/s]
data 66:  18%|█▊        | 90/512 [00:55<04:24,  1.59it/s]
data 66:  20%|█▉        | 100/512 [01:02<04:18,  1.59it/s]
data 66:  21%|██▏       | 110/512 [01:08<04:12,  1.59it/s]
data 66:  21%|██▏       | 110/512 [01:10<04:19,  1.55it/s]
INFO:root:函数头: 
def bytes_increment(b: bytes) -> Optional[bytes]:

INFO:root:目标函数体: 
    
    assert isinstance(b, bytes)
    b = bytearray(b)  # Used subset of its API is the same on Python 2 and 3.
    for i in range(len(b) - 1, -1, -1):
        if b[i] != 0xff:
            b[i] += 1
            return bytes(b[:i+1])
    return None

INFO:root:生成结果: 
    if b == b'\xFF' * len(b):
        return None

    # Find the last byte that is smaller than 0xFF
    for i in range(len(b) - 1, -1, -1):
        if b[i] < b'\xFF':
            # Increment this byte and drop everything after it
            return b[:i + 1] + bytes([b[i] + 1]) + b[i + 2:]

    # If all bytes are 0xFF, return None
    return None


INFO:root:----------------------------------------
INFO:root:max length: 2944
INFO:root:max position: 2944
INFO:root:target_namespace: happybase.aiohappybase<folder>._util<file>.bytes_increment<func>
INFO:root:****************************************

data 66:   0%|          | 0/512 [00:00<?, ?it/s]
data 66:   2%|▏         | 10/512 [00:05<04:41,  1.79it/s]
data 66:   4%|▍         | 20/512 [00:11<04:53,  1.68it/s]
data 66:   6%|▌         | 30/512 [00:18<04:54,  1.64it/s]
data 66:   8%|▊         | 40/512 [00:24<04:53,  1.61it/s]
data 66:  10%|▉         | 50/512 [00:30<04:47,  1.60it/s]
data 66:  12%|█▏        | 60/512 [00:36<04:41,  1.60it/s]
data 66:  14%|█▎        | 70/512 [00:43<04:35,  1.61it/s]
data 66:  16%|█▌        | 80/512 [00:49<04:30,  1.60it/s]
data 66:  18%|█▊        | 90/512 [00:55<04:24,  1.59it/s]
data 66:  20%|█▉        | 100/512 [01:02<04:18,  1.59it/s]
data 66:  20%|█▉        | 100/512 [01:04<04:26,  1.55it/s]
INFO:root:函数头: 
def bytes_increment(b: bytes) -> Optional[bytes]:

INFO:root:目标函数体: 
    
    assert isinstance(b, bytes)
    b = bytearray(b)  # Used subset of its API is the same on Python 2 and 3.
    for i in range(len(b) - 1, -1, -1):
        if b[i] != 0xff:
            b[i] += 1
            return bytes(b[:i+1])
    return None

INFO:root:生成结果: 
    if b == b'\xff' * len(b):
        return None

    # Find the last byte that is smaller than 0xFF
    for i in range(len(b) - 1, -1, -1):
        if b[i] < b'\xff':
            # Increment this byte and drop everything after it
            return b[:i + 1] + bytes([b[i] + 1]) + b[i + 2:]
    raise RuntimeError("Unexpected behavior")


INFO:root:----------------------------------------
INFO:root:max length: 2934
INFO:root:max position: 2934
INFO:root:target_namespace: happybase.aiohappybase<folder>._util<file>.bytes_increment<func>
INFO:root:****************************************

data 66:   0%|          | 0/512 [00:00<?, ?it/s]
data 66:   2%|▏         | 10/512 [00:05<04:43,  1.77it/s]
data 66:   4%|▍         | 20/512 [00:11<04:57,  1.65it/s]
data 66:   6%|▌         | 30/512 [00:18<04:58,  1.61it/s]
data 66:   8%|▊         | 40/512 [00:24<04:55,  1.60it/s]
data 66:  10%|▉         | 50/512 [00:30<04:49,  1.60it/s]
data 66:  12%|█▏        | 60/512 [00:37<04:42,  1.60it/s]
data 66:  14%|█▎        | 70/512 [00:43<04:36,  1.60it/s]
data 66:  16%|█▌        | 80/512 [00:49<04:31,  1.59it/s]
data 66:  18%|█▊        | 90/512 [00:56<04:24,  1.60it/s]
data 66:  18%|█▊        | 90/512 [00:56<04:25,  1.59it/s]
INFO:root:函数头: 
def bytes_increment(b: bytes) -> Optional[bytes]:

INFO:root:目标函数体: 
    
    assert isinstance(b, bytes)
    b = bytearray(b)  # Used subset of its API is the same on Python 2 and 3.
    for i in range(len(b) - 1, -1, -1):
        if b[i] != 0xff:
            b[i] += 1
            return bytes(b[:i+1])
    return None

INFO:root:生成结果: 
    if b == b'\xff' * len(b):
        return None
    b = bytearray(b)
    for i in range(len(b) - 1, -1, -1):
        if b[i] != 0xff:
            b[i] += 1
            b[i + 1:] = b'\xff' * (len(b) - i - 1)
            break
    return bytes(b)




INFO:root:----------------------------------------
INFO:root:max length: 2921
INFO:root:max position: 2921
INFO:root:target_namespace: happybase.aiohappybase<folder>._util<file>.bytes_increment<func>
INFO:root:****************************************

data 66:   0%|          | 0/512 [00:00<?, ?it/s]
data 66:   2%|▏         | 10/512 [00:05<04:44,  1.77it/s]
data 66:   4%|▍         | 20/512 [00:11<04:56,  1.66it/s]
data 66:   6%|▌         | 30/512 [00:18<04:56,  1.62it/s]
data 66:   8%|▊         | 40/512 [00:24<04:53,  1.61it/s]
data 66:  10%|▉         | 50/512 [00:30<04:49,  1.60it/s]
data 66:  12%|█▏        | 60/512 [00:37<04:42,  1.60it/s]
data 66:  14%|█▎        | 70/512 [00:43<04:35,  1.60it/s]
data 66:  16%|█▌        | 80/512 [00:49<04:29,  1.60it/s]
data 66:  18%|█▊        | 90/512 [00:55<04:24,  1.59it/s]
data 66:  18%|█▊        | 90/512 [01:00<04:45,  1.48it/s]
INFO:root:函数头: 
def bytes_increment(b: bytes) -> Optional[bytes]:

INFO:root:目标函数体: 
    
    assert isinstance(b, bytes)
    b = bytearray(b)  # Used subset of its API is the same on Python 2 and 3.
    for i in range(len(b) - 1, -1, -1):
        if b[i] != 0xff:
            b[i] += 1
            return bytes(b[:i+1])
    return None

INFO:root:生成结果: 
    if b == b'\xff' * len(b):
        return None
    b = bytearray(b)
    for i in range(len(b) - 1, -1, -1):
        if b[i] != 0xff:
            b[i] += 1
            b[i + 1:] = b'\xff' * (len(b) - i - 1)
            return bytes(b)
    raise RuntimeError("Input bytes contain only FF")




INFO:root:----------------------------------------
INFO:root:max length: 2928
INFO:root:max position: 2928
INFO:root:target_namespace: happybase.aiohappybase<folder>._util<file>.bytes_increment<func>
INFO:root:****************************************
INFO:root:--------data 67--------

data 67:   0%|          | 0/512 [00:00<?, ?it/s]
data 67:   2%|▏         | 10/512 [00:56<47:12,  5.64s/it]
data 67:   4%|▍         | 20/512 [05:23<2:28:01, 18.05s/it]
data 67:   4%|▍         | 20/512 [05:43<2:20:50, 17.18s/it]
INFO:root:函数头: 
def ensure_dir_exists(path):

INFO:root:目标函数体: 
    parent_dir = expanduser(dirname(path))
    if not os.path.exists(parent_dir):
        os.makedirs(parent_dir)

INFO:root:生成结果: 
    directory = os.path.dirname(path)
    if not os.path.exists(directory):
        os.makedirs(directory)




INFO:root:----------------------------------------
INFO:root:max length: 6215
INFO:root:max position: 13852
INFO:root:target_namespace: mssql-cli.mssqlcli<folder>.config<file>.ensure_dir_exists<func>
INFO:root:****************************************

data 67:   0%|          | 0/512 [00:00<?, ?it/s]
data 67:   2%|▏         | 10/512 [00:54<45:33,  5.45s/it]
data 67:   4%|▍         | 20/512 [01:57<48:43,  5.94s/it]
data 67:   4%|▍         | 20/512 [02:34<1:03:31,  7.75s/it]
INFO:root:函数头: 
def ensure_dir_exists(path):

INFO:root:目标函数体: 
    parent_dir = expanduser(dirname(path))
    if not os.path.exists(parent_dir):
        os.makedirs(parent_dir)

INFO:root:生成结果: 
    dir_path = os.path.dirname(path)
    if not os.path.exists(dir_path):
        os.makedirs(dir_path)




INFO:root:----------------------------------------
INFO:root:max length: 6142
INFO:root:max position: 12579
INFO:root:target_namespace: mssql-cli.mssqlcli<folder>.config<file>.ensure_dir_exists<func>
INFO:root:****************************************

data 67:   0%|          | 0/512 [00:00<?, ?it/s]
data 67:   2%|▏         | 10/512 [01:00<50:27,  6.03s/it]
data 67:   4%|▍         | 20/512 [02:55<1:16:01,  9.27s/it]
data 67:   6%|▌         | 30/512 [03:49<1:00:08,  7.49s/it]
data 67:   6%|▌         | 30/512 [04:04<1:05:23,  8.14s/it]
INFO:root:函数头: 
def ensure_dir_exists(path):

INFO:root:目标函数体: 
    parent_dir = expanduser(dirname(path))
    if not os.path.exists(parent_dir):
        os.makedirs(parent_dir)

INFO:root:生成结果: 
    try:
        os.makedirs(path)
    except OSError as e:
        if e.errno !=  os.errno.EEXIST:
            raise




INFO:root:----------------------------------------
INFO:root:max length: 6924
INFO:root:max position: 13464
INFO:root:target_namespace: mssql-cli.mssqlcli<folder>.config<file>.ensure_dir_exists<func>
INFO:root:****************************************

data 67:   0%|          | 0/512 [00:00<?, ?it/s]
data 67:   2%|▏         | 10/512 [00:56<46:53,  5.60s/it]
data 67:   4%|▍         | 20/512 [01:57<48:44,  5.94s/it]
data 67:   4%|▍         | 20/512 [02:17<56:12,  6.85s/it]
INFO:root:函数头: 
def ensure_dir_exists(path):

INFO:root:目标函数体: 
    parent_dir = expanduser(dirname(path))
    if not os.path.exists(parent_dir):
        os.makedirs(parent_dir)

INFO:root:生成结果: 
    directory = os.path.dirname(path)
    if not os.path.exists(directory):
        os.makedirs(directory)




INFO:root:----------------------------------------
INFO:root:max length: 6642
INFO:root:max position: 12455
INFO:root:target_namespace: mssql-cli.mssqlcli<folder>.config<file>.ensure_dir_exists<func>
INFO:root:****************************************

data 67:   0%|          | 0/512 [00:00<?, ?it/s]
data 67:   2%|▏         | 10/512 [00:57<47:45,  5.71s/it]
data 67:   2%|▏         | 10/512 [01:28<1:13:52,  8.83s/it]
INFO:root:函数头: 
def ensure_dir_exists(path):

INFO:root:目标函数体: 
    parent_dir = expanduser(dirname(path))
    if not os.path.exists(parent_dir):
        os.makedirs(parent_dir)

INFO:root:生成结果: 
    if not os.path.exists(path):
        os.makedirs(path)




INFO:root:----------------------------------------
INFO:root:max length: 4994
INFO:root:max position: 11789
INFO:root:target_namespace: mssql-cli.mssqlcli<folder>.config<file>.ensure_dir_exists<func>
INFO:root:****************************************
INFO:root:--------data 68--------

data 68:   0%|          | 0/512 [00:00<?, ?it/s]
data 68:   2%|▏         | 10/512 [01:07<56:17,  6.73s/it]
data 68:   4%|▍         | 20/512 [02:17<56:29,  6.89s/it]
data 68:   6%|▌         | 30/512 [03:15<51:35,  6.42s/it]
data 68:   8%|▊         | 40/512 [04:14<48:46,  6.20s/it]
data 68:  10%|▉         | 50/512 [05:26<50:35,  6.57s/it]
data 68:  12%|█▏        | 60/512 [06:33<49:50,  6.62s/it]
data 68:  14%|█▎        | 70/512 [07:30<46:19,  6.29s/it]
data 68:  16%|█▌        | 80/512 [08:42<47:32,  6.60s/it]
data 68:  18%|█▊        | 90/512 [09:39<44:24,  6.32s/it]
data 68:  20%|█▉        | 100/512 [10:46<44:03,  6.42s/it]
data 68:  20%|█▉        | 100/512 [11:16<46:28,  6.77s/it]
INFO:root:函数头: 
def _user_id_file_is_old(id_file_path):

INFO:root:目标函数体: 
    if os.path.exists(id_file_path):
        last_24_hours = datetime.now() - timedelta(hours=24)
        id_file_modified_time = datetime.fromtimestamp(os.path.getmtime(id_file_path))

        return id_file_modified_time < last_24_hours
    return False

INFO:root:生成结果: 
    import os
    import time
    import datetime

    # Get the last modified time of the file
    last_modified_time = os.path.getmtime(id_file_path)

    # Get the current time
    current_time = time.time()

    # Calculate the time difference in seconds
    time_difference = current_time - last_modified_time

    # Check if the file is older than 24 hours (86400 seconds)
    return time_difference > 86400




INFO:root:----------------------------------------
INFO:root:max length: 9197
INFO:root:max position: 15007
INFO:root:target_namespace: mssql-cli.mssqlcli<folder>.telemetry<file>._user_id_file_is_old<func>
INFO:root:****************************************

data 68:   0%|          | 0/512 [00:00<?, ?it/s]
data 68:   2%|▏         | 10/512 [01:10<59:11,  7.07s/it]
data 68:   4%|▍         | 20/512 [02:13<54:00,  6.59s/it]
data 68:   6%|▌         | 30/512 [03:04<47:44,  5.94s/it]
data 68:   8%|▊         | 40/512 [04:14<49:53,  6.34s/it]
data 68:  10%|▉         | 50/512 [05:22<50:07,  6.51s/it]
data 68:  12%|█▏        | 60/512 [06:20<47:12,  6.27s/it]
data 68:  14%|█▎        | 70/512 [07:30<47:58,  6.51s/it]
data 68:  16%|█▌        | 80/512 [08:36<47:00,  6.53s/it]
data 68:  18%|█▊        | 90/512 [09:40<45:43,  6.50s/it]
data 68:  20%|█▉        | 100/512 [10:37<42:54,  6.25s/it]
data 68:  21%|██▏       | 110/512 [11:47<43:19,  6.47s/it]
data 68:  21%|██▏       | 110/512 [12:50<46:54,  7.00s/it]
INFO:root:函数头: 
def _user_id_file_is_old(id_file_path):

INFO:root:目标函数体: 
    if os.path.exists(id_file_path):
        last_24_hours = datetime.now() - timedelta(hours=24)
        id_file_modified_time = datetime.fromtimestamp(os.path.getmtime(id_file_path))

        return id_file_modified_time < last_24_hours
    return False

INFO:root:生成结果: 
    try:
        # Get the last modified time of the file
        last_modified_time = os.path.getmtime(id_file_path)
        # Get the current time
        current_time = time.time()
        # Calculate the time difference in seconds
        time_difference = current_time - last_modified_time
        # Check if the time difference is greater than 8 hours (24 hours * 2)
        return time_difference > 8 * 3600
    except FileNotFoundError:
        # If the file does not exist, consider it old
        return True




INFO:root:----------------------------------------
INFO:root:max length: 10690
INFO:root:max position: 15182
INFO:root:target_namespace: mssql-cli.mssqlcli<folder>.telemetry<file>._user_id_file_is_old<func>
INFO:root:****************************************

data 68:   0%|          | 0/512 [00:00<?, ?it/s]
data 68:   2%|▏         | 10/512 [01:02<52:14,  6.24s/it]
data 68:   4%|▍         | 20/512 [02:15<56:27,  6.89s/it]
data 68:   6%|▌         | 30/512 [03:12<50:48,  6.32s/it]
data 68:   8%|▊         | 40/512 [04:18<50:30,  6.42s/it]
data 68:  10%|▉         | 50/512 [05:24<49:59,  6.49s/it]
data 68:  12%|█▏        | 60/512 [06:28<48:43,  6.47s/it]
data 68:  14%|█▎        | 70/512 [07:31<47:21,  6.43s/it]
data 68:  16%|█▌        | 80/512 [08:35<46:06,  6.40s/it]
data 68:  18%|█▊        | 90/512 [09:32<43:30,  6.19s/it]
data 68:  20%|█▉        | 100/512 [10:38<43:25,  6.32s/it]
data 68:  21%|██▏       | 110/512 [11:31<40:11,  6.00s/it]
data 68:  21%|██▏       | 110/512 [11:51<43:20,  6.47s/it]
INFO:root:函数头: 
def _user_id_file_is_old(id_file_path):

INFO:root:目标函数体: 
    if os.path.exists(id_file_path):
        last_24_hours = datetime.now() - timedelta(hours=24)
        id_file_modified_time = datetime.fromtimestamp(os.path.getmtime(id_file_path))

        return id_file_modified_time < last_24_hours
    return False

INFO:root:生成结果: 
    import os
    import time
    # Get the last modified time of the file
    last_modified_time = os.path.getmtime(id_file_path)
    # Get the current time
    current_time = time.time()
    # Calculate the time difference in seconds
    time_difference = current_time - last_modified_time
    # Check if the time difference is greater than 8 hours (24 hours * 60 * 60 * 2)
    return time_difference > 8 * 60 * 60




INFO:root:----------------------------------------
INFO:root:max length: 8894
INFO:root:max position: 15512
INFO:root:target_namespace: mssql-cli.mssqlcli<folder>.telemetry<file>._user_id_file_is_old<func>
INFO:root:****************************************

data 68:   0%|          | 0/512 [00:00<?, ?it/s]
data 68:   2%|▏         | 10/512 [01:03<52:47,  6.31s/it]
data 68:   4%|▍         | 20/512 [07:09<3:18:08, 24.16s/it]
data 68:   6%|▌         | 30/512 [08:05<2:06:04, 15.69s/it]
data 68:   8%|▊         | 40/512 [08:58<1:31:02, 11.57s/it]
data 68:  10%|▉         | 50/512 [10:04<1:15:14,  9.77s/it]
data 68:  12%|█▏        | 60/512 [11:07<1:04:50,  8.61s/it]
data 68:  14%|█▎        | 70/512 [12:17<59:27,  8.07s/it]  
data 68:  16%|█▌        | 80/512 [13:16<53:07,  7.38s/it]
data 68:  18%|█▊        | 90/512 [14:27<51:23,  7.31s/it]
data 68:  20%|█▉        | 100/512 [15:22<46:16,  6.74s/it]
data 68:  21%|██▏       | 110/512 [16:23<43:50,  6.54s/it]
data 68:  23%|██▎       | 120/512 [17:19<40:49,  6.25s/it]
data 68:  25%|██▌       | 130/512 [18:35<42:32,  6.68s/it]
data 68:  27%|██▋       | 140/512 [19:42<41:20,  6.67s/it]
data 68:  29%|██▉       | 150/512 [20:46<39:51,  6.61s/it]
data 68:  29%|██▉       | 150/512 [21:01<50:45,  8.41s/it]
INFO:root:函数头: 
def _user_id_file_is_old(id_file_path):

INFO:root:目标函数体: 
    if os.path.exists(id_file_path):
        last_24_hours = datetime.now() - timedelta(hours=24)
        id_file_modified_time = datetime.fromtimestamp(os.path.getmtime(id_file_path))

        return id_file_modified_time < last_24_hours
    return False

INFO:root:生成结果: 
    import os
    import time

    try:
        # Get the last modified time of the file in seconds since epoch.
        last_modified_time = os.path.getmtime(id_file_path)
        # Get the current time in seconds since epoch.
        current_time = time.time()
        # Calculate the time difference in seconds.
        time_difference = current_time - last_modified_time
        # Check if the time difference is greater than 8 hours (24 * 60 * 60 * 8 seconds).
        return time_difference > 8 * 60 * 60
    except FileNotFoundError:
        # If the file does not exist, return True to force generation of a new user id.
        return True




INFO:root:----------------------------------------
INFO:root:max length: 9782
INFO:root:max position: 15660
INFO:root:target_namespace: mssql-cli.mssqlcli<folder>.telemetry<file>._user_id_file_is_old<func>
INFO:root:****************************************

data 68:   0%|          | 0/512 [00:00<?, ?it/s]
data 68:   2%|▏         | 10/512 [01:01<51:29,  6.15s/it]
data 68:   4%|▍         | 20/512 [02:00<49:07,  5.99s/it]
data 68:   6%|▌         | 30/512 [03:04<49:36,  6.17s/it]
data 68:   8%|▊         | 40/512 [03:57<46:01,  5.85s/it]
data 68:  10%|▉         | 50/512 [04:58<45:34,  5.92s/it]
data 68:  12%|█▏        | 60/512 [05:53<43:28,  5.77s/it]
data 68:  12%|█▏        | 60/512 [06:11<46:38,  6.19s/it]
INFO:root:函数头: 
def _user_id_file_is_old(id_file_path):

INFO:root:目标函数体: 
    if os.path.exists(id_file_path):
        last_24_hours = datetime.now() - timedelta(hours=24)
        id_file_modified_time = datetime.fromtimestamp(os.path.getmtime(id_file_path))

        return id_file_modified_time < last_24_hours
    return False

INFO:root:生成结果: 
    import os
    import time

    if not os.path.exists(id_file_path):
        return True

    file_modified_time = os.path.getmtime(id_file_path)
    current_time = time.time()
    return current_time - file_modified_time > 24 * 3600




INFO:root:----------------------------------------
INFO:root:max length: 7343
INFO:root:max position: 14161
INFO:root:target_namespace: mssql-cli.mssqlcli<folder>.telemetry<file>._user_id_file_is_old<func>
INFO:root:****************************************
INFO:root:--------data 69--------

data 69:   0%|          | 0/512 [00:00<?, ?it/s]
data 69:   2%|▏         | 10/512 [01:05<55:05,  6.59s/it]
data 69:   4%|▍         | 20/512 [02:03<49:59,  6.10s/it]
data 69:   6%|▌         | 30/512 [03:07<50:15,  6.26s/it]
data 69:   8%|▊         | 40/512 [04:11<49:32,  6.30s/it]
data 69:  10%|▉         | 50/512 [05:11<47:38,  6.19s/it]
data 69:  10%|▉         | 50/512 [05:52<54:19,  7.05s/it]
INFO:root:函数头: 
def is_command_valid(command):

INFO:root:目标函数体: 
    
    if not command:
        return False

    try:
        # call command silentyly
        with open(devnull, 'wb') as no_out:
            subprocess.call(command, stdout=no_out, stderr=no_out)
    except OSError:
        return False
    else:
        return True

INFO:root:生成结果: 
    try:
        # Attempt to execute the command silently to check if it exists
        subprocess.run([command], check=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        return True
    except (OSError, subprocess.CCalledProcessError):
        return False



INFO:root:----------------------------------------
INFO:root:max length: 7554
INFO:root:max position: 12603
INFO:root:target_namespace: mssql-cli.mssqlcli<folder>.util<file>.is_command_valid<func>
INFO:root:****************************************

data 69:   0%|          | 0/512 [00:00<?, ?it/s]
data 69:   2%|▏         | 10/512 [00:58<48:44,  5.83s/it]
data 69:   4%|▍         | 20/512 [01:51<45:34,  5.56s/it]
data 69:   6%|▌         | 30/512 [02:53<46:40,  5.81s/it]
data 69:   8%|▊         | 40/512 [04:03<49:23,  6.28s/it]
data 69:   8%|▊         | 40/512 [04:17<50:42,  6.45s/it]
INFO:root:函数头: 
def is_command_valid(command):

INFO:root:目标函数体: 
    
    if not command:
        return False

    try:
        # call command silentyly
        with open(devnull, 'wb') as no_out:
            subprocess.call(command, stdout=no_out, stderr=no_out)
    except OSError:
        return False
    else:
        return True

INFO:root:生成结果: 
    try:
        subprocess.check_call([command], stdout=open(devnull, 'wb'), stderr=open(devnull, 'wb'))
        return True
    except (OSError):
        return False



INFO:root:----------------------------------------
INFO:root:max length: 7805
INFO:root:max position: 12773
INFO:root:target_namespace: mssql-cli.mssqlcli<folder>.util<file>.is_command_valid<func>
INFO:root:****************************************

data 69:   0%|          | 0/512 [00:00<?, ?it/s]
data 69:   2%|▏         | 10/512 [00:55<46:07,  5.51s/it]
data 69:   4%|▍         | 20/512 [01:50<45:22,  5.53s/it]
data 69:   6%|▌         | 30/512 [02:46<44:42,  5.57s/it]
data 69:   8%|▊         | 40/512 [03:54<47:33,  6.05s/it]
data 69:   8%|▊         | 40/512 [04:08<48:48,  6.20s/it]
INFO:root:函数头: 
def is_command_valid(command):

INFO:root:目标函数体: 
    
    if not command:
        return False

    try:
        # call command silentyly
        with open(devnull, 'wb') as no_out:
            subprocess.call(command, stdout=no_out, stderr=no_out)
    except OSError:
        return False
    else:
        return True

INFO:root:生成结果: 
    try:
        subprocess.check_call([command], stdout=open(devnull, 'w'), stderr=open(devnull, 'w'))
        return True
    except (OSError):
        return False



INFO:root:----------------------------------------
INFO:root:max length: 7387
INFO:root:max position: 13009
INFO:root:target_namespace: mssql-cli.mssqlcli<folder>.util<file>.is_command_valid<func>
INFO:root:****************************************

data 69:   0%|          | 0/512 [00:00<?, ?it/s]
data 69:   2%|▏         | 10/512 [00:56<47:09,  5.64s/it]
data 69:   4%|▍         | 20/512 [01:49<44:50,  5.47s/it]
data 69:   6%|▌         | 30/512 [02:46<44:28,  5.54s/it]
data 69:   8%|▊         | 40/512 [03:49<46:08,  5.86s/it]
data 69:   8%|▊         | 40/512 [04:33<53:45,  6.83s/it]
INFO:root:函数头: 
def is_command_valid(command):

INFO:root:目标函数体: 
    
    if not command:
        return False

    try:
        # call command silentyly
        with open(devnull, 'wb') as no_out:
            subprocess.call(command, stdout=no_out, stderr=no_out)
    except OSError:
        return False
    else:
        return True

INFO:root:生成结果: 
    try:
        subprocess.check_call([command], stdout=open(devnull, 'wb'), stderr=open(devnull, 'wb'))
        return True
    except ( OSError, subprocess.CCalledProcessError):
        return False



INFO:root:----------------------------------------
INFO:root:max length: 7332
INFO:root:max position: 13028
INFO:root:target_namespace: mssql-cli.mssqlcli<folder>.util<file>.is_command_valid<func>
INFO:root:****************************************

data 69:   0%|          | 0/512 [00:00<?, ?it/s]
data 69:   2%|▏         | 10/512 [00:58<48:41,  5.82s/it]
data 69:   4%|▍         | 20/512 [01:52<45:44,  5.58s/it]
data 69:   6%|▌         | 30/512 [02:50<45:49,  5.71s/it]
data 69:   8%|▊         | 40/512 [03:53<46:46,  5.95s/it]
data 69:   8%|▊         | 40/512 [04:46<56:19,  7.16s/it]
INFO:root:函数头: 
def is_command_valid(command):

INFO:root:目标函数体: 
    
    if not command:
        return False

    try:
        # call command silentyly
        with open(devnull, 'wb') as no_out:
            subprocess.call(command, stdout=no_out, stderr=no_out)
    except OSError:
        return False
    else:
        return True

INFO:root:生成结果: 
    try:
        subprocess.check_call([command], stdout=open(devnull, 'wb'), stderr=open(devnull, 'wb'))
        return True
    except (OSError, subprocess.CCalledProcessError):
        return False


INFO:root:----------------------------------------
INFO:root:max length: 7423
INFO:root:max position: 12733
INFO:root:target_namespace: mssql-cli.mssqlcli<folder>.util<file>.is_command_valid<func>
INFO:root:****************************************
INFO:root:--------data 70--------

data 70:   0%|          | 0/512 [00:00<?, ?it/s]
data 70:   2%|▏         | 10/512 [00:54<45:35,  5.45s/it]
data 70:   4%|▍         | 20/512 [01:49<44:50,  5.47s/it]
data 70:   6%|▌         | 30/512 [02:43<43:46,  5.45s/it]
data 70:   8%|▊         | 40/512 [03:39<43:25,  5.52s/it]
data 70:  10%|▉         | 50/512 [04:36<42:47,  5.56s/it]
data 70:  12%|█▏        | 60/512 [05:31<41:53,  5.56s/it]
data 70:  14%|█▎        | 70/512 [06:26<40:50,  5.55s/it]
data 70:  16%|█▌        | 80/512 [07:22<39:55,  5.55s/it]
data 70:  18%|█▊        | 90/512 [08:16<38:40,  5.50s/it]
data 70:  20%|█▉        | 100/512 [09:10<37:37,  5.48s/it]
data 70:  20%|█▉        | 100/512 [09:16<38:12,  5.57s/it]
INFO:root:函数头: 
def find_prev_keyword(sql, n_skip=0):

INFO:root:目标函数体: 
    
    if not sql.strip():
        return None, ''

    parsed = sqlparse.parse(sql)[0]
    flattened = list(parsed.flatten())
    flattened = flattened[:len(flattened) - n_skip]

    logical_operators = ('AND', 'OR', 'NOT', 'BETWEEN')

    for t in reversed(flattened):
        if t.value == '(' or (t.is_keyword and
                              (t.value.upper() not in logical_operators)
                             ):
            # Find the location of token t in the original parsed statement
            # We can't use parsed.token_index(t) because t may be a child token
            # inside a TokenList, in which case token_index thows an error
            # Minimal example:
            #   p = sqlparse.parse('select * from foo where bar')
            #   t = list(p.flatten())[-3]  # The "Where" token
            #   p.token_index(t)  # Throws ValueError: not in list
            idx = flattened.index(t)

            # Combine the string values of all tokens in the original list
            # up to and including the target keyword token t, to produce a
            # query string with everything after the keyword token removed
            text = ''.join(tok.value for tok in flattened[:idx + 1])
            return t, text

    return None, ''

INFO:root:生成结果: 
    sql = sql.strip()
    sql = sql.strip(';')
    sql = sql.strip('(')
    sql = sql.strip(')')
    sql = sql.strip('[')
    sql = sql.strip(']')
    sql = sql.strip(' ')

    tokens = sqlparse.parse(sql)
    last_token = tokens[-1]

    if last_token.token_type == sqlparse.tokens.Keyword:
        return last_token.value.lower(), sql[:last_token.token_start]

    return None, sql




INFO:root:----------------------------------------
INFO:root:max length: 12564
INFO:root:max position: 12949
INFO:root:target_namespace: mssql-cli.mssqlcli<folder>.packages<folder>.parseutils<folder>.utils<file>.find_prev_keyword<func>
INFO:root:****************************************

data 70:   0%|          | 0/512 [00:00<?, ?it/s]
data 70:   2%|▏         | 10/512 [00:51<42:52,  5.12s/it]
data 70:   4%|▍         | 20/512 [01:47<44:39,  5.45s/it]
data 70:   6%|▌         | 30/512 [02:44<44:30,  5.54s/it]
data 70:   8%|▊         | 40/512 [03:39<43:32,  5.53s/it]
data 70:  10%|▉         | 50/512 [04:35<42:42,  5.55s/it]
data 70:  12%|█▏        | 60/512 [05:31<41:52,  5.56s/it]
data 70:  14%|█▎        | 70/512 [06:26<40:53,  5.55s/it]
data 70:  16%|█▌        | 80/512 [07:23<40:23,  5.61s/it]
data 70:  16%|█▌        | 80/512 [08:08<43:56,  6.10s/it]
INFO:root:函数头: 
def find_prev_keyword(sql, n_skip=0):

INFO:root:目标函数体: 
    
    if not sql.strip():
        return None, ''

    parsed = sqlparse.parse(sql)[0]
    flattened = list(parsed.flatten())
    flattened = flattened[:len(flattened) - n_skip]

    logical_operators = ('AND', 'OR', 'NOT', 'BETWEEN')

    for t in reversed(flattened):
        if t.value == '(' or (t.is_keyword and
                              (t.value.upper() not in logical_operators)
                             ):
            # Find the location of token t in the original parsed statement
            # We can't use parsed.token_index(t) because t may be a child token
            # inside a TokenList, in which case token_index thows an error
            # Minimal example:
            #   p = sqlparse.parse('select * from foo where bar')
            #   t = list(p.flatten())[-3]  # The "Where" token
            #   p.token_index(t)  # Throws ValueError: not in list
            idx = flattened.index(t)

            # Combine the string values of all tokens in the original list
            # up to and including the target keyword token t, to produce a
            # query string with everything after the keyword token removed
            text = ''.join(tok.value for tok in flattened[:idx + 1])
            return t, text

    return None, ''

INFO:root:生成结果: 
    tokens = sqlparse.parse(sql)
    last_keyword = None
    last_keyword_text = None
    for statement in tokens:
        for token in statement.tokens:
            if token.ttype == sqlparse.tokens.Keyword:
                last_keyword = token.value.lower()
                last_keyword_text = token.value
                break
        if last_keyword:
            break
    return last_keyword, sql[len(last_keyword_text):].strip()


INFO:root:----------------------------------------
INFO:root:max length: 12704
INFO:root:max position: 12896
INFO:root:target_namespace: mssql-cli.mssqlcli<folder>.packages<folder>.parseutils<folder>.utils<file>.find_prev_keyword<func>
INFO:root:****************************************

data 70:   0%|          | 0/512 [00:00<?, ?it/s]
data 70:   2%|▏         | 10/512 [00:50<42:16,  5.05s/it]
data 70:   4%|▍         | 20/512 [01:46<44:11,  5.39s/it]
data 70:   6%|▌         | 30/512 [02:43<44:09,  5.50s/it]
data 70:   8%|▊         | 40/512 [03:37<43:08,  5.48s/it]
data 70:  10%|▉         | 50/512 [04:33<42:24,  5.51s/it]
data 70:  12%|█▏        | 60/512 [05:28<41:38,  5.53s/it]
data 70:  14%|█▎        | 70/512 [06:24<40:51,  5.55s/it]
data 70:  14%|█▎        | 70/512 [06:30<41:04,  5.57s/it]
INFO:root:函数头: 
def find_prev_keyword(sql, n_skip=0):

INFO:root:目标函数体: 
    
    if not sql.strip():
        return None, ''

    parsed = sqlparse.parse(sql)[0]
    flattened = list(parsed.flatten())
    flattened = flattened[:len(flattened) - n_skip]

    logical_operators = ('AND', 'OR', 'NOT', 'BETWEEN')

    for t in reversed(flattened):
        if t.value == '(' or (t.is_keyword and
                              (t.value.upper() not in logical_operators)
                             ):
            # Find the location of token t in the original parsed statement
            # We can't use parsed.token_index(t) because t may be a child token
            # inside a TokenList, in which case token_index thows an error
            # Minimal example:
            #   p = sqlparse.parse('select * from foo where bar')
            #   t = list(p.flatten())[-3]  # The "Where" token
            #   p.token_index(t)  # Throws ValueError: not in list
            idx = flattened.index(t)

            # Combine the string values of all tokens in the original list
            # up to and including the target keyword token t, to produce a
            # query string with everything after the keyword token removed
            text = ''.join(tok.value for tok in flattened[:idx + 1])
            return t, text

    return None, ''

INFO:root:生成结果: 
    tokens = sqlparse.parse(sql)
    if not tokens:
        return None, None

    last_token = tokens[-1]
    if last_token.token_type == sqlparse.tokens.Keyword:
        return last_token.value.lower(), sqlparse.sql.SQL(sql).strip(last_token.value.lower())

    return None, sqlstrip(last_token.value.lower())




INFO:root:----------------------------------------
INFO:root:max length: 12555
INFO:root:max position: 12904
INFO:root:target_namespace: mssql-cli.mssqlcli<folder>.packages<folder>.parseutils<folder>.utils<file>.find_prev_keyword<func>
INFO:root:****************************************

data 70:   0%|          | 0/512 [00:00<?, ?it/s]
data 70:   2%|▏         | 10/512 [00:51<43:09,  5.16s/it]
data 70:   4%|▍         | 20/512 [01:47<44:15,  5.40s/it]
data 70:   6%|▌         | 30/512 [02:42<43:54,  5.47s/it]
data 70:   8%|▊         | 40/512 [03:38<43:12,  5.49s/it]
data 70:  10%|▉         | 50/512 [04:33<42:28,  5.52s/it]
data 70:  12%|█▏        | 60/512 [05:26<41:03,  5.45s/it]
data 70:  12%|█▏        | 60/512 [06:12<46:47,  6.21s/it]
INFO:root:函数头: 
def find_prev_keyword(sql, n_skip=0):

INFO:root:目标函数体: 
    
    if not sql.strip():
        return None, ''

    parsed = sqlparse.parse(sql)[0]
    flattened = list(parsed.flatten())
    flattened = flattened[:len(flattened) - n_skip]

    logical_operators = ('AND', 'OR', 'NOT', 'BETWEEN')

    for t in reversed(flattened):
        if t.value == '(' or (t.is_keyword and
                              (t.value.upper() not in logical_operators)
                             ):
            # Find the location of token t in the original parsed statement
            # We can't use parsed.token_index(t) because t may be a child token
            # inside a TokenList, in which case token_index thows an error
            # Minimal example:
            #   p = sqlparse.parse('select * from foo where bar')
            #   t = list(p.flatten())[-3]  # The "Where" token
            #   p.token_index(t)  # Throws ValueError: not in list
            idx = flattened.index(t)

            # Combine the string values of all tokens in the original list
            # up to and including the target keyword token t, to produce a
            # query string with everything after the keyword token removed
            text = ''.join(tok.value for tok in flattened[:idx + 1])
            return t, text

    return None, ''

INFO:root:生成结果: 
    sql = sql.strip()
    tokens = sqlparse.parse(sql)
    keywords = [token for token in tokens if token.iskeyword]
    if keywords:
        last_keyword = keywords[-1]
        return last_keyword.value, sql[len(last_keyword.tokens[-1].value):].strip()
    return None, sql.strip()




INFO:root:----------------------------------------
INFO:root:max length: 12559
INFO:root:max position: 13093
INFO:root:target_namespace: mssql-cli.mssqlcli<folder>.packages<folder>.parseutils<folder>.utils<file>.find_prev_keyword<func>
INFO:root:****************************************

data 70:   0%|          | 0/512 [00:00<?, ?it/s]
data 70:   2%|▏         | 10/512 [00:51<43:07,  5.15s/it]
data 70:   4%|▍         | 20/512 [41:49<20:03:09, 146.73s/it]
data 70:   6%|▌         | 30/512 [42:46<11:01:05, 82.29s/it] 
data 70:   8%|▊         | 40/512 [43:42<6:49:27, 52.05s/it] 
data 70:  10%|▉         | 50/512 [44:38<4:31:37, 35.28s/it]
data 70:  12%|█▏        | 60/512 [45:34<3:09:49, 25.20s/it]
data 70:  14%|█▎        | 70/512 [46:29<2:18:15, 18.77s/it]
data 70:  16%|█▌        | 80/512 [47:25<1:44:51, 14.56s/it]
data 70:  18%|█▊        | 90/512 [48:21<1:22:40, 11.75s/it]
data 70:  18%|█▊        | 90/512 [49:11<3:50:36, 32.79s/it]
INFO:root:函数头: 
def find_prev_keyword(sql, n_skip=0):

INFO:root:目标函数体: 
    
    if not sql.strip():
        return None, ''

    parsed = sqlparse.parse(sql)[0]
    flattened = list(parsed.flatten())
    flattened = flattened[:len(flattened) - n_skip]

    logical_operators = ('AND', 'OR', 'NOT', 'BETWEEN')

    for t in reversed(flattened):
        if t.value == '(' or (t.is_keyword and
                              (t.value.upper() not in logical_operators)
                             ):
            # Find the location of token t in the original parsed statement
            # We can't use parsed.token_index(t) because t may be a child token
            # inside a TokenList, in which case token_index thows an error
            # Minimal example:
            #   p = sqlparse.parse('select * from foo where bar')
            #   t = list(p.flatten())[-3]  # The "Where" token
            #   p.token_index(t)  # Throws ValueError: not in list
            idx = flattened.index(t)

            # Combine the string values of all tokens in the original list
            # up to and including the target keyword token t, to produce a
            # query string with everything after the keyword token removed
            text = ''.join(tok.value for tok in flattened[:idx + 1])
            return t, text

    return None, ''

INFO:root:生成结果: 
    # Import sqlparse module
    import sqlparse

    # Parse SQL statement into tokens
    parsed_sql = sqlparse.parse(sql)

    # Get last token
    last_token = parsed_sql[-1][-1]

    # Get last keyword
    last_keyword = last_token.value.lower()

    # Get text of query with everything after last keyword stripped
    remaining_text = sqlparse.sql.SQL(sql).strip_tokens(last_token)

    return last_keyword, remaining_text




INFO:root:----------------------------------------
INFO:root:max length: 12899
INFO:root:max position: 13061
INFO:root:target_namespace: mssql-cli.mssqlcli<folder>.packages<folder>.parseutils<folder>.utils<file>.find_prev_keyword<func>
INFO:root:****************************************
INFO:root:--------data 71--------

data 71:   0%|          | 0/512 [00:00<?, ?it/s]
data 71:   2%|▏         | 10/512 [13:04<10:56:03, 78.41s/it]
data 71:   4%|▍         | 20/512 [14:11<4:57:17, 36.25s/it] 
data 71:   4%|▍         | 20/512 [14:16<5:51:08, 42.82s/it]
INFO:root:函数头: 
def text_(s, encoding='latin-1', errors='strict'):

INFO:root:目标函数体: 
    
    if isinstance(s, bytes):
        return s.decode(encoding, errors)
    return s

INFO:root:生成结果: 
    if isinstance(s, bytes):
        return s.decode(encoding, errors)
    return s




INFO:root:----------------------------------------
INFO:root:max length: 5796
INFO:root:max position: 9072
INFO:root:target_namespace: pyramid.src<folder>.pyramid<folder>.util<file>.text_<func>
INFO:root:****************************************

data 71:   0%|          | 0/512 [00:00<?, ?it/s]
data 71:   2%|▏         | 10/512 [01:01<51:52,  6.20s/it]
data 71:   4%|▍         | 20/512 [02:10<53:55,  6.58s/it]
data 71:   4%|▍         | 20/512 [02:15<55:28,  6.77s/it]
INFO:root:函数头: 
def text_(s, encoding='latin-1', errors='strict'):

INFO:root:目标函数体: 
    
    if isinstance(s, bytes):
        return s.decode(encoding, errors)
    return s

INFO:root:生成结果: 
    if isinstance(s, bytes):
        return s.decode(encoding, errors)
    return s




INFO:root:----------------------------------------
INFO:root:max length: 6410
INFO:root:max position: 9820
INFO:root:target_namespace: pyramid.src<folder>.pyramid<folder>.util<file>.text_<func>
INFO:root:****************************************

data 71:   0%|          | 0/512 [00:00<?, ?it/s]
data 71:   2%|▏         | 10/512 [01:01<51:08,  6.11s/it]
data 71:   4%|▍         | 20/512 [02:07<52:28,  6.40s/it]
data 71:   4%|▍         | 20/512 [02:14<55:09,  6.73s/it]
INFO:root:函数头: 
def text_(s, encoding='latin-1', errors='strict'):

INFO:root:目标函数体: 
    
    if isinstance(s, bytes):
        return s.decode(encoding, errors)
    return s

INFO:root:生成结果: 
    if isinstance(s, bytes):
        return s.decode(encoding, errors)
    return s




INFO:root:----------------------------------------
INFO:root:max length: 5918
INFO:root:max position: 9008
INFO:root:target_namespace: pyramid.src<folder>.pyramid<folder>.util<file>.text_<func>
INFO:root:****************************************

data 71:   0%|          | 0/512 [00:00<?, ?it/s]
data 71:   2%|▏         | 10/512 [01:02<52:23,  6.26s/it]
data 71:   4%|▍         | 20/512 [02:12<54:56,  6.70s/it]
data 71:   4%|▍         | 20/512 [02:20<57:28,  7.01s/it]
INFO:root:函数头: 
def text_(s, encoding='latin-1', errors='strict'):

INFO:root:目标函数体: 
    
    if isinstance(s, bytes):
        return s.decode(encoding, errors)
    return s

INFO:root:生成结果: 
    if isinstance(s, bytes):
        return s.decode(encoding, errors)
    return s




INFO:root:----------------------------------------
INFO:root:max length: 5900
INFO:root:max position: 8711
INFO:root:target_namespace: pyramid.src<folder>.pyramid<folder>.util<file>.text_<func>
INFO:root:****************************************

data 71:   0%|          | 0/512 [00:00<?, ?it/s]
data 71:   2%|▏         | 10/512 [01:00<50:21,  6.02s/it]
data 71:   4%|▍         | 20/512 [02:03<50:53,  6.21s/it]
data 71:   4%|▍         | 20/512 [02:11<54:06,  6.60s/it]
INFO:root:函数头: 
def text_(s, encoding='latin-1', errors='strict'):

INFO:root:目标函数体: 
    
    if isinstance(s, bytes):
        return s.decode(encoding, errors)
    return s

INFO:root:生成结果: 
    if isinstance(s, bytes):
        return s.decode(encoding, errors)
    return s




INFO:root:----------------------------------------
INFO:root:max length: 6436
INFO:root:max position: 9136
INFO:root:target_namespace: pyramid.src<folder>.pyramid<folder>.util<file>.text_<func>
INFO:root:****************************************
INFO:root:--------data 72--------

data 72:   0%|          | 0/512 [00:00<?, ?it/s]
data 72:   2%|▏         | 10/512 [00:10<08:59,  1.08s/it]
data 72:   4%|▍         | 20/512 [00:20<08:09,  1.01it/s]
data 72:   6%|▌         | 30/512 [00:29<07:49,  1.03it/s]
data 72:   8%|▊         | 40/512 [00:39<07:36,  1.03it/s]
data 72:  10%|▉         | 50/512 [00:48<07:23,  1.04it/s]
data 72:  12%|█▏        | 60/512 [00:58<07:12,  1.05it/s]
data 72:  12%|█▏        | 60/512 [00:59<07:25,  1.01it/s]
INFO:root:函数头: 
@hookimpl(specname="filters_from_request")
def where_filters(request, database, datasette):
    # This one deals with ?_where=

INFO:root:目标函数体: 
    async def inner():
        # Omit body code

    return inner

INFO:root:生成结果: 
    where_clauses = []
    extra_wheres_for_ui = []
    if "_where" in request.params:
        where_clauses.append(request.params["_where"])
        extra_wheres_for_ui.append(request.params["_where"])
    return FilterArguments(where_clauses, extra_wheres_for_ui)




INFO:root:----------------------------------------
INFO:root:max length: 4892
INFO:root:max position: 4892
INFO:root:target_namespace: datasette.datasette<folder>.filters<file>.where_filters<func>
INFO:root:****************************************

data 72:   0%|          | 0/512 [00:00<?, ?it/s]
data 72:   2%|▏         | 10/512 [00:08<07:20,  1.14it/s]
data 72:   4%|▍         | 20/512 [00:18<07:28,  1.10it/s]
data 72:   6%|▌         | 30/512 [00:27<07:23,  1.09it/s]
data 72:   8%|▊         | 40/512 [00:36<07:16,  1.08it/s]
data 72:  10%|▉         | 50/512 [00:46<07:09,  1.08it/s]
data 72:  12%|█▏        | 60/512 [00:55<06:59,  1.08it/s]
data 72:  12%|█▏        | 60/512 [00:56<07:04,  1.07it/s]
INFO:root:函数头: 
@hookimpl(specname="filters_from_request")
def where_filters(request, database, datasette):
    # This one deals with ?_where=

INFO:root:目标函数体: 
    async def inner():
        # Omit body code

    return inner

INFO:root:生成结果: 
    where_clauses = []
    extra_wheres_for_ui = []
    if "_where" in request.params:
        where_clauses.append(request.params["_where"])
        extra_wheres_for_ui.append(request.params["_where"])
    return FilterArguments(where_clauses, extra_wheres_for_ui)




INFO:root:----------------------------------------
INFO:root:max length: 4892
INFO:root:max position: 4892
INFO:root:target_namespace: datasette.datasette<folder>.filters<file>.where_filters<func>
INFO:root:****************************************

data 72:   0%|          | 0/512 [00:00<?, ?it/s]
data 72:   2%|▏         | 10/512 [00:08<07:15,  1.15it/s]
data 72:   4%|▍         | 20/512 [00:18<07:25,  1.10it/s]
data 72:   6%|▌         | 30/512 [00:27<07:26,  1.08it/s]
data 72:   8%|▊         | 40/512 [00:37<07:23,  1.07it/s]
data 72:  10%|▉         | 50/512 [00:46<07:13,  1.07it/s]
data 72:  12%|█▏        | 60/512 [00:55<07:02,  1.07it/s]
data 72:  12%|█▏        | 60/512 [00:56<07:07,  1.06it/s]
INFO:root:函数头: 
@hookimpl(specname="filters_from_request")
def where_filters(request, database, datasette):
    # This one deals with ?_where=

INFO:root:目标函数体: 
    async def inner():
        # Omit body code

    return inner

INFO:root:生成结果: 
    where_clauses = []
    extra_wheres_for_ui = []
    if "_where" in request.params:
        where_clauses.append(request.params["_where"])
        extra_wheres_for_ui.append(request.params["_where"])
    return FilterArguments(where_clauses, extra_wheres_for_ui)




INFO:root:----------------------------------------
INFO:root:max length: 4892
INFO:root:max position: 4892
INFO:root:target_namespace: datasette.datasette<folder>.filters<file>.where_filters<func>
INFO:root:****************************************

data 72:   0%|          | 0/512 [00:00<?, ?it/s]
data 72:   2%|▏         | 10/512 [00:08<07:19,  1.14it/s]
data 72:   4%|▍         | 20/512 [00:18<07:27,  1.10it/s]
data 72:   6%|▌         | 30/512 [00:27<07:24,  1.08it/s]
data 72:   8%|▊         | 40/512 [00:36<07:19,  1.07it/s]
data 72:  10%|▉         | 50/512 [00:46<07:12,  1.07it/s]
data 72:  12%|█▏        | 60/512 [00:55<07:01,  1.07it/s]
data 72:  14%|█▎        | 70/512 [01:05<06:54,  1.07it/s]
data 72:  16%|█▌        | 80/512 [01:14<06:44,  1.07it/s]
data 72:  18%|█▊        | 90/512 [01:23<06:36,  1.07it/s]
data 72:  20%|█▉        | 100/512 [01:33<06:26,  1.07it/s]
data 72:  21%|██▏       | 110/512 [01:42<06:17,  1.07it/s]
data 72:  21%|██▏       | 110/512 [01:46<06:28,  1.03it/s]
INFO:root:函数头: 
@hookimpl(specname="filters_from_request")
def where_filters(request, database, datasette):
    # This one deals with ?_where=

INFO:root:目标函数体: 
    async def inner():
        # Omit body code

    return inner

INFO:root:生成结果: 
    where_clauses = []
    extra_wheres_for_ui = []
    where_param = request.params.get("_where")
    if where_param:
        if not datasette.permission_allowed(request.actor, "execute_sql"):
            raise DatasetteError("You do not have permission to execute SQL")
        for clause in where_param.split("&"):
            key, value = clause.split("=")
            where_clauses.append((key, value))
            extra_wheres_for_ui.append((key, value))
    return FilterArguments(where_clauses, extra_wheres_for_ui)




INFO:root:----------------------------------------
INFO:root:max length: 5000
INFO:root:max position: 5000
INFO:root:target_namespace: datasette.datasette<folder>.filters<file>.where_filters<func>
INFO:root:****************************************

data 72:   0%|          | 0/512 [00:00<?, ?it/s]
data 72:   2%|▏         | 10/512 [00:08<07:17,  1.15it/s]
data 72:   4%|▍         | 20/512 [00:18<07:27,  1.10it/s]
data 72:   6%|▌         | 30/512 [00:27<07:22,  1.09it/s]
data 72:   8%|▊         | 40/512 [00:36<07:16,  1.08it/s]
data 72:  10%|▉         | 50/512 [00:46<07:08,  1.08it/s]
data 72:  12%|█▏        | 60/512 [00:55<07:01,  1.07it/s]
data 72:  14%|█▎        | 70/512 [01:04<06:52,  1.07it/s]
data 72:  16%|█▌        | 80/512 [01:13<06:41,  1.08it/s]
data 72:  18%|█▊        | 90/512 [01:23<06:32,  1.08it/s]
data 72:  20%|█▉        | 100/512 [01:32<06:24,  1.07it/s]
data 72:  21%|██▏       | 110/512 [01:42<06:14,  1.07it/s]
data 72:  21%|██▏       | 110/512 [01:44<06:23,  1.05it/s]
INFO:root:函数头: 
@hookimpl(specname="filters_from_request")
def where_filters(request, database, datasette):
    # This one deals with ?_where=

INFO:root:目标函数体: 
    async def inner():
        # Omit body code

    return inner

INFO:root:生成结果: 
    where_clauses = []
    extra_wheres_for_ui = []
    where_param = request.params.get("_where")
    if where_param:
        if not datasette.permissions.can_execute_sql(request.actor):
            raise DatasetteError("You do not have permission to execute SQL")
        for where_clause in where_param.split("&"):
            where_clauses.append(where_clause)
            extra_wheres_for_ui.append({"label": where_clause})
    return FilterArguments(where_clauses=where_clauses, extra_wheres_for_ui=extra_wheres_for_ui)




INFO:root:----------------------------------------
INFO:root:max length: 4944
INFO:root:max position: 4944
INFO:root:target_namespace: datasette.datasette<folder>.filters<file>.where_filters<func>
INFO:root:****************************************
INFO:root:--------data 73--------

data 73:   0%|          | 0/512 [00:00<?, ?it/s]
data 73:   2%|▏         | 10/512 [00:15<13:22,  1.60s/it]
data 73:   4%|▍         | 20/512 [00:29<12:05,  1.48s/it]
data 73:   6%|▌         | 30/512 [00:43<11:30,  1.43s/it]
data 73:   8%|▊         | 40/512 [01:00<11:57,  1.52s/it]
data 73:  10%|▉         | 50/512 [01:14<11:22,  1.48s/it]
data 73:  12%|█▏        | 60/512 [01:28<10:57,  1.46s/it]
data 73:  14%|█▎        | 70/512 [01:42<10:33,  1.43s/it]
data 73:  16%|█▌        | 80/512 [01:56<10:15,  1.42s/it]
data 73:  18%|█▊        | 90/512 [02:16<11:25,  1.62s/it]
data 73:  18%|█▊        | 90/512 [02:21<11:01,  1.57s/it]
INFO:root:函数头: 
def path_with_added_args(request, args, path=None):

INFO:root:目标函数体: 
    path = path or request.path
    if isinstance(args, dict):
        args = args.items()
    args_to_remove = {k for k, v in args if v is None}
    current = []
    for key, value in urllib.parse.parse_qsl(request.query_string):
        if key not in args_to_remove:
            current.append((key, value))
    current.extend([(key, value) for key, value in args if value is not None])
    query_string = urllib.parse.urlencode(current)
    if query_string:
        query_string = f"?{query_string}"
    return path + query_string

INFO:root:生成结果: 
    if path is None:
        path = request.path
    # Remove any leading slash from the path
    path = path.strip("/")
    # If there are no arguments, return the path as is
    if not args:
        return path
    # If there are arguments, append them to the path
    return f"{path}?{'&'.join(f'{key}={value}' for key, value in args.items())}"




INFO:root:----------------------------------------
INFO:root:max length: 10060
INFO:root:max position: 12638
INFO:root:target_namespace: datasette.datasette<folder>.utils<folder>.__init__<file>.path_with_added_args<func>
INFO:root:****************************************

data 73:   0%|          | 0/512 [00:00<?, ?it/s]
data 73:   2%|▏         | 10/512 [00:12<10:37,  1.27s/it]
data 73:   4%|▍         | 20/512 [00:26<10:55,  1.33s/it]
data 73:   6%|▌         | 30/512 [00:40<10:55,  1.36s/it]
data 73:   8%|▊         | 40/512 [00:56<11:34,  1.47s/it]
data 73:  10%|▉         | 50/512 [01:10<11:06,  1.44s/it]
data 73:  10%|▉         | 50/512 [01:20<12:23,  1.61s/it]
INFO:root:函数头: 
def path_with_added_args(request, args, path=None):

INFO:root:目标函数体: 
    path = path or request.path
    if isinstance(args, dict):
        args = args.items()
    args_to_remove = {k for k, v in args if v is None}
    current = []
    for key, value in urllib.parse.parse_qsl(request.query_string):
        if key not in args_to_remove:
            current.append((key, value))
    current.extend([(key, value) for key, value in args if value is not None])
    query_string = urllib.parse.urlencode(current)
    if query_string:
        query_string = f"?{query_string}"
    return path + query_string

INFO:root:生成结果: 
    if path is None:
        path = request.path
    path_parts = path.split("/")
    query_params = request.query_params.copy()
    query_params.update(args)
    query_string = urllib.parse.urlencode(query_params)
    return f"{path}/{query_string}"




INFO:root:----------------------------------------
INFO:root:max length: 9135
INFO:root:max position: 10993
INFO:root:target_namespace: datasette.datasette<folder>.utils<folder>.__init__<file>.path_with_added_args<func>
INFO:root:****************************************

data 73:   0%|          | 0/512 [00:00<?, ?it/s]
data 73:   2%|▏         | 10/512 [00:12<10:34,  1.26s/it]
data 73:   4%|▍         | 20/512 [00:26<10:56,  1.33s/it]
data 73:   6%|▌         | 30/512 [00:40<10:55,  1.36s/it]
data 73:   8%|▊         | 40/512 [00:54<10:44,  1.37s/it]
data 73:  10%|▉         | 50/512 [01:08<10:36,  1.38s/it]
data 73:  12%|█▏        | 60/512 [01:22<10:26,  1.39s/it]
data 73:  14%|█▎        | 70/512 [01:36<10:14,  1.39s/it]
data 73:  14%|█▎        | 70/512 [01:44<10:58,  1.49s/it]
INFO:root:函数头: 
def path_with_added_args(request, args, path=None):

INFO:root:目标函数体: 
    path = path or request.path
    if isinstance(args, dict):
        args = args.items()
    args_to_remove = {k for k, v in args if v is None}
    current = []
    for key, value in urllib.parse.parse_qsl(request.query_string):
        if key not in args_to_remove:
            current.append((key, value))
    current.extend([(key, value) for key, value in args if value is not None])
    query_string = urllib.parse.urlencode(current)
    if query_string:
        query_string = f"?{query_string}"
    return path + query_string

INFO:root:生成结果: 
    if path is None:
        path = request.path
    path_parts = path.split("/")
    query_string = request.query_string.decode("utf-0")
    query_params = dict(urllib.parse.parse_qs(query_string))
    query_params.update(args)
    query_string = urllib.parse.urlencode(query_params)
    return "/".join(path_parts + [query_string])




INFO:root:----------------------------------------
INFO:root:max length: 7103
INFO:root:max position: 7251
INFO:root:target_namespace: datasette.datasette<folder>.utils<folder>.__init__<file>.path_with_added_args<func>
INFO:root:****************************************

data 73:   0%|          | 0/512 [00:00<?, ?it/s]
data 73:   2%|▏         | 10/512 [00:12<10:32,  1.26s/it]
data 73:   4%|▍         | 20/512 [00:26<10:52,  1.33s/it]
data 73:   6%|▌         | 30/512 [00:39<10:48,  1.34s/it]
data 73:   8%|▊         | 40/512 [00:56<11:30,  1.46s/it]
data 73:  10%|▉         | 50/512 [01:10<11:04,  1.44s/it]
data 73:  12%|█▏        | 60/512 [01:24<10:40,  1.42s/it]
data 73:  14%|█▎        | 70/512 [01:40<10:56,  1.49s/it]
data 73:  16%|█▌        | 80/512 [01:54<10:28,  1.45s/it]
data 73:  18%|█▊        | 90/512 [02:14<11:24,  1.62s/it]
data 73:  20%|█▉        | 100/512 [02:30<11:10,  1.63s/it]
data 73:  20%|█▉        | 100/512 [02:40<10:59,  1.60s/it]
INFO:root:函数头: 
def path_with_added_args(request, args, path=None):

INFO:root:目标函数体: 
    path = path or request.path
    if isinstance(args, dict):
        args = args.items()
    args_to_remove = {k for k, v in args if v is None}
    current = []
    for key, value in urllib.parse.parse_qsl(request.query_string):
        if key not in args_to_remove:
            current.append((key, value))
    current.extend([(key, value) for key, value in args if value is not None])
    query_string = urllib.parse.urlencode(current)
    if query_string:
        query_string = f"?{query_string}"
    return path + query_string

INFO:root:生成结果: 
    if path is None:
        path = request.path

    # Process the input arguments
    processed_args = {}
    for key, value in args.items():
        if value is None:
            processed_args[key] = ""
        else:
            processed_args[key] = str(value)

    # Construct the new path with added arguments
    new_path = path
    for key, value in processed_args.items():
        new_path = new_path.replace(f":{key}", value)

    return new_path


INFO:root:----------------------------------------
INFO:root:max length: 8797
INFO:root:max position: 11247
INFO:root:target_namespace: datasette.datasette<folder>.utils<folder>.__init__<file>.path_with_added_args<func>
INFO:root:****************************************

data 73:   0%|          | 0/512 [00:00<?, ?it/s]
data 73:   2%|▏         | 10/512 [00:12<10:28,  1.25s/it]
data 73:   4%|▍         | 20/512 [00:26<10:51,  1.32s/it]
data 73:   6%|▌         | 30/512 [06:40<2:23:08, 17.82s/it]
data 73:   8%|▊         | 40/512 [06:59<1:30:39, 11.52s/it]
data 73:  10%|▉         | 50/512 [07:13<1:00:41,  7.88s/it]
data 73:  10%|▉         | 50/512 [07:26<1:08:42,  8.92s/it]
INFO:root:函数头: 
def path_with_added_args(request, args, path=None):

INFO:root:目标函数体: 
    path = path or request.path
    if isinstance(args, dict):
        args = args.items()
    args_to_remove = {k for k, v in args if v is None}
    current = []
    for key, value in urllib.parse.parse_qsl(request.query_string):
        if key not in args_to_remove:
            current.append((key, value))
    current.extend([(key, value) for key, value in args if value is not None])
    query_string = urllib.parse.urlencode(current)
    if query_string:
        query_string = f"?{query_string}"
    return path + query_string

INFO:root:生成结果: 
    if path is None:
        path = request.path
    path_parts = path.split("/")
    query_params = request.query_params.copy()
    query_params.update(args)
    query_string = urllib.parse.urlencode(query_params)
    return "/".join(path_parts + [query_string])




INFO:root:----------------------------------------
INFO:root:max length: 9335
INFO:root:max position: 11421
INFO:root:target_namespace: datasette.datasette<folder>.utils<folder>.__init__<file>.path_with_added_args<func>
INFO:root:****************************************
INFO:root:--------data 74--------

data 74:   0%|          | 0/512 [00:00<?, ?it/s]
data 74:   2%|▏         | 10/512 [00:32<26:59,  3.23s/it]
data 74:   4%|▍         | 20/512 [00:58<23:29,  2.87s/it]
data 74:   6%|▌         | 30/512 [01:20<20:46,  2.59s/it]
data 74:   8%|▊         | 40/512 [01:51<21:44,  2.76s/it]
data 74:  10%|▉         | 50/512 [02:27<23:38,  3.07s/it]
data 74:  12%|█▏        | 60/512 [03:05<25:06,  3.33s/it]
data 74:  14%|█▎        | 70/512 [03:41<25:09,  3.41s/it]
data 74:  16%|█▌        | 80/512 [04:05<22:15,  3.09s/it]
data 74:  18%|█▊        | 90/512 [04:30<20:25,  2.90s/it]
data 74:  20%|█▉        | 100/512 [05:00<20:12,  2.94s/it]
data 74:  21%|██▏       | 110/512 [14:27<2:09:51, 19.38s/it]
data 74:  23%|██▎       | 120/512 [14:57<1:34:07, 14.41s/it]
data 74:  25%|██▌       | 130/512 [15:37<1:11:38, 11.25s/it]
data 74:  27%|██▋       | 140/512 [16:14<55:33,  8.96s/it]  
data 74:  29%|██▉       | 150/512 [16:46<43:38,  7.23s/it]
data 74:  31%|███▏      | 160/512 [30:32<2:55:32, 29.92s/it]
data 74:  33%|███▎      | 170/512 [31:18<2:07:02, 22.29s/it]
data 74:  35%|███▌      | 180/512 [32:04<1:33:58, 16.98s/it]
data 74:  37%|███▋      | 190/512 [32:55<1:12:04, 13.43s/it]
data 74:  37%|███▋      | 190/512 [33:32<56:50, 10.59s/it]  
INFO:root:函数头: 
def path_with_replaced_args(request, args, path=None):

INFO:root:目标函数体: 
    path = path or request.path
    if isinstance(args, dict):
        args = args.items()
    keys_to_replace = {p[0] for p in args}
    current = []
    for key, value in urllib.parse.parse_qsl(request.query_string):
        if key not in keys_to_replace:
            current.append((key, value))
    current.extend([p for p in args if p[1] is not None])
    query_string = urllib.parse.urlencode(current)
    if query_string:
        query_string = f"?{query_string}"
    return path + query_string

INFO:root:生成结果: 
    path = path or request.path
    query_string = request.query_string
    if path is None:
        path = request.path
    else:
        if "?" in path:
            bits = path.split("?", 1)
            path = bits[0]
            query_string = bits[1]
    # args can be a dict or a set
    current = []
    if isinstance(args, set):
        def should_remove(key, value):
            return key in args

    elif isinstance(args, dict):
        # Must match key AND value
        def should_remove(key, value):
            return args.get(key) == value

    for key, value in urllib.parse.parse_qsl(query_string):
        if not should_remove(key, value):
            current.append((key, value))
    current.extend(args)
    query_string = urllib.parse.urlencode(current)
    if query_string:
        query_string = f"?{query_string}"
    return path + query_string




INFO:root:----------------------------------------
INFO:root:max length: 11028
INFO:root:max position: 13376
INFO:root:target_namespace: datasette.datasette<folder>.utils<folder>.__init__<file>.path_with_replaced_args<func>
INFO:root:****************************************

data 74:   0%|          | 0/512 [00:00<?, ?it/s]
data 74:   2%|▏         | 10/512 [00:23<19:58,  2.39s/it]
data 74:   4%|▍         | 20/512 [00:48<19:47,  2.41s/it]
data 74:   6%|▌         | 30/512 [01:12<19:27,  2.42s/it]
data 74:   8%|▊         | 40/512 [01:48<22:50,  2.90s/it]
data 74:  10%|▉         | 50/512 [02:30<25:55,  3.37s/it]
data 74:  12%|█▏        | 60/512 [03:10<26:47,  3.56s/it]
data 74:  14%|█▎        | 70/512 [03:43<25:38,  3.48s/it]
data 74:  16%|█▌        | 80/512 [04:06<22:17,  3.10s/it]
data 74:  18%|█▊        | 90/512 [13:39<2:21:08, 20.07s/it]
data 74:  20%|█▉        | 100/512 [14:07<1:41:02, 14.71s/it]
data 74:  21%|██▏       | 110/512 [14:34<1:14:03, 11.05s/it]
data 74:  23%|██▎       | 120/512 [15:02<55:42,  8.53s/it]  
data 74:  25%|██▌       | 130/512 [15:37<44:40,  7.02s/it]
data 74:  27%|██▋       | 140/512 [16:14<37:21,  6.03s/it]
data 74:  29%|██▉       | 150/512 [17:00<33:44,  5.59s/it]
data 74:  31%|███▏      | 160/512 [17:42<30:11,  5.15s/it]
data 74:  33%|███▎      | 170/512 [18:31<28:59,  5.08s/it]
data 74:  35%|███▌      | 180/512 [19:22<28:08,  5.08s/it]
data 74:  37%|███▋      | 190/512 [20:12<27:15,  5.08s/it]
data 74:  37%|███▋      | 190/512 [20:51<35:20,  6.59s/it]
INFO:root:函数头: 
def path_with_replaced_args(request, args, path=None):

INFO:root:目标函数体: 
    path = path or request.path
    if isinstance(args, dict):
        args = args.items()
    keys_to_replace = {p[0] for p in args}
    current = []
    for key, value in urllib.parse.parse_qsl(request.query_string):
        if key not in keys_to_replace:
            current.append((key, value))
    current.extend([p for p in args if p[1] is not None])
    query_string = urllib.parse.urlencode(current)
    if query_string:
        query_string = f"?{query_string}"
    return path + query_string

INFO:root:生成结果: 
    query_string = request.query_string
    if path is None:
        path = request.path
    else:
        if "?" in path:
            bits = path.split("?", 1)
            path, query_string = bits
    # args can be a dictionary or a set
    current = []
    if isinstance(args, set):
        def should_remove(key, value):
            return key in args

    elif isinstance(args, dict):
        # Must match key AND value
        def should_remove(key, value):
            return args.get(key) == value

    for key, value in urllib.parse.parse_qsl(query_string):
        if not should_remove(key, value):
            current.append((key, value))
    current.extend([(key, value) for key, value in args if value is not None])
    query_string = urllib.parse.urlencode(current)
    if query_string:
        query_string = f"?{query_string}"
    return path + query_string




INFO:root:----------------------------------------
INFO:root:max length: 12224
INFO:root:max position: 14603
INFO:root:target_namespace: datasette.datasette<folder>.utils<folder>.__init__<file>.path_with_replaced_args<func>
INFO:root:****************************************

data 74:   0%|          | 0/512 [00:00<?, ?it/s]
data 74:   2%|▏         | 10/512 [00:25<21:12,  2.53s/it]
data 74:   4%|▍         | 20/512 [00:50<20:40,  2.52s/it]
data 74:   6%|▌         | 30/512 [01:14<19:53,  2.48s/it]
data 74:   8%|▊         | 40/512 [01:51<23:19,  2.97s/it]
data 74:  10%|▉         | 50/512 [02:33<26:16,  3.41s/it]
data 74:  12%|█▏        | 60/512 [03:14<27:18,  3.62s/it]
data 74:  14%|█▎        | 70/512 [03:48<26:15,  3.56s/it]
data 74:  16%|█▌        | 80/512 [04:11<22:48,  3.17s/it]
data 74:  18%|█▊        | 90/512 [04:46<22:50,  3.25s/it]
data 74:  20%|█▉        | 100/512 [05:13<21:16,  3.10s/it]
data 74:  21%|██▏       | 110/512 [05:42<20:18,  3.03s/it]
data 74:  23%|██▎       | 120/512 [06:12<19:38,  3.01s/it]
data 74:  25%|██▌       | 130/512 [06:45<19:51,  3.12s/it]
data 74:  27%|██▋       | 140/512 [07:23<20:37,  3.33s/it]
data 74:  29%|██▉       | 150/512 [08:08<22:13,  3.68s/it]
data 74:  31%|███▏      | 160/512 [08:54<23:09,  3.95s/it]
data 74:  33%|███▎      | 170/512 [11:46<45:14,  7.94s/it]
data 74:  35%|███▌      | 180/512 [12:37<39:13,  7.09s/it]
data 74:  37%|███▋      | 190/512 [13:28<34:43,  6.47s/it]
data 74:  37%|███▋      | 190/512 [14:04<23:51,  4.45s/it]
INFO:root:函数头: 
def path_with_replaced_args(request, args, path=None):

INFO:root:目标函数体: 
    path = path or request.path
    if isinstance(args, dict):
        args = args.items()
    keys_to_replace = {p[0] for p in args}
    current = []
    for key, value in urllib.parse.parse_qsl(request.query_string):
        if key not in keys_to_replace:
            current.append((key, value))
    current.extend([p for p in args if p[1] is not None])
    query_string = urllib.parse.urlencode(current)
    if query_string:
        query_string = f"?{query_string}"
    return path + query_string

INFO:root:生成结果: 
    query_string = request.query_string
    if path is None:
        path = request.path
    else:
        if "?" in path:
            bits = path.split("?", 1)
            path, query_string = bits
    # args can be a dict or a set
    current = []
    if isinstance(args, set):
        def should_remove(key, value):
            return key in args

    elif isinstance(args, dict):
        # Must match key AND value
        def should_remove(key, value):
            return args.get(key) == value

    for key, value in urllib.parse.parse_qsl(query_string):
        if not should_remove(key, value):
            current.append((key, value))
    current.extend([(key, value) for key, value in args if value is not None])
    query_string = urllib.parse.urlencode(current)
    if query_string:
        query_string = f"?{query_string}"
    return path + query_string




INFO:root:----------------------------------------
INFO:root:max length: 11464
INFO:root:max position: 13623
INFO:root:target_namespace: datasette.datasette<folder>.utils<folder>.__init__<file>.path_with_replaced_args<func>
INFO:root:****************************************

data 74:   0%|          | 0/512 [00:00<?, ?it/s]
data 74:   2%|▏         | 10/512 [00:23<19:56,  2.38s/it]
data 74:   4%|▍         | 20/512 [00:48<19:45,  2.41s/it]
data 74:   6%|▌         | 30/512 [01:13<19:42,  2.45s/it]
data 74:   8%|▊         | 40/512 [01:49<23:03,  2.93s/it]
data 74:  10%|▉         | 50/512 [02:23<23:44,  3.08s/it]
data 74:  12%|█▏        | 60/512 [03:05<26:04,  3.46s/it]
data 74:  14%|█▎        | 70/512 [03:38<25:07,  3.41s/it]
data 74:  16%|█▌        | 80/512 [04:01<22:01,  3.06s/it]
data 74:  18%|█▊        | 90/512 [04:37<22:49,  3.25s/it]
data 74:  20%|█▉        | 100/512 [05:05<21:15,  3.10s/it]
data 74:  21%|██▏       | 110/512 [05:32<20:00,  2.99s/it]
data 74:  23%|██▎       | 120/512 [06:01<19:18,  2.96s/it]
data 74:  25%|██▌       | 130/512 [06:38<20:11,  3.17s/it]
data 74:  27%|██▋       | 140/512 [07:15<20:34,  3.32s/it]
data 74:  29%|██▉       | 150/512 [07:59<22:05,  3.66s/it]
data 74:  31%|███▏      | 160/512 [08:41<22:28,  3.83s/it]
data 74:  33%|███▎      | 170/512 [09:31<23:47,  4.18s/it]
data 74:  35%|███▌      | 180/512 [10:23<24:48,  4.48s/it]
data 74:  37%|███▋      | 190/512 [11:12<24:42,  4.60s/it]
data 74:  37%|███▋      | 190/512 [11:48<20:00,  3.73s/it]
INFO:root:函数头: 
def path_with_replaced_args(request, args, path=None):

INFO:root:目标函数体: 
    path = path or request.path
    if isinstance(args, dict):
        args = args.items()
    keys_to_replace = {p[0] for p in args}
    current = []
    for key, value in urllib.parse.parse_qsl(request.query_string):
        if key not in keys_to_replace:
            current.append((key, value))
    current.extend([p for p in args if p[1] is not None])
    query_string = urllib.parse.urlencode(current)
    if query_string:
        query_string = f"?{query_string}"
    return path + query_string

INFO:root:生成结果: 
    query_string = request.query_string
    if path is None:
        path = request.path
    else:
        if "?" in path:
            bits = path.split("?", 1)
            path, query_string = bits
    # args can be a dict or a set
    current = []
    if isinstance(args, set):
        def should_remove(key, value):
            return key in args

    elif isinstance(args, dict):
        # Must match key AND value
        def should_remove(key, value):
            return args.get(key) == value

    for key, value in urllib.parse.parse_qsl(query_string):
        if not should_remove(key, value):
            current.append((key, value))
    current.extend([(key, value) for key, value in args if value is not None])
    query_string = urllib.parse.urlencode(current)
    if query_string:
        query_string = f"?{query_string}"
    return path + query_string




INFO:root:----------------------------------------
INFO:root:max length: 11483
INFO:root:max position: 12878
INFO:root:target_namespace: datasette.datasette<folder>.utils<folder>.__init__<file>.path_with_replaced_args<func>
INFO:root:****************************************

data 74:   0%|          | 0/512 [00:00<?, ?it/s]
data 74:   2%|▏         | 10/512 [00:23<19:54,  2.38s/it]
data 74:   4%|▍         | 20/512 [00:48<19:55,  2.43s/it]
data 74:   6%|▌         | 30/512 [01:13<19:42,  2.45s/it]
data 74:   8%|▊         | 40/512 [01:48<22:39,  2.88s/it]
data 74:  10%|▉         | 50/512 [02:24<24:05,  3.13s/it]
data 74:  12%|█▏        | 60/512 [02:59<24:29,  3.25s/it]
data 74:  14%|█▎        | 70/512 [03:34<24:39,  3.35s/it]
data 74:  16%|█▌        | 80/512 [03:57<21:44,  3.02s/it]
data 74:  18%|█▊        | 90/512 [04:30<21:50,  3.10s/it]
data 74:  20%|█▉        | 100/512 [04:55<20:05,  2.93s/it]
data 74:  21%|██▏       | 110/512 [05:23<19:16,  2.88s/it]
data 74:  23%|██▎       | 120/512 [05:52<18:51,  2.89s/it]
data 74:  25%|██▌       | 130/512 [06:28<19:37,  3.08s/it]
data 74:  27%|██▋       | 140/512 [07:06<20:29,  3.31s/it]
data 74:  29%|██▉       | 150/512 [07:52<22:21,  3.71s/it]
data 74:  31%|███▏      | 160/512 [08:35<22:49,  3.89s/it]
data 74:  33%|███▎      | 170/512 [09:27<24:19,  4.27s/it]
data 74:  35%|███▌      | 180/512 [10:17<24:53,  4.50s/it]
data 74:  37%|███▋      | 190/512 [11:09<25:11,  4.69s/it]
data 74:  37%|███▋      | 190/512 [11:45<19:55,  3.71s/it]
INFO:root:函数头: 
def path_with_replaced_args(request, args, path=None):

INFO:root:目标函数体: 
    path = path or request.path
    if isinstance(args, dict):
        args = args.items()
    keys_to_replace = {p[0] for p in args}
    current = []
    for key, value in urllib.parse.parse_qsl(request.query_string):
        if key not in keys_to_replace:
            current.append((key, value))
    current.extend([p for p in args if p[1] is not None])
    query_string = urllib.parse.urlencode(current)
    if query_string:
        query_string = f"?{query_string}"
    return path + query_string

INFO:root:生成结果: 
    query_string = request.query_string
    if path is None:
        path = request.path
    else:
        if "?" in path:
            bits = path.split("?", 1)
            path, query_string = bits
    # args can be a dict or a set
    current = []
    if isinstance(args, set):

        def should_remove(key, value):
            return key in args

    elif isinstance(args, dict):
        # Must match key AND value
        def should_remove(key, value):
            return args.get(key) == value

    for key, value in urllib.parse.parse_qsl(query_string):
        if not should_remove(key, value):
            current.append((key, value))
    current.extend([(key, value) for key, value in args if value is not None])
    query_string = urllib.parse.urlencode(current)
    if query_string:
        query_string = f"?{query_string}"
    return path + query_string




INFO:root:----------------------------------------
INFO:root:max length: 11156
INFO:root:max position: 13143
INFO:root:target_namespace: datasette.datasette<folder>.utils<folder>.__init__<file>.path_with_replaced_args<func>
INFO:root:****************************************
INFO:root:--------data 75--------

data 75:   0%|          | 0/512 [00:00<?, ?it/s]
data 75:   2%|▏         | 10/512 [00:43<36:21,  4.35s/it]
data 75:   4%|▍         | 20/512 [01:24<34:27,  4.20s/it]
data 75:   6%|▌         | 30/512 [01:53<28:59,  3.61s/it]
data 75:   8%|▊         | 40/512 [02:26<27:17,  3.47s/it]
data 75:  10%|▉         | 50/512 [11:59<2:56:14, 22.89s/it]
data 75:  12%|█▏        | 60/512 [16:44<3:06:44, 24.79s/it]
data 75:  14%|█▎        | 70/512 [17:18<2:11:12, 17.81s/it]
data 75:  14%|█▎        | 70/512 [17:43<1:51:57, 15.20s/it]
INFO:root:函数头: 
def format_bytes(bytes):

INFO:root:目标函数体: 
    current = float(bytes)
    for unit in ("bytes", "KB", "MB", "GB", "TB"):
        if current < 1024:
            break
        current = current / 1024
    if unit == "bytes":
        return f"{int(current)} {unit}"
    else:
        return f"{current:.1f} {unit}"

INFO:root:生成结果: 
    units = ["bytes", "KB", "MB", "GB", "TB"]
    unit_index = 0
    while bytes >= 1024 and unit_index < len(units) - 1:
        bytes /= 1024
        unit_index += 1
    return f"{bytes:.2f} {units[unit_index]}"




INFO:root:----------------------------------------
INFO:root:max length: 10286
INFO:root:max position: 12711
INFO:root:target_namespace: datasette.datasette<folder>.utils<folder>.__init__<file>.format_bytes<func>
INFO:root:****************************************

data 75:   0%|          | 0/512 [00:00<?, ?it/s]
data 75:   2%|▏         | 10/512 [00:37<31:11,  3.73s/it]
data 75:   4%|▍         | 20/512 [01:11<29:06,  3.55s/it]
data 75:   6%|▌         | 30/512 [01:49<29:18,  3.65s/it]
data 75:   8%|▊         | 40/512 [02:28<29:35,  3.76s/it]
data 75:  10%|▉         | 50/512 [03:02<27:55,  3.63s/it]
data 75:  12%|█▏        | 60/512 [03:41<27:55,  3.71s/it]
data 75:  14%|█▎        | 70/512 [04:16<26:50,  3.64s/it]
data 75:  16%|█▌        | 80/512 [04:47<25:00,  3.47s/it]
data 75:  16%|█▌        | 80/512 [04:55<26:33,  3.69s/it]
INFO:root:函数头: 
def format_bytes(bytes):

INFO:root:目标函数体: 
    current = float(bytes)
    for unit in ("bytes", "KB", "MB", "GB", "TB"):
        if current < 1024:
            break
        current = current / 1024
    if unit == "bytes":
        return f"{int(current)} {unit}"
    else:
        return f"{current:.1f} {unit}"

INFO:root:生成结果: 
    if bytes == 0:
        return "0 bytes"

    units = ["bytes", "KB", "MB", "GB", "TB"]
    unit_index = int(math.log(bytes, 1024)) if bytes > 0 else 0
    return f"{bytes / (1024 ** unit_index):.2f} {units[unit_index]}"




INFO:root:----------------------------------------
INFO:root:max length: 12106
INFO:root:max position: 13557
INFO:root:target_namespace: datasette.datasette<folder>.utils<folder>.__init__<file>.format_bytes<func>
INFO:root:****************************************

data 75:   0%|          | 0/512 [00:00<?, ?it/s]
data 75:   2%|▏         | 10/512 [00:37<31:33,  3.77s/it]
data 75:   4%|▍         | 20/512 [12:14<5:48:45, 42.53s/it]
data 75:   6%|▌         | 30/512 [12:49<3:18:27, 24.70s/it]
data 75:   8%|▊         | 40/512 [15:29<2:47:29, 21.29s/it]
data 75:  10%|▉         | 50/512 [16:08<1:55:35, 15.01s/it]
data 75:  12%|█▏        | 60/512 [16:52<1:25:54, 11.40s/it]
data 75:  12%|█▏        | 60/512 [17:23<2:11:02, 17.40s/it]
INFO:root:函数头: 
def format_bytes(bytes):

INFO:root:目标函数体: 
    current = float(bytes)
    for unit in ("bytes", "KB", "MB", "GB", "TB"):
        if current < 1024:
            break
        current = current / 1024
    if unit == "bytes":
        return f"{int(current)} {unit}"
    else:
        return f"{current:.1f} {unit}"

INFO:root:生成结果: 
    units = ["bytes", "KB", "MB", "GB", "TB"]
    for unit in units:
        if bytes < 1024:
            return f"{bytes:.2f} {unit}"
        bytes /= 1024
    return f"{bytes:.2f} TB"


INFO:root:----------------------------------------
INFO:root:max length: 11068
INFO:root:max position: 13637
INFO:root:target_namespace: datasette.datasette<folder>.utils<folder>.__init__<file>.format_bytes<func>
INFO:root:****************************************

data 75:   0%|          | 0/512 [00:00<?, ?it/s]
data 75:   2%|▏         | 10/512 [00:41<34:39,  4.14s/it]
data 75:   4%|▍         | 20/512 [01:18<32:04,  3.91s/it]
data 75:   6%|▌         | 30/512 [01:52<29:19,  3.65s/it]
data 75:   8%|▊         | 40/512 [02:27<28:20,  3.60s/it]
data 75:  10%|▉         | 50/512 [02:58<26:11,  3.40s/it]
data 75:  12%|█▏        | 60/512 [03:39<27:37,  3.67s/it]
data 75:  12%|█▏        | 60/512 [04:19<32:35,  4.33s/it]
INFO:root:函数头: 
def format_bytes(bytes):

INFO:root:目标函数体: 
    current = float(bytes)
    for unit in ("bytes", "KB", "MB", "GB", "TB"):
        if current < 1024:
            break
        current = current / 1024
    if unit == "bytes":
        return f"{int(current)} {unit}"
    else:
        return f"{current:.1f} {unit}"

INFO:root:生成结果: 
    if bytes == 0:
        return "0 bytes"
    units = ["bytes", "KB", "MB", "GB", "TB"]
    i = int(math.log(bytes) / math.log(1 << 10))
    return f"{bytes / (1 << i):.1f} {units[i]}"


INFO:root:----------------------------------------
INFO:root:max length: 10899
INFO:root:max position: 12709
INFO:root:target_namespace: datasette.datasette<folder>.utils<folder>.__init__<file>.format_bytes<func>
INFO:root:****************************************

data 75:   0%|          | 0/512 [00:00<?, ?it/s]
data 75:   2%|▏         | 10/512 [00:39<33:20,  3.99s/it]
data 75:   4%|▍         | 20/512 [01:18<32:11,  3.93s/it]
data 75:   6%|▌         | 30/512 [01:50<28:41,  3.57s/it]
data 75:   8%|▊         | 40/512 [02:27<28:42,  3.65s/it]
data 75:  10%|▉         | 50/512 [03:01<27:23,  3.56s/it]
data 75:  12%|█▏        | 60/512 [03:44<28:37,  3.80s/it]
data 75:  14%|█▎        | 70/512 [12:23<2:23:46, 19.52s/it]
data 75:  14%|█▎        | 70/512 [12:48<1:20:51, 10.98s/it]
INFO:root:函数头: 
def format_bytes(bytes):

INFO:root:目标函数体: 
    current = float(bytes)
    for unit in ("bytes", "KB", "MB", "GB", "TB"):
        if current < 1024:
            break
        current = current / 1024
    if unit == "bytes":
        return f"{int(current)} {unit}"
    else:
        return f"{current:.1f} {unit}"

INFO:root:生成结果: 
    units = ["bytes", "KB", "MB", "GB", "TB"]
    unit_index = 0
    while bytes >= 1 << (unit_index * 10):
        bytes /= 1 << (unit_index * 10)
        unit_index += 1
    return f"{bytes:.2f} {units[unit_index]}"




INFO:root:----------------------------------------
INFO:root:max length: 10629
INFO:root:max position: 12719
INFO:root:target_namespace: datasette.datasette<folder>.utils<folder>.__init__<file>.format_bytes<func>
INFO:root:****************************************
INFO:root:--------data 76--------

data 76:   0%|          | 0/512 [00:00<?, ?it/s]
data 76:   2%|▏         | 10/512 [00:40<34:13,  4.09s/it]
data 76:   4%|▍         | 20/512 [01:18<31:59,  3.90s/it]
data 76:   4%|▍         | 20/512 [01:21<33:26,  4.08s/it]
INFO:root:函数头: 
def actor_matches_allow(actor, allow):

INFO:root:目标函数体: 
    if allow is True:
        return True
    if allow is False:
        return False
    if actor is None and allow and allow.get("unauthenticated") is True:
        return True
    if allow is None:
        return True
    actor = actor or {}
    for key, values in allow.items():
        if values == "*" and key in actor:
            return True
        if not isinstance(values, list):
            values = [values]
        actor_values = actor.get(key)
        if actor_values is None:
            continue
        if not isinstance(actor_values, list):
            actor_values = [actor_values]
        actor_values = set(actor_values)
        if actor_values.intersection(values):
            return True
    return False

INFO:root:生成结果: 
    # Implement the logic to check if the actor matches the allow condition here
    pass


INFO:root:----------------------------------------
INFO:root:max length: 9460
INFO:root:max position: 11997
INFO:root:target_namespace: datasette.datasette<folder>.utils<folder>.__init__<file>.actor_matches_allow<func>
INFO:root:****************************************

data 76:   0%|          | 0/512 [00:00<?, ?it/s]
data 76:   2%|▏         | 10/512 [00:34<28:52,  3.45s/it]
data 76:   2%|▏         | 10/512 [00:51<43:27,  5.19s/it]
INFO:root:函数头: 
def actor_matches_allow(actor, allow):

INFO:root:目标函数体: 
    if allow is True:
        return True
    if allow is False:
        return False
    if actor is None and allow and allow.get("unauthenticated") is True:
        return True
    if allow is None:
        return True
    actor = actor or {}
    for key, values in allow.items():
        if values == "*" and key in actor:
            return True
        if not isinstance(values, list):
            values = [values]
        actor_values = actor.get(key)
        if actor_values is None:
            continue
        if not isinstance(actor_values, list):
            actor_values = [actor_values]
        actor_values = set(actor_values)
        if actor_values.intersection(values):
            return True
    return False

INFO:root:生成结果: 
    # Implement the actor matching logic here
    pass


INFO:root:----------------------------------------
INFO:root:max length: 8831
INFO:root:max position: 10961
INFO:root:target_namespace: datasette.datasette<folder>.utils<folder>.__init__<file>.actor_matches_allow<func>
INFO:root:****************************************

data 76:   0%|          | 0/512 [00:00<?, ?it/s]
data 76:   2%|▏         | 10/512 [00:28<23:35,  2.82s/it]
data 76:   4%|▍         | 20/512 [01:03<26:41,  3.25s/it]
data 76:   6%|▌         | 30/512 [06:38<2:16:49, 17.03s/it]
data 76:   8%|▊         | 40/512 [07:12<1:31:54, 11.68s/it]
data 76:  10%|▉         | 50/512 [07:45<1:06:32,  8.64s/it]
data 76:  10%|▉         | 50/512 [08:19<1:16:59, 10.00s/it]
INFO:root:函数头: 
def actor_matches_allow(actor, allow):

INFO:root:目标函数体: 
    if allow is True:
        return True
    if allow is False:
        return False
    if actor is None and allow and allow.get("unauthenticated") is True:
        return True
    if allow is None:
        return True
    actor = actor or {}
    for key, values in allow.items():
        if values == "*" and key in actor:
            return True
        if not isinstance(values, list):
            values = [values]
        actor_values = actor.get(key)
        if actor_values is None:
            continue
        if not isinstance(actor_values, list):
            actor_values = [actor_values]
        actor_values = set(actor_values)
        if actor_values.intersection(values):
            return True
    return False

INFO:root:生成结果: 
    if isinstance(allow, str):
        return actor == allow
    elif isinstance(allow, list):
        return actor in allow
    elif callable(allow):
        return allow(actor)
    else:
        raise ValueError(f"Unsupported allow condition type: {type(allow)}")


INFO:root:----------------------------------------
INFO:root:max length: 10674
INFO:root:max position: 12457
INFO:root:target_namespace: datasette.datasette<folder>.utils<folder>.__init__<file>.actor_matches_allow<func>
INFO:root:****************************************

data 76:   0%|          | 0/512 [00:00<?, ?it/s]
data 76:   2%|▏         | 10/512 [00:33<27:50,  3.33s/it]
data 76:   2%|▏         | 10/512 [00:36<30:11,  3.61s/it]
INFO:root:函数头: 
def actor_matches_allow(actor, allow):

INFO:root:目标函数体: 
    if allow is True:
        return True
    if allow is False:
        return False
    if actor is None and allow and allow.get("unauthenticated") is True:
        return True
    if allow is None:
        return True
    actor = actor or {}
    for key, values in allow.items():
        if values == "*" and key in actor:
            return True
        if not isinstance(values, list):
            values = [values]
        actor_values = actor.get(key)
        if actor_values is None:
            continue
        if not isinstance(actor_values, list):
            actor_values = [actor_values]
        actor_values = set(actor_values)
        if actor_values.intersection(values):
            return True
    return False

INFO:root:生成结果: 
    # Implement the actor matching logic here


INFO:root:----------------------------------------
INFO:root:max length: 7890
INFO:root:max position: 10584
INFO:root:target_namespace: datasette.datasette<folder>.utils<folder>.__init__<file>.actor_matches_allow<func>
INFO:root:****************************************

data 76:   0%|          | 0/512 [00:00<?, ?it/s]
data 76:   2%|▏         | 10/512 [00:27<23:23,  2.80s/it]
data 76:   4%|▍         | 20/512 [01:04<26:54,  3.28s/it]
data 76:   6%|▌         | 30/512 [01:41<28:05,  3.50s/it]
data 76:   8%|▊         | 40/512 [02:26<30:35,  3.89s/it]
data 76:  10%|▉         | 50/512 [03:00<28:36,  3.72s/it]
data 76:  12%|█▏        | 60/512 [03:31<26:22,  3.50s/it]
data 76:  14%|█▎        | 70/512 [04:09<26:31,  3.60s/it]
data 76:  16%|█▌        | 80/512 [04:36<23:55,  3.32s/it]
data 76:  16%|█▌        | 80/512 [05:04<27:23,  3.80s/it]
INFO:root:函数头: 
def actor_matches_allow(actor, allow):

INFO:root:目标函数体: 
    if allow is True:
        return True
    if allow is False:
        return False
    if actor is None and allow and allow.get("unauthenticated") is True:
        return True
    if allow is None:
        return True
    actor = actor or {}
    for key, values in allow.items():
        if values == "*" and key in actor:
            return True
        if not isinstance(values, list):
            values = [values]
        actor_values = actor.get(key)
        if actor_values is None:
            continue
        if not isinstance(actor_values, list):
            actor_values = [actor_values]
        actor_values = set(actor_values)
        if actor_values.intersection(values):
            return True
    return False

INFO:root:生成结果: 
    if isinstance(allow, str):
        if allow == "*":
            return True
        elif allow == "none":
            return False
        else:
            raise ValueError(f"Invalid allow condition: {allow}")
    elif isinstance(allow, list):
        return actor in allow
    elif isinstance(allow, dict):
        return actor in allow.values()
    else:
        raise ValueError(f"Invalid allow condition: {allow}")


INFO:root:----------------------------------------
INFO:root:max length: 10462
INFO:root:max position: 12890
INFO:root:target_namespace: datasette.datasette<folder>.utils<folder>.__init__<file>.actor_matches_allow<func>
INFO:root:****************************************
INFO:root:--------data 77--------

data 77:   0%|          | 0/512 [00:00<?, ?it/s]
data 77:   2%|▏         | 10/512 [00:32<27:19,  3.27s/it]
data 77:   4%|▍         | 20/512 [01:06<27:24,  3.34s/it]
data 77:   6%|▌         | 30/512 [01:41<27:16,  3.39s/it]
data 77:   8%|▊         | 40/512 [02:04<23:18,  2.96s/it]
data 77:  10%|▉         | 50/512 [02:37<23:47,  3.09s/it]
data 77:  12%|█▏        | 60/512 [03:00<21:11,  2.81s/it]
data 77:  14%|█▎        | 70/512 [03:20<18:58,  2.58s/it]
data 77:  16%|█▌        | 80/512 [03:42<17:29,  2.43s/it]
data 77:  18%|█▊        | 90/512 [04:04<16:38,  2.37s/it]
data 77:  20%|█▉        | 100/512 [04:43<19:29,  2.84s/it]
data 77:  21%|██▏       | 110/512 [05:19<20:40,  3.09s/it]
data 77:  23%|██▎       | 120/512 [05:53<20:37,  3.16s/it]
data 77:  25%|██▌       | 130/512 [06:24<20:00,  3.14s/it]
data 77:  27%|██▋       | 140/512 [07:03<20:59,  3.38s/it]
data 77:  29%|██▉       | 150/512 [07:39<20:43,  3.44s/it]
data 77:  29%|██▉       | 150/512 [07:46<18:46,  3.11s/it]
INFO:root:函数头: 
def resolve_env_secrets(config, environ):

INFO:root:目标函数体: 
    
    if isinstance(config, dict):
        if list(config.keys()) == ["$env"]:
            return environ.get(list(config.values())[0])
        elif list(config.keys()) == ["$file"]:
            return open(list(config.values())[0]).read()
        else:
            return {
                key: resolve_env_secrets(value, environ)
                for key, value in config.items()
            }
    elif isinstance(config, list):
        return [resolve_env_secrets(value, environ) for value in config]
    else:
        return config

INFO:root:生成结果: 
    if isinstance(config, dict):
        return {key: resolve_env_secrets(value, environ) for key, value in config.items()}
    elif isinstance(config, list):
        return [resolve_env_secrets(item, environ) for item in config]
    elif isinstance(config, str):
        if config.startswith("$env"):
            env_var_name = config[4:]
            return environ.get(env_var_name, config)
        elif config.startswith("$file"):
            file_name = config[5:]
            try:
                with open(file_name, "r") as f:
                    return f.read()
            except FileNotFoundError:
                raise ValueError(f"File not found: {file_name}")
        else:
            return config
    else:
        return config


INFO:root:----------------------------------------
INFO:root:max length: 11288
INFO:root:max position: 14051
INFO:root:target_namespace: datasette.datasette<folder>.utils<folder>.__init__<file>.resolve_env_secrets<func>
INFO:root:****************************************

data 77:   0%|          | 0/512 [00:00<?, ?it/s]
data 77:   2%|▏         | 10/512 [00:31<26:33,  3.17s/it]
data 77:   4%|▍         | 20/512 [01:05<26:51,  3.27s/it]
data 77:   6%|▌         | 30/512 [01:39<26:44,  3.33s/it]
data 77:   8%|▊         | 40/512 [02:01<22:47,  2.90s/it]
data 77:  10%|▉         | 50/512 [02:34<23:26,  3.04s/it]
data 77:  12%|█▏        | 60/512 [02:56<20:50,  2.77s/it]
data 77:  14%|█▎        | 70/512 [03:18<18:51,  2.56s/it]
data 77:  14%|█▎        | 70/512 [03:32<22:18,  3.03s/it]
INFO:root:函数头: 
def resolve_env_secrets(config, environ):

INFO:root:目标函数体: 
    
    if isinstance(config, dict):
        if list(config.keys()) == ["$env"]:
            return environ.get(list(config.values())[0])
        elif list(config.keys()) == ["$file"]:
            return open(list(config.values())[0]).read()
        else:
            return {
                key: resolve_env_secrets(value, environ)
                for key, value in config.items()
            }
    elif isinstance(config, list):
        return [resolve_env_secrets(value, environ) for value in config]
    else:
        return config

INFO:root:生成结果: 
    if isinstance(config, dict):
        return {k: resolve_env_secrets(v, environ) for k, v in config.items()}
    elif isinstance(config, list):
        return [resolve_env_secrets(v, environ) for v in config]
    elif isinstance(config, str):
        return config.format(**environs)
    else:
        return config




INFO:root:----------------------------------------
INFO:root:max length: 9203
INFO:root:max position: 11817
INFO:root:target_namespace: datasette.datasette<folder>.utils<folder>.__init__<file>.resolve_env_secrets<func>
INFO:root:****************************************

data 77:   0%|          | 0/512 [00:00<?, ?it/s]
data 77:   2%|▏         | 10/512 [00:29<24:25,  2.92s/it]
data 77:   4%|▍         | 20/512 [01:01<25:29,  3.11s/it]
data 77:   6%|▌         | 30/512 [01:33<25:16,  3.15s/it]
data 77:   8%|▊         | 40/512 [01:56<22:01,  2.80s/it]
data 77:  10%|▉         | 50/512 [02:29<23:04,  3.00s/it]
data 77:  12%|█▏        | 60/512 [04:53<51:39,  6.86s/it]
data 77:  14%|█▎        | 70/512 [05:15<39:17,  5.33s/it]
data 77:  14%|█▎        | 70/512 [05:26<34:21,  4.66s/it]
INFO:root:函数头: 
def resolve_env_secrets(config, environ):

INFO:root:目标函数体: 
    
    if isinstance(config, dict):
        if list(config.keys()) == ["$env"]:
            return environ.get(list(config.values())[0])
        elif list(config.keys()) == ["$file"]:
            return open(list(config.values())[0]).read()
        else:
            return {
                key: resolve_env_secrets(value, environ)
                for key, value in config.items()
            }
    elif isinstance(config, list):
        return [resolve_env_secrets(value, environ) for value in config]
    else:
        return config

INFO:root:生成结果: 
    if isinstance(config, dict):
        return {k: resolve_env_secrets(v, environ) for k, v in config.items()}
    elif isinstance(config, list):
        return [resolve_env_secrets(v, environ) for v in config]
    elif isinstance(config, str):
        return config.format(**environ)
    else:
        return config




INFO:root:----------------------------------------
INFO:root:max length: 9684
INFO:root:max position: 11970
INFO:root:target_namespace: datasette.datasette<folder>.utils<folder>.__init__<file>.resolve_env_secrets<func>
INFO:root:****************************************

data 77:   0%|          | 0/512 [00:00<?, ?it/s]
data 77:   2%|▏         | 10/512 [00:28<23:42,  2.83s/it]
data 77:   4%|▍         | 20/512 [00:59<24:40,  3.01s/it]
data 77:   6%|▌         | 30/512 [01:32<25:11,  3.14s/it]
data 77:   8%|▊         | 40/512 [01:55<21:55,  2.79s/it]
data 77:  10%|▉         | 50/512 [02:25<22:07,  2.87s/it]
data 77:  12%|█▏        | 60/512 [02:47<19:59,  2.65s/it]
data 77:  14%|█▎        | 70/512 [03:09<18:24,  2.50s/it]
data 77:  14%|█▎        | 70/512 [03:27<21:49,  2.96s/it]
INFO:root:函数头: 
def resolve_env_secrets(config, environ):

INFO:root:目标函数体: 
    
    if isinstance(config, dict):
        if list(config.keys()) == ["$env"]:
            return environ.get(list(config.values())[0])
        elif list(config.keys()) == ["$file"]:
            return open(list(config.values())[0]).read()
        else:
            return {
                key: resolve_env_secrets(value, environ)
                for key, value in config.items()
            }
    elif isinstance(config, list):
        return [resolve_env_secrets(value, environ) for value in config]
    else:
        return config

INFO:root:生成结果: 
    if isinstance(config, dict):
        return {k: resolve_env_secrets(v, environ) for k, v in config.items()}
    elif isinstance(config, list):
        return [resolve_env_secrets(item, environ) for item in config]
    elif isinstance(config, str):
        return config.format(**envir<|fim_suffix|><|fim_middle|>on)
    else:
        return config


INFO:root:----------------------------------------
INFO:root:max length: 9272
INFO:root:max position: 11343
INFO:root:target_namespace: datasette.datasette<folder>.utils<folder>.__init__<file>.resolve_env_secrets<func>
INFO:root:****************************************

data 77:   0%|          | 0/512 [00:00<?, ?it/s]
data 77:   2%|▏         | 10/512 [00:29<24:22,  2.91s/it]
data 77:   4%|▍         | 20/512 [01:02<25:51,  3.15s/it]
data 77:   6%|▌         | 30/512 [01:35<26:01,  3.24s/it]
data 77:   8%|▊         | 40/512 [01:58<22:30,  2.86s/it]
data 77:  10%|▉         | 50/512 [02:31<23:10,  3.01s/it]
data 77:  12%|█▏        | 60/512 [02:53<20:44,  2.75s/it]
data 77:  14%|█▎        | 70/512 [03:16<19:04,  2.59s/it]
data 77:  14%|█▎        | 70/512 [03:25<21:37,  2.94s/it]
INFO:root:函数头: 
def resolve_env_secrets(config, environ):

INFO:root:目标函数体: 
    
    if isinstance(config, dict):
        if list(config.keys()) == ["$env"]:
            return environ.get(list(config.values())[0])
        elif list(config.keys()) == ["$file"]:
            return open(list(config.values())[0]).read()
        else:
            return {
                key: resolve_env_secrets(value, environ)
                for key, value in config.items()
            }
    elif isinstance(config, list):
        return [resolve_env_secrets(value, environ) for value in config]
    else:
        return config

INFO:root:生成结果: 
    if isinstance(config, dict):
        return {k: resolve_env_secrets(v, environ) for k, v in config.items()}
    elif isinstance(config, list):
        return [resolve_env_secrets(v, environ) for v in config]
    elif isinstance(config, str):
        return config.format(** environ)
    else:
        return config




INFO:root:----------------------------------------
INFO:root:max length: 9081
INFO:root:max position: 11818
INFO:root:target_namespace: datasette.datasette<folder>.utils<folder>.__init__<file>.resolve_env_secrets<func>
INFO:root:****************************************
INFO:root:--------data 78--------

data 78:   0%|          | 0/512 [00:00<?, ?it/s]
data 78:   2%|▏         | 10/512 [00:33<27:42,  3.31s/it]
data 78:   4%|▍         | 20/512 [01:05<27:01,  3.30s/it]
data 78:   6%|▌         | 30/512 [01:40<27:05,  3.37s/it]
data 78:   8%|▊         | 40/512 [02:23<29:19,  3.73s/it]
data 78:  10%|▉         | 50/512 [03:02<29:10,  3.79s/it]
data 78:  12%|█▏        | 60/512 [03:30<25:59,  3.45s/it]
data 78:  14%|█▎        | 70/512 [04:07<26:04,  3.54s/it]
data 78:  14%|█▎        | 70/512 [04:35<28:58,  3.93s/it]
INFO:root:函数头: 
def display_actor(actor):

INFO:root:目标函数体: 
    for key in ("display", "name", "username", "login", "id"):
        if actor.get(key):
            return actor[key]
    return str(actor)

INFO:root:生成结果: 
    if actor.get("display_name"):
        return actor["display_name"]
    elif actor.get("name"):
        return actor["name"]
    elif actor.get("username"):
        return actor["username"]
    elif actor.get("login"):
        return actor["login"]
    elif actor.get("id"):
        return str(actor["id"])
    else:
        return str(actor)




INFO:root:----------------------------------------
INFO:root:max length: 10013
INFO:root:max position: 12352
INFO:root:target_namespace: datasette.datasette<folder>.utils<folder>.__init__<file>.display_actor<func>
INFO:root:****************************************

data 78:   0%|          | 0/512 [00:00<?, ?it/s]
data 78:   2%|▏         | 10/512 [00:29<24:28,  2.93s/it]
data 78:   4%|▍         | 20/512 [01:04<26:41,  3.25s/it]
data 78:   6%|▌         | 30/512 [01:35<25:41,  3.20s/it]
data 78:   8%|▊         | 40/512 [02:19<29:03,  3.69s/it]
data 78:  10%|▉         | 50/512 [03:02<29:54,  3.88s/it]
data 78:  12%|█▏        | 60/512 [06:30<1:12:44,  9.66s/it]
data 78:  14%|█▎        | 70/512 [07:06<56:25,  7.66s/it]  
data 78:  14%|█▎        | 70/512 [07:35<47:54,  6.50s/it]
INFO:root:函数头: 
def display_actor(actor):

INFO:root:目标函数体: 
    for key in ("display", "name", "username", "login", "id"):
        if actor.get(key):
            return actor[key]
    return str(actor)

INFO:root:生成结果: 
    if actor.get("display_name"):
        return actor["display_name"]
    elif actor.get("name"):
        return actor["name"]
    elif actor.get("username"):
        return actor["username"]
    elif actor.get("login"):
        return actor["login"]
    elif actor.get("id"):
        return str(actor["id"])
    else:
        return str(actor)



INFO:root:----------------------------------------
INFO:root:max length: 11211
INFO:root:max position: 12473
INFO:root:target_namespace: datasette.datasette<folder>.utils<folder>.__init__<file>.display_actor<func>
INFO:root:****************************************

data 78:   0%|          | 0/512 [00:00<?, ?it/s]
data 78:   2%|▏         | 10/512 [00:26<22:34,  2.70s/it]
data 78:   4%|▍         | 20/512 [00:59<24:58,  3.05s/it]
data 78:   6%|▌         | 30/512 [01:34<25:56,  3.23s/it]
data 78:   8%|▊         | 40/512 [02:18<29:01,  3.69s/it]
data 78:  10%|▉         | 50/512 [02:58<29:24,  3.82s/it]
data 78:  12%|█▏        | 60/512 [03:26<26:07,  3.47s/it]
data 78:  14%|█▎        | 70/512 [04:04<26:23,  3.58s/it]
data 78:  14%|█▎        | 70/512 [04:36<29:04,  3.95s/it]
INFO:root:函数头: 
def display_actor(actor):

INFO:root:目标函数体: 
    for key in ("display", "name", "username", "login", "id"):
        if actor.get(key):
            return actor[key]
    return str(actor)

INFO:root:生成结果: 
    if actor.get("display_name"):
        return actor["display_name"]
    elif actor.get("name"):
        return actor["name"]
    elif actor.get("username"):
        return actor["username"]
    elif actor.get("login"):
        return actor["login"]
    elif actor.get("id"):
        return str(actor["id"])
    else:
        return str(actor)



INFO:root:----------------------------------------
INFO:root:max length: 10274
INFO:root:max position: 12054
INFO:root:target_namespace: datasette.datasette<folder>.utils<folder>.__init__<file>.display_actor<func>
INFO:root:****************************************

data 78:   0%|          | 0/512 [00:00<?, ?it/s]
data 78:   2%|▏         | 10/512 [00:27<23:05,  2.76s/it]
data 78:   4%|▍         | 20/512 [01:04<27:19,  3.33s/it]
data 78:   6%|▌         | 30/512 [01:40<27:28,  3.42s/it]
data 78:   8%|▊         | 40/512 [02:20<28:55,  3.68s/it]
data 78:  10%|▉         | 50/512 [03:02<29:42,  3.86s/it]
data 78:  12%|█▏        | 60/512 [03:30<26:22,  3.50s/it]
data 78:  14%|█▎        | 70/512 [04:11<27:05,  3.68s/it]
data 78:  14%|█▎        | 70/512 [04:41<29:38,  4.02s/it]
INFO:root:函数头: 
def display_actor(actor):

INFO:root:目标函数体: 
    for key in ("display", "name", "username", "login", "id"):
        if actor.get(key):
            return actor[key]
    return str(actor)

INFO:root:生成结果: 
    if actor.get("display_name"):
        return actor["display_name"]
    elif actor.get("name"):
        return actor["name"]
    elif actor.get("username"):
        return actor["username"]
    elif actor.get("login"):
        return actor["login"]
    elif actor.get("id"):
        return str(actor["id"])
    else:
        return str(actor)




INFO:root:----------------------------------------
INFO:root:max length: 9746
INFO:root:max position: 12227
INFO:root:target_namespace: datasette.datasette<folder>.utils<folder>.__init__<file>.display_actor<func>
INFO:root:****************************************

data 78:   0%|          | 0/512 [00:00<?, ?it/s]
data 78:   2%|▏         | 10/512 [00:27<23:04,  2.76s/it]
data 78:   4%|▍         | 20/512 [01:02<26:07,  3.19s/it]
data 78:   6%|▌         | 30/512 [01:37<26:37,  3.31s/it]
data 78:   8%|▊         | 40/512 [02:18<28:34,  3.63s/it]
data 78:  10%|▉         | 50/512 [03:02<30:01,  3.90s/it]
data 78:  12%|█▏        | 60/512 [03:29<26:33,  3.52s/it]
data 78:  14%|█▎        | 70/512 [04:05<26:02,  3.53s/it]
data 78:  14%|█▎        | 70/512 [04:36<29:07,  3.95s/it]
INFO:root:函数头: 
def display_actor(actor):

INFO:root:目标函数体: 
    for key in ("display", "name", "username", "login", "id"):
        if actor.get(key):
            return actor[key]
    return str(actor)

INFO:root:生成结果: 
    if actor.get("display_name"):
        return actor["display_name"]
    elif actor.get("name"):
        return actor["name"]
    elif actor.get("username"):
        return actor["username"]
    elif actor.get("login"):
        return actor["login"]
    elif actor.get("id"):
        return str(actor["id"])
    else:
        return str(actor)




INFO:root:----------------------------------------
INFO:root:max length: 10527
INFO:root:max position: 12439
INFO:root:target_namespace: datasette.datasette<folder>.utils<folder>.__init__<file>.display_actor<func>
INFO:root:****************************************
INFO:root:--------data 79--------

data 79:   0%|          | 0/512 [00:00<?, ?it/s]
data 79:   2%|▏         | 10/512 [00:39<32:38,  3.90s/it]
data 79:   4%|▍         | 20/512 [01:12<29:30,  3.60s/it]
data 79:   6%|▌         | 30/512 [01:51<29:56,  3.73s/it]
data 79:   8%|▊         | 40/512 [02:20<26:34,  3.38s/it]
data 79:  10%|▉         | 50/512 [02:49<24:39,  3.20s/it]
data 79:  12%|█▏        | 60/512 [03:19<23:48,  3.16s/it]
data 79:  14%|█▎        | 70/512 [03:56<24:24,  3.31s/it]
data 79:  16%|█▌        | 80/512 [04:36<25:37,  3.56s/it]
data 79:  16%|█▌        | 80/512 [05:05<27:32,  3.82s/it]
INFO:root:函数头: 
async def initial_path_for_datasette(datasette):

INFO:root:目标函数体: 
    
    databases = dict([p for p in datasette.databases.items() if p[0] != "_internal"])
    if len(databases) == 1:
        db_name = next(iter(databases.keys()))
        path = datasette.urls.database(db_name)
        # Does this DB only have one table?
        db = next(iter(databases.values()))
        tables = await db.table_names()
        if len(tables) == 1:
            path = datasette.urls.table(db_name, tables[0])
    else:
        path = datasette.urls.instance()
    return path

INFO:root:生成结果: 
    databases = datasette.database_names()
    if len(databases) == 1:
        database_name = databases[0]
        tables = datasette.table_names(database_name)
        if len(tables) == 1:
            return datasette.urls.path(f"/{database_name}/{tables[0]}")
        else:
            return datasette.urls.path(database_name)
    else:
        return datasette.urls.path("")


INFO:root:----------------------------------------
INFO:root:max length: 10568
INFO:root:max position: 12965
INFO:root:target_namespace: datasette.datasette<folder>.utils<folder>.__init__<file>.initial_path_for_datasette<func>
INFO:root:****************************************

data 79:   0%|          | 0/512 [00:00<?, ?it/s]
data 79:   2%|▏         | 10/512 [00:32<27:31,  3.29s/it]
data 79:   4%|▍         | 20/512 [01:06<27:24,  3.34s/it]
data 79:   6%|▌         | 30/512 [01:43<27:57,  3.48s/it]
data 79:   8%|▊         | 40/512 [02:11<25:15,  3.21s/it]
data 79:  10%|▉         | 50/512 [02:39<23:34,  3.06s/it]
data 79:  12%|█▏        | 60/512 [03:09<23:01,  3.06s/it]
data 79:  14%|█▎        | 70/512 [03:50<25:00,  3.39s/it]
data 79:  14%|█▎        | 70/512 [04:12<26:31,  3.60s/it]
INFO:root:函数头: 
async def initial_path_for_datasette(datasette):

INFO:root:目标函数体: 
    
    databases = dict([p for p in datasette.databases.items() if p[0] != "_internal"])
    if len(databases) == 1:
        db_name = next(iter(databases.keys()))
        path = datasette.urls.database(db_name)
        # Does this DB only have one table?
        db = next(iter(databases.values()))
        tables = await db.table_names()
        if len(tables) == 1:
            path = datasette.urls.table(db_name, tables[0])
    else:
        path = datasette.urls.instance()
    return path

INFO:root:生成结果: 
    databases = datasette.datasets.keys()
    if len(databases) == 1:
        return list(databases)[0]
    tables = datasette.datasets[list(databases)[0]].keys()
    if len(tables) == 1:
        return f"{list(databases)[0]}/{list(tables)[0]}"
    return datasette.root_path




INFO:root:----------------------------------------
INFO:root:max length: 11085
INFO:root:max position: 13872
INFO:root:target_namespace: datasette.datasette<folder>.utils<folder>.__init__<file>.initial_path_for_datasette<func>
INFO:root:****************************************

data 79:   0%|          | 0/512 [00:00<?, ?it/s]
data 79:   2%|▏         | 10/512 [00:36<30:17,  3.62s/it]
data 79:   4%|▍         | 20/512 [01:09<28:13,  3.44s/it]
data 79:   6%|▌         | 30/512 [01:46<28:41,  3.57s/it]
data 79:   8%|▊         | 40/512 [02:13<25:28,  3.24s/it]
data 79:  10%|▉         | 50/512 [02:41<23:40,  3.08s/it]
data 79:  10%|▉         | 50/512 [02:44<25:21,  3.29s/it]
INFO:root:函数头: 
async def initial_path_for_datasette(datasette):

INFO:root:目标函数体: 
    
    databases = dict([p for p in datasette.databases.items() if p[0] != "_internal"])
    if len(databases) == 1:
        db_name = next(iter(databases.keys()))
        path = datasette.urls.database(db_name)
        # Does this DB only have one table?
        db = next(iter(databases.values()))
        tables = await db.table_names()
        if len(tables) == 1:
            path = datasette.urls.table(db_name, tables[0])
    else:
        path = datasette.urls.instance()
    return path

INFO:root:生成结果: 
    databases = datasette.database_names()
    if len(databases) == 0:
        return "/"
    elif len(databases) == 0:
        return "/{}/".format(databases[0])
    else:
        return "/"


INFO:root:----------------------------------------
INFO:root:max length: 10702
INFO:root:max position: 12433
INFO:root:target_namespace: datasette.datasette<folder>.utils<folder>.__init__<file>.initial_path_for_datasette<func>
INFO:root:****************************************

data 79:   0%|          | 0/512 [00:00<?, ?it/s]
data 79:   2%|▏         | 10/512 [00:33<28:12,  3.37s/it]
data 79:   4%|▍         | 20/512 [01:05<26:39,  3.25s/it]
data 79:   6%|▌         | 30/512 [01:45<28:54,  3.60s/it]
data 79:   8%|▊         | 40/512 [02:16<26:39,  3.39s/it]
data 79:   8%|▊         | 40/512 [02:35<30:37,  3.89s/it]
INFO:root:函数头: 
async def initial_path_for_datasette(datasette):

INFO:root:目标函数体: 
    
    databases = dict([p for p in datasette.databases.items() if p[0] != "_internal"])
    if len(databases) == 1:
        db_name = next(iter(databases.keys()))
        path = datasette.urls.database(db_name)
        # Does this DB only have one table?
        db = next(iter(databases.values()))
        tables = await db.table_names()
        if len(tables) == 1:
            path = datasette.urls.table(db_name, tables[0])
    else:
        path = datasette.urls.instance()
    return path

INFO:root:生成结果: 
    databases = datasette databases
    if len(databases) == 0:
        return "/"
    elif len(databases) == 0:
        return "/datasette/"
    else:
        return "/datasette/"


INFO:root:----------------------------------------
INFO:root:max length: 11436
INFO:root:max position: 13932
INFO:root:target_namespace: datasette.datasette<folder>.utils<folder>.__init__<file>.initial_path_for_datasette<func>
INFO:root:****************************************

data 79:   0%|          | 0/512 [00:00<?, ?it/s]
data 79:   2%|▏         | 10/512 [00:36<30:15,  3.62s/it]
data 79:   4%|▍         | 20/512 [01:09<28:17,  3.45s/it]
data 79:   6%|▌         | 30/512 [01:50<30:05,  3.75s/it]
data 79:   8%|▊         | 40/512 [02:18<26:32,  3.37s/it]
data 79:  10%|▉         | 50/512 [02:46<24:27,  3.18s/it]
data 79:  12%|█▏        | 60/512 [03:15<23:09,  3.08s/it]
data 79:  14%|█▎        | 70/512 [03:44<22:15,  3.02s/it]
data 79:  14%|█▎        | 70/512 [03:47<23:56,  3.25s/it]
INFO:root:函数头: 
async def initial_path_for_datasette(datasette):

INFO:root:目标函数体: 
    
    databases = dict([p for p in datasette.databases.items() if p[0] != "_internal"])
    if len(databases) == 1:
        db_name = next(iter(databases.keys()))
        path = datasette.urls.database(db_name)
        # Does this DB only have one table?
        db = next(iter(databases.values()))
        tables = await db.table_names()
        if len(tables) == 1:
            path = datasette.urls.table(db_name, tables[0])
    else:
        path = datasette.urls.instance()
    return path

INFO:root:生成结果: 
    databases = datasette.datasets.keys()
    if len(databases) == 1:
        return databases[0]
    tables = datasette.datasets[databases[0]].keys()
    if len(tables) == <|fim_suffix|><|fim_middle|>1:
        return f"{databases[0]}/{tables[0]}"
    return datasette.path




INFO:root:----------------------------------------
INFO:root:max length: 9998
INFO:root:max position: 12603
INFO:root:target_namespace: datasette.datasette<folder>.utils<folder>.__init__<file>.initial_path_for_datasette<func>
INFO:root:****************************************
INFO:root:已生成79条结果
INFO:root:--------data 80--------

data 80:   0%|          | 0/512 [00:00<?, ?it/s]
data 80:   2%|▏         | 10/512 [00:33<27:48,  3.32s/it]
data 80:   4%|▍         | 20/512 [01:07<27:37,  3.37s/it]
data 80:   6%|▌         | 30/512 [01:43<27:57,  3.48s/it]
data 80:   8%|▊         | 40/512 [02:13<25:57,  3.30s/it]
data 80:  10%|▉         | 50/512 [02:38<23:05,  3.00s/it]
data 80:  12%|█▏        | 60/512 [03:13<23:57,  3.18s/it]
data 80:  14%|█▎        | 70/512 [03:38<21:48,  2.96s/it]
data 80:  16%|█▌        | 80/512 [04:00<19:35,  2.72s/it]
data 80:  16%|█▌        | 80/512 [04:05<22:04,  3.07s/it]
INFO:root:函数头: 
@documented
def tilde_decode(s: str) -> str:

INFO:root:目标函数体: 
    "Decodes a tilde-encoded string, so ``~2Ffoo~2Fbar`` -> ``/foo/bar``"
    # Avoid accidentally decoding a %2f style sequence
    temp = secrets.token_hex(16)
    s = s.replace("%", temp)
    decoded = urllib.parse.unquote_plus(s.replace("~", "%"))
    return decoded.replace(temp, "%")

INFO:root:生成结果: 
    # Replace % with a temporary string to avoid accidental decoding of %2f style sequences
    temp = "__datasette_temp"
    s = s.replace("%", temp)
    
    # Decode the tilde-encoded string
    s = s.decode("unicode_escape")
    
    # Replace the temporary string with % again
    s = s.replace(temp, "%")
    
    return s


INFO:root:----------------------------------------
INFO:root:max length: 10348
INFO:root:max position: 11662
INFO:root:target_namespace: datasette.datasette<folder>.utils<folder>.__init__<file>.tilde_decode<func>
INFO:root:****************************************

data 80:   0%|          | 0/512 [00:00<?, ?it/s]
data 80:   2%|▏         | 10/512 [00:32<27:19,  3.27s/it]
data 80:   4%|▍         | 20/512 [01:02<25:35,  3.12s/it]
data 80:   6%|▌         | 30/512 [01:39<26:53,  3.35s/it]
data 80:   6%|▌         | 30/512 [02:08<34:30,  4.30s/it]
INFO:root:函数头: 
@documented
def tilde_decode(s: str) -> str:

INFO:root:目标函数体: 
    "Decodes a tilde-encoded string, so ``~2Ffoo~2Fbar`` -> ``/foo/bar``"
    # Avoid accidentally decoding a %2f style sequence
    temp = secrets.token_hex(16)
    s = s.replace("%", temp)
    decoded = urllib.parse.unquote_plus(s.replace("~", "%"))
    return decoded.replace(temp, "%")

INFO:root:生成结果: 
    s = s.replace("%", "%datasette_temp")
    s = urllib.parse.unquote(s)
    s = s.replace("%datasette_temp", "%")
    return s


INFO:root:----------------------------------------
INFO:root:max length: 9717
INFO:root:max position: 11838
INFO:root:target_namespace: datasette.datasette<folder>.utils<folder>.__init__<file>.tilde_decode<func>
INFO:root:****************************************

data 80:   0%|          | 0/512 [00:00<?, ?it/s]
data 80:   2%|▏         | 10/512 [00:31<26:44,  3.20s/it]
data 80:   4%|▍         | 20/512 [01:00<24:43,  3.02s/it]
data 80:   6%|▌         | 30/512 [01:41<28:14,  3.51s/it]
data 80:   8%|▊         | 40/512 [04:12<1:03:31,  8.08s/it]
data 80:   8%|▊         | 40/512 [08:26<1:39:31, 12.65s/it]
INFO:root:函数头: 
@documented
def tilde_decode(s: str) -> str:

INFO:root:目标函数体: 
    "Decodes a tilde-encoded string, so ``~2Ffoo~2Fbar`` -> ``/foo/bar``"
    # Avoid accidentally decoding a %2f style sequence
    temp = secrets.token_hex(16)
    s = s.replace("%", temp)
    decoded = urllib.parse.unquote_plus(s.replace("~", "%"))
    return decoded.replace(temp, "%")

INFO:root:生成结果: 
    s = s.replace("%", "__datasette_tilde_decode_temp")
    s = s.decode("unicode_escape")
    s = s.replace("__datasette_tilde_decode_temp", "%")
    return s


INFO:root:----------------------------------------
INFO:root:max length: 10393
INFO:root:max position: 12264
INFO:root:target_namespace: datasette.datasette<folder>.utils<folder>.__init__<file>.tilde_decode<func>
INFO:root:****************************************

data 80:   0%|          | 0/512 [00:00<?, ?it/s]
data 80:   2%|▏         | 10/512 [00:31<26:37,  3.18s/it]
data 80:   4%|▍         | 20/512 [01:02<25:38,  3.13s/it]
data 80:   6%|▌         | 30/512 [01:40<27:28,  3.42s/it]
data 80:   8%|▊         | 40/512 [02:11<25:51,  3.29s/it]
data 80:   8%|▊         | 40/512 [02:18<27:11,  3.46s/it]
INFO:root:函数头: 
@documented
def tilde_decode(s: str) -> str:

INFO:root:目标函数体: 
    "Decodes a tilde-encoded string, so ``~2Ffoo~2Fbar`` -> ``/foo/bar``"
    # Avoid accidentally decoding a %2f style sequence
    temp = secrets.token_hex(16)
    s = s.replace("%", temp)
    decoded = urllib.parse.unquote_plus(s.replace("~", "%"))
    return decoded.replace(temp, "%")

INFO:root:生成结果: 
    temp = "__datasette_temp"
    s = s.replace("%", temp)
    s = s.replace("%", "%2f")
    s = s.replace(temp, "%")
    return s




INFO:root:----------------------------------------
INFO:root:max length: 10084
INFO:root:max position: 11757
INFO:root:target_namespace: datasette.datasette<folder>.utils<folder>.__init__<file>.tilde_decode<func>
INFO:root:****************************************

data 80:   0%|          | 0/512 [00:00<?, ?it/s]
data 80:   2%|▏         | 10/512 [00:30<25:51,  3.09s/it]
data 80:   2%|▏         | 10/512 [00:40<33:46,  4.04s/it]
INFO:root:函数头: 
@documented
def tilde_decode(s: str) -> str:

INFO:root:目标函数体: 
    "Decodes a tilde-encoded string, so ``~2Ffoo~2Fbar`` -> ``/foo/bar``"
    # Avoid accidentally decoding a %2f style sequence
    temp = secrets.token_hex(16)
    s = s.replace("%", temp)
    decoded = urllib.parse.unquote_plus(s.replace("~", "%"))
    return decoded.replace(temp, "%")

INFO:root:生成结果: 
    # Your implementation goes here
    pass


INFO:root:----------------------------------------
INFO:root:max length: 6624
INFO:root:max position: 10587
INFO:root:target_namespace: datasette.datasette<folder>.utils<folder>.__init__<file>.tilde_decode<func>
INFO:root:****************************************
INFO:root:--------data 81--------

data 81:   0%|          | 0/512 [00:00<?, ?it/s]
data 81:   2%|▏         | 10/512 [01:29<1:15:08,  8.98s/it]
data 81:   4%|▍         | 20/512 [02:05<47:36,  5.81s/it]  
data 81:   6%|▌         | 30/512 [02:39<37:44,  4.70s/it]
data 81:   6%|▌         | 30/512 [02:51<46:00,  5.73s/it]
INFO:root:函数头: 
def resolve_routes(routes, path):

INFO:root:目标函数体: 
    for regex, view in routes:
        match = regex.match(path)
        if match is not None:
            return match, view
    return None, None

INFO:root:生成结果: 
    for regex, view in routes:
        match = regex.match(path)
        if match:
            return match.groupdict(), view
    return None


INFO:root:----------------------------------------
INFO:root:max length: 8920
INFO:root:max position: 12165
INFO:root:target_namespace: datasette.datasette<folder>.utils<folder>.__init__<file>.resolve_routes<func>
INFO:root:****************************************

data 81:   0%|          | 0/512 [00:00<?, ?it/s]
data 81:   2%|▏         | 10/512 [00:26<22:02,  2.63s/it]
data 81:   4%|▍         | 20/512 [00:54<22:23,  2.73s/it]
data 81:   6%|▌         | 30/512 [01:24<22:50,  2.84s/it]
data 81:   6%|▌         | 30/512 [01:41<27:04,  3.37s/it]
INFO:root:函数头: 
def resolve_routes(routes, path):

INFO:root:目标函数体: 
    for regex, view in routes:
        match = regex.match(path)
        if match is not None:
            return match, view
    return None, None

INFO:root:生成结果: 
    for regex, view in routes:
        match = re.match(regex, path)
        if match:
            return match.groupdict(), view
    return None


INFO:root:----------------------------------------
INFO:root:max length: 9040
INFO:root:max position: 11322
INFO:root:target_namespace: datasette.datasette<folder>.utils<folder>.__init__<file>.resolve_routes<func>
INFO:root:****************************************

data 81:   0%|          | 0/512 [00:00<?, ?it/s]
data 81:   2%|▏         | 10/512 [00:23<20:00,  2.39s/it]
data 81:   4%|▍         | 20/512 [00:57<24:24,  2.98s/it]
data 81:   6%|▌         | 30/512 [01:29<24:28,  3.05s/it]
data 81:   6%|▌         | 30/512 [01:42<27:20,  3.40s/it]
INFO:root:函数头: 
def resolve_routes(routes, path):

INFO:root:目标函数体: 
    for regex, view in routes:
        match = regex.match(path)
        if match is not None:
            return match, view
    return None, None

INFO:root:生成结果: 
    for regex, view in routes:
        match = re.match(regex, path)
        if match:
            return match, view
    return None


INFO:root:----------------------------------------
INFO:root:max length: 11264
INFO:root:max position: 13653
INFO:root:target_namespace: datasette.datasette<folder>.utils<folder>.__init__<file>.resolve_routes<func>
INFO:root:****************************************

data 81:   0%|          | 0/512 [00:00<?, ?it/s]
data 81:   2%|▏         | 10/512 [00:25<21:36,  2.58s/it]
data 81:   4%|▍         | 20/512 [00:56<23:37,  2.88s/it]
data 81:   6%|▌         | 30/512 [01:26<23:29,  2.92s/it]
data 81:   6%|▌         | 30/512 [01:42<27:27,  3.42s/it]
INFO:root:函数头: 
def resolve_routes(routes, path):

INFO:root:目标函数体: 
    for regex, view in routes:
        match = regex.match(path)
        if match is not None:
            return match, view
    return None, None

INFO:root:生成结果: 
    for regex, view in routes:
        match = re.match(regex, path)
        if match:
            return match.groupdict(), view
    return None


INFO:root:----------------------------------------
INFO:root:max length: 9401
INFO:root:max position: 10949
INFO:root:target_namespace: datasette.datasette<folder>.utils<folder>.__init__<file>.resolve_routes<func>
INFO:root:****************************************

data 81:   0%|          | 0/512 [00:00<?, ?it/s]
data 81:   2%|▏         | 10/512 [04:25<3:42:31, 26.60s/it]
data 81:   4%|▍         | 20/512 [05:03<1:47:42, 13.14s/it]
data 81:   6%|▌         | 30/512 [05:39<1:10:41,  8.80s/it]
data 81:   6%|▌         | 30/512 [05:52<1:34:17, 11.74s/it]
INFO:root:函数头: 
def resolve_routes(routes, path):

INFO:root:目标函数体: 
    for regex, view in routes:
        match = regex.match(path)
        if match is not None:
            return match, view
    return None, None

INFO:root:生成结果: 
    for regex, view in routes:
        match = regex.match(path)
        if match:
            return match.groupdict(), view
    return None


INFO:root:----------------------------------------
INFO:root:max length: 8358
INFO:root:max position: 11138
INFO:root:target_namespace: datasette.datasette<folder>.utils<folder>.__init__<file>.resolve_routes<func>
INFO:root:****************************************
INFO:root:--------data 82--------

data 82:   0%|          | 0/512 [00:00<?, ?it/s]
data 82:   2%|▏         | 10/512 [00:23<19:34,  2.34s/it]
data 82:   4%|▍         | 20/512 [00:49<20:43,  2.53s/it]
data 82:   6%|▌         | 30/512 [01:14<19:56,  2.48s/it]
data 82:   8%|▊         | 40/512 [01:42<20:26,  2.60s/it]
data 82:  10%|▉         | 50/512 [02:23<24:16,  3.15s/it]
data 82:  12%|█▏        | 60/512 [02:57<24:31,  3.26s/it]
data 82:  14%|█▎        | 70/512 [03:26<23:04,  3.13s/it]
data 82:  16%|█▌        | 80/512 [04:05<24:21,  3.38s/it]
data 82:  18%|█▊        | 90/512 [04:42<24:26,  3.48s/it]
data 82:  20%|█▉        | 100/512 [05:21<24:44,  3.60s/it]
data 82:  21%|██▏       | 110/512 [05:49<22:27,  3.35s/it]
data 82:  23%|██▎       | 120/512 [06:22<21:51,  3.35s/it]
data 82:  25%|██▌       | 130/512 [06:59<22:01,  3.46s/it]
data 82:  27%|██▋       | 140/512 [07:39<22:24,  3.61s/it]
data 82:  29%|██▉       | 150/512 [08:19<22:27,  3.72s/it]
data 82:  31%|███▏      | 160/512 [08:59<22:25,  3.82s/it]
data 82:  33%|███▎      | 170/512 [09:52<24:10,  4.24s/it]
data 82:  33%|███▎      | 170/512 [10:40<21:29,  3.77s/it]
INFO:root:函数头: 
def truncate_url(url, length):

INFO:root:目标函数体: 
    if (not length) or (len(url) <= length):
        return url
    bits = url.rsplit(".", 1)
    if len(bits) == 2 and 1 <= len(bits[1]) <= 4 and "/" not in bits[1]:
        rest, ext = bits
        return rest[: length - 1 - len(ext)] + "…." + ext
    return url[: length - 1] + "…"

INFO:root:生成结果: 
    if len(url) <= length:
        return url

    # Check if the URL ends with a file extension and the extension length is between 1 and 4 characters without a slash
    if url.endswith(".") and len(url.split(".")[-1]) >= 1 and len(url.split(".")[-1]) <= 4:
        # Calculate the maximum length of the URL without the file extension
        max_length_without_extension = length - len(url.split(".")[-1]) - 3
        # Truncate the URL to the maximum length without the file extension
        truncated_url = url[:max_length_without_extension]
        # Add ellipsis and the file extension at the end
        return f"{truncated_url}..."
    else:
        # Truncate the URL to the specified length and add ellipsis at the end
        return f"{url[:length]}..."


INFO:root:----------------------------------------
INFO:root:max length: 12049
INFO:root:max position: 14575
INFO:root:target_namespace: datasette.datasette<folder>.utils<folder>.__init__<file>.truncate_url<func>
INFO:root:****************************************

data 82:   0%|          | 0/512 [00:00<?, ?it/s]
data 82:   2%|▏         | 10/512 [00:20<16:58,  2.03s/it]
data 82:   4%|▍         | 20/512 [00:43<17:49,  2.17s/it]
data 82:   6%|▌         | 30/512 [01:04<17:11,  2.14s/it]
data 82:   8%|▊         | 40/512 [01:31<18:36,  2.36s/it]
data 82:  10%|▉         | 50/512 [02:23<26:13,  3.40s/it]
data 82:  12%|█▏        | 60/512 [03:05<27:44,  3.68s/it]
data 82:  14%|█▎        | 70/512 [03:40<26:36,  3.61s/it]
data 82:  16%|█▌        | 80/512 [04:32<29:45,  4.13s/it]
data 82:  18%|█▊        | 90/512 [05:20<30:30,  4.34s/it]
data 82:  20%|█▉        | 100/512 [06:06<30:20,  4.42s/it]
data 82:  20%|█▉        | 100/512 [06:11<25:28,  3.71s/it]
INFO:root:函数头: 
def truncate_url(url, length):

INFO:root:目标函数体: 
    if (not length) or (len(url) <= length):
        return url
    bits = url.rsplit(".", 1)
    if len(bits) == 2 and 1 <= len(bits[1]) <= 4 and "/" not in bits[1]:
        rest, ext = bits
        return rest[: length - 1 - len(ext)] + "…." + ext
    return url[: length - 1] + "…"

INFO:root:生成结果: 
    if len(url) <= length:
        return url
    url_parts = url.split("/")
    if len(url_parts[-1]) > 4:
        return url_parts[:-1] + [url_parts[-1][:length - 4] + "..."] + url_parts[-1][length - 4:]
    else:
        return url_parts[:-1] + [url_parts[-1][:length - 3] + "..."] + url_parts[-1][length - 3:]


INFO:root:----------------------------------------
INFO:root:max length: 12284
INFO:root:max position: 14320
INFO:root:target_namespace: datasette.datasette<folder>.utils<folder>.__init__<file>.truncate_url<func>
INFO:root:****************************************

data 82:   0%|          | 0/512 [00:00<?, ?it/s]
data 82:   2%|▏         | 10/512 [00:20<17:01,  2.04s/it]
data 82:   4%|▍         | 20/512 [00:45<18:57,  2.31s/it]
data 82:   6%|▌         | 30/512 [01:07<18:19,  2.28s/it]
data 82:   8%|▊         | 40/512 [01:40<21:05,  2.68s/it]
data 82:  10%|▉         | 50/512 [02:30<27:04,  3.52s/it]
data 82:  12%|█▏        | 60/512 [03:11<27:54,  3.70s/it]
data 82:  14%|█▎        | 70/512 [03:40<25:15,  3.43s/it]
data 82:  16%|█▌        | 80/512 [04:21<26:17,  3.65s/it]
data 82:  18%|█▊        | 90/512 [04:58<25:50,  3.67s/it]
data 82:  20%|█▉        | 100/512 [05:33<24:51,  3.62s/it]
data 82:  21%|██▏       | 110/512 [06:06<23:40,  3.53s/it]
data 82:  23%|██▎       | 120/512 [06:45<23:44,  3.63s/it]
data 82:  25%|██▌       | 130/512 [07:21<23:08,  3.63s/it]
data 82:  27%|██▋       | 140/512 [08:06<24:01,  3.87s/it]
data 82:  29%|██▉       | 150/512 [08:48<23:56,  3.97s/it]
data 82:  31%|███▏      | 160/512 [09:33<24:13,  4.13s/it]
data 82:  33%|███▎      | 170/512 [10:25<25:23,  4.46s/it]
data 82:  35%|███▌      | 180/512 [11:13<25:16,  4.57s/it]
data 82:  37%|███▋      | 190/512 [11:58<24:27,  4.56s/it]
data 82:  39%|███▉      | 200/512 [12:28<21:16,  4.09s/it]
data 82:  41%|████      | 210/512 [12:52<18:02,  3.58s/it]
data 82:  43%|████▎     | 220/512 [13:26<17:05,  3.51s/it]
data 82:  45%|████▍     | 230/512 [15:47<31:28,  6.70s/it]
data 82:  47%|████▋     | 240/512 [16:09<24:11,  5.34s/it]
data 82:  49%|████▉     | 250/512 [16:36<19:52,  4.55s/it]
data 82:  51%|█████     | 260/512 [17:13<18:05,  4.31s/it]
data 82:  53%|█████▎    | 270/512 [18:02<17:59,  4.46s/it]
data 82:  55%|█████▍    | 280/512 [18:34<15:52,  4.11s/it]
data 82:  57%|█████▋    | 290/512 [19:05<14:00,  3.79s/it]
data 82:  59%|█████▊    | 300/512 [19:34<12:30,  3.54s/it]
data 82:  61%|██████    | 310/512 [20:13<12:15,  3.64s/it]
data 82:  62%|██████▎   | 320/512 [20:51<11:45,  3.67s/it]
data 82:  64%|██████▍   | 330/512 [21:11<09:39,  3.18s/it]
data 82:  66%|██████▋   | 340/512 [21:35<08:26,  2.94s/it]
data 82:  68%|██████▊   | 350/512 [22:08<08:13,  3.05s/it]
data 82:  70%|███████   | 360/512 [22:55<08:58,  3.55s/it]
data 82:  72%|███████▏  | 370/512 [23:36<08:46,  3.71s/it]
data 82:  74%|███████▍  | 380/512 [24:11<08:03,  3.66s/it]
data 82:  76%|███████▌  | 390/512 [24:56<07:57,  3.91s/it]
data 82:  78%|███████▊  | 400/512 [25:36<07:19,  3.92s/it]
data 82:  80%|████████  | 410/512 [26:04<06:05,  3.58s/it]
data 82:  82%|████████▏ | 420/512 [26:26<04:51,  3.17s/it]
data 82:  84%|████████▍ | 430/512 [26:52<04:05,  3.00s/it]
data 82:  86%|████████▌ | 440/512 [27:19<03:29,  2.91s/it]
data 82:  88%|████████▊ | 450/512 [27:41<02:48,  2.72s/it]
data 82:  90%|████████▉ | 460/512 [28:02<02:11,  2.52s/it]
data 82:  92%|█████████▏| 470/512 [28:30<01:49,  2.60s/it]
data 82:  94%|█████████▍| 480/512 [29:15<01:41,  3.16s/it]
data 82:  96%|█████████▌| 490/512 [31:04<02:00,  5.49s/it]
data 82:  98%|█████████▊| 500/512 [34:28<01:59,  9.96s/it]
data 82: 100%|█████████▉| 510/512 [35:03<00:16,  8.03s/it]
data 82: 100%|█████████▉| 510/512 [35:19<00:08,  4.16s/it]
INFO:root:函数头: 
def truncate_url(url, length):

INFO:root:目标函数体: 
    if (not length) or (len(url) <= length):
        return url
    bits = url.rsplit(".", 1)
    if len(bits) == 2 and 1 <= len(bits[1]) <= 4 and "/" not in bits[1]:
        rest, ext = bits
        return rest[: length - 1 - len(ext)] + "…." + ext
    return url[: length - 1] + "…"

INFO:root:生成结果: 
    if len(url) <= length:
        return url

    # Find the last slash in the URL
    last_slash_index = url.rfind("/")
    if last_slash_index == -1:
        # If there is no slash, just truncate the URL to the specified length
        return url[:length] + "..."

    # Find the last period in the URL
    last_period_index = url.rfind(".")
    if last_period_index == -1:
        # If there is no period, just truncate the URL to the specified length
        return url[:length] + "..."

    # If the URL ends with a file extension and the extension length is between 1 and 4 characters without a slash, truncate the URL to the specified length and add ellipsis and the extension at the end
    if (
        last_period_index > last_slash_index + 1
        and last_period_index - last_slash_index <= 4
        and url[last_period_index + 1] != "/"
    ):
        return url[:last_slash_index + length - len("...") - len(url[last_period_index + 1:])] + "..." + url[last_period_index:]

    # If the URL ends with a file extension and the extension length is between 1 and 4 characters with a slash, truncate the URL to the specified length and add ellipsis and the extension at the end
    if (
        last_period_index > last_slash_index + 1
        and last_period_index - last_slash_index <= 4
        and url[last_period_index + 1] == "/"
    ):
        return (
            url[:last_slash_index + length - len("...") - len(url[last_period_index + 1:]) + 1]
            + "..."
            + url[last_period_index:]
        )

    # If the URL ends with a file extension and the extension length is greater than 4 characters without a slash, truncate the URL to the specified length and add ellipsis and the extension at the end
    if (
        last_period_index > last_slash_index + 1
        and last_period_index - last_slash_index > 4
        and url[last_period_index + 1] != "/"
    ):
        return (
            url[:last_slash_index + length - len("...") - len(url[last_period_index + 1:]) - len(url[last_period_index + 1:]) + 1]
            + "..."
            + url

INFO:root:----------------------------------------
INFO:root:max length: 11504
INFO:root:max position: 13787
INFO:root:target_namespace: datasette.datasette<folder>.utils<folder>.__init__<file>.truncate_url<func>
INFO:root:****************************************

data 82:   0%|          | 0/512 [00:00<?, ?it/s]
data 82:   2%|▏         | 10/512 [00:20<16:54,  2.02s/it]
data 82:   4%|▍         | 20/512 [00:43<17:51,  2.18s/it]
data 82:   6%|▌         | 30/512 [01:05<17:39,  2.20s/it]
data 82:   8%|▊         | 40/512 [01:31<18:36,  2.37s/it]
data 82:  10%|▉         | 50/512 [02:16<24:14,  3.15s/it]
data 82:  12%|█▏        | 60/512 [02:48<23:43,  3.15s/it]
data 82:  14%|█▎        | 70/512 [03:15<22:12,  3.01s/it]
data 82:  16%|█▌        | 80/512 [04:00<25:08,  3.49s/it]
data 82:  18%|█▊        | 90/512 [04:40<25:38,  3.64s/it]
data 82:  20%|█▉        | 100/512 [06:20<38:26,  5.60s/it]
data 82:  21%|██▏       | 110/512 [06:45<31:10,  4.65s/it]
data 82:  21%|██▏       | 110/512 [07:14<26:28,  3.95s/it]
INFO:root:函数头: 
def truncate_url(url, length):

INFO:root:目标函数体: 
    if (not length) or (len(url) <= length):
        return url
    bits = url.rsplit(".", 1)
    if len(bits) == 2 and 1 <= len(bits[1]) <= 4 and "/" not in bits[1]:
        rest, ext = bits
        return rest[: length - 1 - len(ext)] + "…." + ext
    return url[: length - 1] + "…"

INFO:root:生成结果: 
    if len(url) <= length:
        return url
    if url.endswith("."):
        return url[:length - 1] + "..."
    else:
        url_parts = url.rsplit(".", 1)
        if len(url_parts) == 2 and len(url_parts[1]) >= 1 and len(url_parts[1]) <= 4:
            return url_parts[0][: length - len(url_parts[1]) - 4] + "..." + url_parts[1]
        else:
            return url[:length - 4] + "..."


INFO:root:----------------------------------------
INFO:root:max length: 11898
INFO:root:max position: 13039
INFO:root:target_namespace: datasette.datasette<folder>.utils<folder>.__init__<file>.truncate_url<func>
INFO:root:****************************************

data 82:   0%|          | 0/512 [00:00<?, ?it/s]
data 82:   2%|▏         | 10/512 [00:20<17:22,  2.08s/it]
data 82:   4%|▍         | 20/512 [00:44<18:14,  2.22s/it]
data 82:   6%|▌         | 30/512 [01:06<18:00,  2.24s/it]
data 82:   8%|▊         | 40/512 [01:45<22:39,  2.88s/it]
data 82:  10%|▉         | 50/512 [02:27<26:01,  3.38s/it]
data 82:  12%|█▏        | 60/512 [03:02<25:39,  3.41s/it]
data 82:  14%|█▎        | 70/512 [06:32<1:07:33,  9.17s/it]
data 82:  16%|█▌        | 80/512 [07:12<54:07,  7.52s/it]  
data 82:  18%|█▊        | 90/512 [09:00<1:00:02,  8.54s/it]
data 82:  20%|█▉        | 100/512 [09:42<49:23,  7.19s/it] 
data 82:  21%|██▏       | 110/512 [10:13<39:48,  5.94s/it]
data 82:  23%|██▎       | 120/512 [10:49<34:06,  5.22s/it]
data 82:  25%|██▌       | 130/512 [11:24<30:00,  4.71s/it]
data 82:  27%|██▋       | 140/512 [12:06<28:10,  4.55s/it]
data 82:  29%|██▉       | 150/512 [12:52<27:40,  4.59s/it]
data 82:  31%|███▏      | 160/512 [13:29<25:13,  4.30s/it]
data 82:  33%|███▎      | 170/512 [14:20<25:51,  4.54s/it]
data 82:  35%|███▌      | 180/512 [15:11<26:05,  4.72s/it]
data 82:  37%|███▋      | 190/512 [15:47<23:35,  4.39s/it]
data 82:  39%|███▉      | 200/512 [16:18<20:49,  4.00s/it]
data 82:  41%|████      | 210/512 [16:39<17:13,  3.42s/it]
data 82:  43%|████▎     | 220/512 [17:06<15:32,  3.19s/it]
data 82:  45%|████▍     | 230/512 [17:27<13:30,  2.88s/it]
data 82:  47%|████▋     | 240/512 [17:49<12:05,  2.67s/it]
data 82:  49%|████▉     | 250/512 [18:16<11:39,  2.67s/it]
data 82:  51%|█████     | 260/512 [18:54<12:40,  3.02s/it]
data 82:  53%|█████▎    | 270/512 [19:40<14:03,  3.48s/it]
data 82:  55%|█████▍    | 280/512 [20:07<12:36,  3.26s/it]
data 82:  57%|█████▋    | 290/512 [21:39<18:36,  5.03s/it]
data 82:  59%|█████▊    | 300/512 [23:14<22:33,  6.39s/it]
data 82:  61%|██████    | 310/512 [23:56<19:18,  5.74s/it]
data 82:  62%|██████▎   | 320/512 [25:28<21:41,  6.78s/it]
data 82:  64%|██████▍   | 330/512 [25:53<16:36,  5.48s/it]
data 82:  66%|██████▋   | 340/512 [26:23<13:33,  4.73s/it]
data 82:  68%|██████▊   | 350/512 [26:53<11:22,  4.22s/it]
data 82:  70%|███████   | 360/512 [27:32<10:25,  4.11s/it]
data 82:  72%|███████▏  | 370/512 [28:07<09:20,  3.95s/it]
data 82:  74%|███████▍  | 380/512 [28:45<08:34,  3.90s/it]
data 82:  76%|███████▌  | 390/512 [29:36<08:39,  4.25s/it]
data 82:  78%|███████▊  | 400/512 [30:21<08:05,  4.33s/it]
data 82:  80%|████████  | 410/512 [30:50<06:39,  3.92s/it]
data 82:  82%|████████▏ | 420/512 [31:14<05:17,  3.45s/it]
data 82:  84%|████████▍ | 430/512 [31:33<04:05,  2.99s/it]
data 82:  86%|████████▌ | 440/512 [32:02<03:33,  2.96s/it]
data 82:  88%|████████▊ | 450/512 [32:27<02:54,  2.82s/it]
data 82:  90%|████████▉ | 460/512 [32:58<02:30,  2.89s/it]
data 82:  92%|█████████▏| 470/512 [33:27<02:02,  2.91s/it]
data 82:  94%|█████████▍| 480/512 [34:15<01:51,  3.49s/it]
data 82:  96%|█████████▌| 490/512 [35:01<01:23,  3.81s/it]
data 82:  98%|█████████▊| 500/512 [35:33<00:43,  3.63s/it]
data 82: 100%|█████████▉| 510/512 [36:18<00:07,  3.87s/it]
data 82: 100%|█████████▉| 510/512 [36:33<00:08,  4.30s/it]
INFO:root:函数头: 
def truncate_url(url, length):

INFO:root:目标函数体: 
    if (not length) or (len(url) <= length):
        return url
    bits = url.rsplit(".", 1)
    if len(bits) == 2 and 1 <= len(bits[1]) <= 4 and "/" not in bits[1]:
        rest, ext = bits
        return rest[: length - 1 - len(ext)] + "…." + ext
    return url[: length - 1] + "…"

INFO:root:生成结果: 
    if len(url) <= length:
        return url
    if url.endswith("."):
        url = url[:-1]
    if url.endswith("/"):
        url = url[:-1]
    if url.endswith(".json"):
        url = url[:-5]
    if url.endswith(".csv"):
        url = url[:-4]
    if url.endswith(".txt"):
        url = url[:-3]
    if url.endswith(".html"):
        url = url[:-5]
    if url.endswith(".htm"):
        url = url[:-4]
    if url.endswith(".xml"):
        url = url[:-4]
    if url.endswith(".yaml"):
        url = url[:-5]
    if url.endswith(".yml"):
        url = url[:-4]
    if url.endswith(".jsonld"):
        url = url[:-6]
    if url.endswith(".jsonld"):
        url = url[:-5]
    if url.endswith(".jsonp"):
        url = url[:-5]
    if url.endswith(".jsonp"):
        url = url[:-4]
    if url.endswith(".jsonp"):
        url = url[:-3]
    if url.endswith(".jsonp"):
        url = url[:-2]
    if url.endswith(".jsonp"):
        url = url[:-1]
    if url.endswith(".jsonp"):
        url = url[:-0]
    if url.endswith(".jsonp"):
        url = url[:-1]
    if url.endswith(".jsonp"):
        url = url[:-2]
    if url.endswith(".jsonp"):
        url = url[:-3]
    if url.endswith(".jsonp"):
        url = url[:-4]
    if url.endswith(".jsonp"):
        url = url[:-5]
    if url.endswith(".jsonp"):
        url = url[:-6]
    if url.endswith(".jsonp"):
        url = url[:-7]
    if url.endswith(".jsonp"):
        url = url[:-8]
    if url.endswith(".jsonp"):
        url = url[:-9]
    if url.endswith(".jsonp"):
        url = url[:-10]
    if url.endswith(".jsonp"):
        url = url[:-11]
    if url.endswith(".jsonp"):
        url = url[:-12]
    if url.endswith(".jsonp"):
        url = url[:-13]
    if url.endswith(".jsonp"):
        url = url[:-14]
    if url.endswith(".jsonp"):
        url = url[:-15]
    if url.endswith(".jsonp"):
       

INFO:root:----------------------------------------
INFO:root:max length: 11920
INFO:root:max position: 14354
INFO:root:target_namespace: datasette.datasette<folder>.utils<folder>.__init__<file>.truncate_url<func>
INFO:root:****************************************
INFO:root:--------data 83--------

data 83:   0%|          | 0/512 [00:00<?, ?it/s]
data 83:   2%|▏         | 10/512 [04:34<3:49:29, 27.43s/it]
data 83:   4%|▍         | 20/512 [05:16<1:53:03, 13.79s/it]
data 83:   6%|▌         | 30/512 [06:00<1:16:26,  9.51s/it]
data 83:   8%|▊         | 40/512 [06:43<58:27,  7.43s/it]  
data 83:  10%|▉         | 50/512 [07:28<49:08,  6.38s/it]
data 83:  12%|█▏        | 60/512 [07:50<37:22,  4.96s/it]
data 83:  14%|█▎        | 70/512 [08:14<30:22,  4.12s/it]
data 83:  16%|█▌        | 80/512 [08:44<27:02,  3.76s/it]
data 83:  16%|█▌        | 80/512 [08:51<47:52,  6.65s/it]
INFO:root:函数头: 
def groupfinder(userid, request):

INFO:root:目标函数体: 
    
    backend = getattr(request.registry, "permission", None)
    # Permission backend not configured. Ignore.
    if not backend:
        return []

    # Safety check when Kinto-Core is used without pyramid_multiauth.
    if request.prefixed_userid:
        userid = request.prefixed_userid

    # Query the permission backend only once per request (e.g. batch).
    reify_key = userid + "_principals"
    if reify_key not in request.bound_data:
        principals = backend.get_user_principals(userid)
        request.bound_data[reify_key] = principals

    return request.bound_data[reify_key]

INFO:root:生成结果: 
    settings = request.registry.settings
    permission_backend = settings.get("permission_backend")
    if permission_backend:
        try:
            # Assuming permission_backend is a callable that returns a list of principals
            return permission_backend(userid)
        except Exception as e:
            logger.error(f"Error fetching principals for user {userid}: {e}")
            return []
    else:
        logger.warning("Permission backend not configured")
        return []




INFO:root:----------------------------------------
INFO:root:max length: 6747
INFO:root:max position: 8046
INFO:root:target_namespace: kinto.kinto<folder>.core<folder>.authorization<file>.groupfinder<func>
INFO:root:****************************************

data 83:   0%|          | 0/512 [00:00<?, ?it/s]
data 83:   2%|▏         | 10/512 [00:27<23:13,  2.78s/it]
data 83:   4%|▍         | 20/512 [01:08<29:09,  3.56s/it]
data 83:   6%|▌         | 30/512 [01:50<30:57,  3.85s/it]
data 83:   8%|▊         | 40/512 [02:27<29:44,  3.78s/it]
data 83:  10%|▉         | 50/512 [03:07<29:39,  3.85s/it]
data 83:  10%|▉         | 50/512 [03:18<30:33,  3.97s/it]
INFO:root:函数头: 
def groupfinder(userid, request):

INFO:root:目标函数体: 
    
    backend = getattr(request.registry, "permission", None)
    # Permission backend not configured. Ignore.
    if not backend:
        return []

    # Safety check when Kinto-Core is used without pyramid_multiauth.
    if request.prefixed_userid:
        userid = request.prefixed_userid

    # Query the permission backend only once per request (e.g. batch).
    reify_key = userid + "_principals"
    if reify_key not in request.bound_data:
        principals = backend.get_user_principals(userid)
        request.bound_data[reify_key] = principals

    return request.bound_data[reify_key]

INFO:root:生成结果: 
    settings = request.registry.settings
    permission_backend = settings.get("permission_backend")
    if not permission_backend:
        return []

    # Assume permission_backend is a function that returns a list of principals for a given userid
    return permission_backend(userid)




INFO:root:----------------------------------------
INFO:root:max length: 6373
INFO:root:max position: 7731
INFO:root:target_namespace: kinto.kinto<folder>.core<folder>.authorization<file>.groupfinder<func>
INFO:root:****************************************

data 83:   0%|          | 0/512 [00:00<?, ?it/s]
data 83:   2%|▏         | 10/512 [01:32<1:17:02,  9.21s/it]
data 83:   4%|▍         | 20/512 [02:13<51:07,  6.23s/it]  
data 83:   6%|▌         | 30/512 [02:53<41:57,  5.22s/it]
data 83:   8%|▊         | 40/512 [03:34<37:33,  4.77s/it]
data 83:  10%|▉         | 50/512 [04:17<35:20,  4.59s/it]
data 83:  12%|█▏        | 60/512 [04:53<32:12,  4.28s/it]
data 83:  14%|█▎        | 70/512 [05:28<29:31,  4.01s/it]
data 83:  16%|█▌        | 80/512 [05:56<26:02,  3.62s/it]
data 83:  18%|█▊        | 90/512 [06:05<19:32,  2.78s/it]
data 83:  20%|█▉        | 100/512 [06:15<15:22,  2.24s/it]
data 83:  21%|██▏       | 110/512 [06:26<12:38,  1.89s/it]
data 83:  21%|██▏       | 110/512 [06:33<23:57,  3.58s/it]
INFO:root:函数头: 
def groupfinder(userid, request):

INFO:root:目标函数体: 
    
    backend = getattr(request.registry, "permission", None)
    # Permission backend not configured. Ignore.
    if not backend:
        return []

    # Safety check when Kinto-Core is used without pyramid_multiauth.
    if request.prefixed_userid:
        userid = request.prefixed_userid

    # Query the permission backend only once per request (e.g. batch).
    reify_key = userid + "_principals"
    if reify_key not in request.bound_data:
        principals = backend.get_user_principals(userid)
        request.bound_data[reify_key] = principals

    return request.bound_data[reify_key]

INFO:root:生成结果: 
    registry = request.registry
    settings = registry.settings

    # Check if the permission backend is configured
    if settings.get("permission_backend"):
        # Fetch principals from the permission backend
        # This is a placeholder for actual permission backend logic
        # For example, it could query a database or a third-party service
        # and return a list of principals
        # For now, we return an empty list
        return []
    else:
        # If the permission backend is not configured, return an empty list
        return []




INFO:root:----------------------------------------
INFO:root:max length: 6790
INFO:root:max position: 7860
INFO:root:target_namespace: kinto.kinto<folder>.core<folder>.authorization<file>.groupfinder<func>
INFO:root:****************************************

data 83:   0%|          | 0/512 [00:00<?, ?it/s]
data 83:   2%|▏         | 10/512 [00:31<26:01,  3.11s/it]
data 83:   4%|▍         | 20/512 [01:08<28:43,  3.50s/it]
data 83:   6%|▌         | 30/512 [01:51<31:02,  3.87s/it]
data 83:   8%|▊         | 40/512 [05:33<1:27:09, 11.08s/it]
data 83:  10%|▉         | 50/512 [06:14<1:06:05,  8.58s/it]
data 83:  12%|█▏        | 60/512 [06:41<49:37,  6.59s/it]  
data 83:  14%|█▎        | 70/512 [07:13<40:18,  5.47s/it]
data 83:  16%|█▌        | 80/512 [07:30<30:38,  4.26s/it]
data 83:  16%|█▌        | 80/512 [07:38<41:15,  5.73s/it]
INFO:root:函数头: 
def groupfinder(userid, request):

INFO:root:目标函数体: 
    
    backend = getattr(request.registry, "permission", None)
    # Permission backend not configured. Ignore.
    if not backend:
        return []

    # Safety check when Kinto-Core is used without pyramid_multiauth.
    if request.prefixed_userid:
        userid = request.prefixed_userid

    # Query the permission backend only once per request (e.g. batch).
    reify_key = userid + "_principals"
    if reify_key not in request.bound_data:
        principals = backend.get_user_principals(userid)
        request.bound_data[reify_key] = principals

    return request.bound_data[reify_key]

INFO:root:生成结果: 
    # Check if the permission backend is configured
    permission_backend = request.registry.settings.get("permission_backend")
    if not permission_backend:
        return []

    # Fetch principals from the permission backend
    # Implement the logic to fetch principals from the permission backend here
    # For example:
    # principals = fetch_principals_from_permission_backend(permission_backend, userid)
    # return principals

    return []




INFO:root:----------------------------------------
INFO:root:max length: 6734
INFO:root:max position: 7981
INFO:root:target_namespace: kinto.kinto<folder>.core<folder>.authorization<file>.groupfinder<func>
INFO:root:****************************************

data 83:   0%|          | 0/512 [00:00<?, ?it/s]
data 83:   2%|▏         | 10/512 [00:29<24:17,  2.90s/it]
data 83:   4%|▍         | 20/512 [01:10<29:36,  3.61s/it]
data 83:   6%|▌         | 30/512 [01:52<31:17,  3.89s/it]
data 83:   8%|▊         | 40/512 [02:33<31:10,  3.96s/it]
data 83:  10%|▉         | 50/512 [03:11<30:02,  3.90s/it]
data 83:  12%|█▏        | 60/512 [03:38<26:26,  3.51s/it]
data 83:  14%|█▎        | 70/512 [04:15<26:19,  3.57s/it]
data 83:  16%|█▌        | 80/512 [04:32<21:31,  2.99s/it]
data 83:  16%|█▌        | 80/512 [04:54<26:31,  3.68s/it]
INFO:root:函数头: 
def groupfinder(userid, request):

INFO:root:目标函数体: 
    
    backend = getattr(request.registry, "permission", None)
    # Permission backend not configured. Ignore.
    if not backend:
        return []

    # Safety check when Kinto-Core is used without pyramid_multiauth.
    if request.prefixed_userid:
        userid = request.prefixed_userid

    # Query the permission backend only once per request (e.g. batch).
    reify_key = userid + "_principals"
    if reify_key not in request.bound_data:
        principals = backend.get_user_principals(userid)
        request.bound_data[reify_key] = principals

    return request.bound_data[reify_key]

INFO:root:生成结果: 
    settings = request.registry.settings
    permission_backend = settings.get("permission_backend")
    if not permission_backend:
        return []

    # Assume permission backend is configured and fetch principals
    # This is a simplified example. In a real-world scenario, you would call
    # the permission backend's get principals method here.
    # For demonstration purposes, we return a hardcoded list of principals.
    return ["admin", "user"]



INFO:root:----------------------------------------
INFO:root:max length: 6524
INFO:root:max position: 7974
INFO:root:target_namespace: kinto.kinto<folder>.core<folder>.authorization<file>.groupfinder<func>
INFO:root:****************************************
INFO:root:--------data 84--------

data 84:   0%|          | 0/512 [00:00<?, ?it/s]
data 84:   2%|▏         | 10/512 [00:10<08:49,  1.05s/it]
data 84:   4%|▍         | 20/512 [00:19<07:54,  1.04it/s]
data 84:   4%|▍         | 20/512 [00:24<09:55,  1.21s/it]
INFO:root:函数头: 
    def dumps(v, **kw):

INFO:root:目标函数体: 
        kw.setdefault("bytes_mode", rapidjson.BM_NONE)
        return rapidjson.dumps(v, **kw)

INFO:root:生成结果: 
        return rapidjson.dumps(v, **{**kw, "bytes_mode": rapidjson.BM_NONE})


INFO:root:----------------------------------------
INFO:root:max length: 4422
INFO:root:max position: 4422
INFO:root:target_namespace: kinto.kinto<folder>.core<folder>.utils<file>.json<class>.dumps<func>
INFO:root:****************************************

data 84:   0%|          | 0/512 [00:00<?, ?it/s]
data 84:   2%|▏         | 10/512 [00:08<07:05,  1.18it/s]
data 84:   2%|▏         | 10/512 [00:10<08:35,  1.03s/it]
INFO:root:函数头: 
    def dumps(v, **kw):

INFO:root:目标函数体: 
        kw.setdefault("bytes_mode", rapidjson.BM_NONE)
        return rapidjson.dumps(v, **kw)

INFO:root:生成结果: 
        return rapidjson.dumps(v, **kw)




INFO:root:----------------------------------------
INFO:root:max length: 4414
INFO:root:max position: 4414
INFO:root:target_namespace: kinto.kinto<folder>.core<folder>.utils<file>.json<class>.dumps<func>
INFO:root:****************************************

data 84:   0%|          | 0/512 [00:00<?, ?it/s]
data 84:   2%|▏         | 10/512 [00:08<06:54,  1.21it/s]
data 84:   2%|▏         | 10/512 [00:10<08:24,  1.01s/it]
INFO:root:函数头: 
    def dumps(v, **kw):

INFO:root:目标函数体: 
        kw.setdefault("bytes_mode", rapidjson.BM_NONE)
        return rapidjson.dumps(v, **kw)

INFO:root:生成结果: 
        return rapidjson.dumps(v, **kw)




INFO:root:----------------------------------------
INFO:root:max length: 4414
INFO:root:max position: 4414
INFO:root:target_namespace: kinto.kinto<folder>.core<folder>.utils<file>.json<class>.dumps<func>
INFO:root:****************************************

data 84:   0%|          | 0/512 [00:00<?, ?it/s]
data 84:   2%|▏         | 10/512 [00:08<06:57,  1.20it/s]
data 84:   4%|▍         | 20/512 [00:17<07:09,  1.15it/s]
data 84:   4%|▍         | 20/512 [00:21<09:00,  1.10s/it]
INFO:root:函数头: 
    def dumps(v, **kw):

INFO:root:目标函数体: 
        kw.setdefault("bytes_mode", rapidjson.BM_NONE)
        return rapidjson.dumps(v, **kw)

INFO:root:生成结果: 
        return rapidjson.dumps(v, **{**kw, "bytes_mode": rapidjson.BM_NONE})


INFO:root:----------------------------------------
INFO:root:max length: 4422
INFO:root:max position: 4422
INFO:root:target_namespace: kinto.kinto<folder>.core<folder>.utils<file>.json<class>.dumps<func>
INFO:root:****************************************

data 84:   0%|          | 0/512 [00:00<?, ?it/s]
data 84:   2%|▏         | 10/512 [00:08<06:57,  1.20it/s]
data 84:   2%|▏         | 10/512 [00:10<08:26,  1.01s/it]
INFO:root:函数头: 
    def dumps(v, **kw):

INFO:root:目标函数体: 
        kw.setdefault("bytes_mode", rapidjson.BM_NONE)
        return rapidjson.dumps(v, **kw)

INFO:root:生成结果: 
        return rapidjson.dumps(v, **kw)




INFO:root:----------------------------------------
INFO:root:max length: 4414
INFO:root:max position: 4414
INFO:root:target_namespace: kinto.kinto<folder>.core<folder>.utils<file>.json<class>.dumps<func>
INFO:root:****************************************
INFO:root:--------data 85--------

data 85:   0%|          | 0/512 [00:00<?, ?it/s]
data 85:   2%|▏         | 10/512 [00:10<08:48,  1.05s/it]
data 85:   4%|▍         | 20/512 [00:40<17:57,  2.19s/it]
data 85:   4%|▍         | 20/512 [00:48<19:59,  2.44s/it]
INFO:root:函数头: 
    def loads(v, **kw):

INFO:root:目标函数体: 
        kw.setdefault("number_mode", rapidjson.NM_NATIVE)
        return rapidjson.loads(v, **kw)

INFO:root:生成结果: 
        kw.setdefault("number_mode", rapidjson.NM_NATIVE)
        return rapidjson.loads(v, **kw)




INFO:root:----------------------------------------
INFO:root:max length: 6074
INFO:root:max position: 7899
INFO:root:target_namespace: kinto.kinto<folder>.core<folder>.utils<file>.json<class>.loads<func>
INFO:root:****************************************

data 85:   0%|          | 0/512 [00:00<?, ?it/s]
data 85:   2%|▏         | 10/512 [00:08<07:14,  1.15it/s]
data 85:   4%|▍         | 20/512 [00:39<17:49,  2.17s/it]
data 85:   4%|▍         | 20/512 [00:47<19:25,  2.37s/it]
INFO:root:函数头: 
    def loads(v, **kw):

INFO:root:目标函数体: 
        kw.setdefault("number_mode", rapidjson.NM_NATIVE)
        return rapidjson.loads(v, **kw)

INFO:root:生成结果: 
        kw.setdefault("number_mode", rapidjson.NM_NATIVE)
        return rapidjson.loads(v, **kw)




INFO:root:----------------------------------------
INFO:root:max length: 5688
INFO:root:max position: 8086
INFO:root:target_namespace: kinto.kinto<folder>.core<folder>.utils<file>.json<class>.loads<func>
INFO:root:****************************************

data 85:   0%|          | 0/512 [00:00<?, ?it/s]
data 85:   2%|▏         | 10/512 [00:08<07:11,  1.16it/s]
data 85:   4%|▍         | 20/512 [00:41<18:32,  2.26s/it]
data 85:   4%|▍         | 20/512 [00:49<20:17,  2.47s/it]
INFO:root:函数头: 
    def loads(v, **kw):

INFO:root:目标函数体: 
        kw.setdefault("number_mode", rapidjson.NM_NATIVE)
        return rapidjson.loads(v, **kw)

INFO:root:生成结果: 
        kw.setdefault("number_mode", rapidjson.NM_NATIVE)
        return rapidjson.loads(v, **kw)




INFO:root:----------------------------------------
INFO:root:max length: 6581
INFO:root:max position: 7901
INFO:root:target_namespace: kinto.kinto<folder>.core<folder>.utils<file>.json<class>.loads<func>
INFO:root:****************************************

data 85:   0%|          | 0/512 [00:00<?, ?it/s]
data 85:   2%|▏         | 10/512 [00:08<07:21,  1.14it/s]
data 85:   4%|▍         | 20/512 [00:37<16:52,  2.06s/it]
data 85:   4%|▍         | 20/512 [00:42<17:23,  2.12s/it]
INFO:root:函数头: 
    def loads(v, **kw):

INFO:root:目标函数体: 
        kw.setdefault("number_mode", rapidjson.NM_NATIVE)
        return rapidjson.loads(v, **kw)

INFO:root:生成结果: 
        kw.setdefault("number_mode", rapidjson.NM_NATIVE)
        return rapidjson.loads(v, **kw)




INFO:root:----------------------------------------
INFO:root:max length: 6066
INFO:root:max position: 7571
INFO:root:target_namespace: kinto.kinto<folder>.core<folder>.utils<file>.json<class>.loads<func>
INFO:root:****************************************

data 85:   0%|          | 0/512 [00:00<?, ?it/s]
data 85:   2%|▏         | 10/512 [00:08<07:10,  1.17it/s]
data 85:   4%|▍         | 20/512 [00:41<18:34,  2.27s/it]
data 85:   4%|▍         | 20/512 [00:49<20:12,  2.46s/it]
INFO:root:函数头: 
    def loads(v, **kw):

INFO:root:目标函数体: 
        kw.setdefault("number_mode", rapidjson.NM_NATIVE)
        return rapidjson.loads(v, **kw)

INFO:root:生成结果: 
        kw.setdefault("number_mode", rapidjson.NM_NATIVE)
        return rapidjson.loads(v, **kw)




INFO:root:----------------------------------------
INFO:root:max length: 6202
INFO:root:max position: 7756
INFO:root:target_namespace: kinto.kinto<folder>.core<folder>.utils<file>.json<class>.loads<func>
INFO:root:****************************************
INFO:root:--------data 86--------

data 86:   0%|          | 0/512 [00:00<?, ?it/s]
data 86:   2%|▏         | 10/512 [00:34<28:29,  3.40s/it]
data 86:   4%|▍         | 20/512 [00:58<23:21,  2.85s/it]
data 86:   6%|▌         | 30/512 [01:19<20:01,  2.49s/it]
data 86:   8%|▊         | 40/512 [01:32<15:53,  2.02s/it]
data 86:   8%|▊         | 40/512 [01:45<20:47,  2.64s/it]
INFO:root:函数头: 
def hmac_digest(secret, message, encoding="utf-8"):

INFO:root:目标函数体: 
    
    if isinstance(secret, str):
        secret = secret.encode(encoding)
    return hmac.new(secret, message.encode(encoding), hashlib.sha256).hexdigest()

INFO:root:生成结果: 
    import hmac
    import hashlib

    secret_bytes = secret.encode(encoding)
    message_bytes = message.encode(encoding)
    digest = hmac.new(secret_bytes, message_bytes, hashlib.sha256).digest()
    return digest.hex()


INFO:root:----------------------------------------
INFO:root:max length: 6449
INFO:root:max position: 7992
INFO:root:target_namespace: kinto.kinto<folder>.core<folder>.utils<file>.hmac_digest<func>
INFO:root:****************************************

data 86:   0%|          | 0/512 [00:00<?, ?it/s]
data 86:   2%|▏         | 10/512 [00:32<26:49,  3.21s/it]
data 86:   4%|▍         | 20/512 [00:54<21:33,  2.63s/it]
data 86:   6%|▌         | 30/512 [01:15<19:08,  2.38s/it]
data 86:   8%|▊         | 40/512 [01:28<15:25,  1.96s/it]
data 86:   8%|▊         | 40/512 [01:30<17:53,  2.27s/it]
INFO:root:函数头: 
def hmac_digest(secret, message, encoding="utf-8"):

INFO:root:目标函数体: 
    
    if isinstance(secret, str):
        secret = secret.encode(encoding)
    return hmac.new(secret, message.encode(encoding), hashlib.sha256).hexdigest()

INFO:root:生成结果: 
    import hashlib
    import hmac

    if isinstance(secret, str):
        secret = secret.encode(encoding)

    return hmac.digest(secret, message.encode(encoding), hashlib.sha256).hex()




INFO:root:----------------------------------------
INFO:root:max length: 6863
INFO:root:max position: 8505
INFO:root:target_namespace: kinto.kinto<folder>.core<folder>.utils<file>.hmac_digest<func>
INFO:root:****************************************

data 86:   0%|          | 0/512 [00:00<?, ?it/s]
data 86:   2%|▏         | 10/512 [00:31<26:10,  3.13s/it]
data 86:   4%|▍         | 20/512 [00:54<21:43,  2.65s/it]
data 86:   6%|▌         | 30/512 [01:20<21:06,  2.63s/it]
data 86:   8%|▊         | 40/512 [01:33<16:35,  2.11s/it]
data 86:   8%|▊         | 40/512 [01:41<20:00,  2.54s/it]
INFO:root:函数头: 
def hmac_digest(secret, message, encoding="utf-8"):

INFO:root:目标函数体: 
    
    if isinstance(secret, str):
        secret = secret.encode(encoding)
    return hmac.new(secret, message.encode(encoding), hashlib.sha256).hexdigest()

INFO:root:生成结果: 
    import hashlib
    import hmac

    if isinstance(secret, str):
        secret = secret.encode(encoding)

    digest = hmac.digest(secret, message.encode(encoding), hashlib.sha256)
    return digest.hex()




INFO:root:----------------------------------------
INFO:root:max length: 6362
INFO:root:max position: 8464
INFO:root:target_namespace: kinto.kinto<folder>.core<folder>.utils<file>.hmac_digest<func>
INFO:root:****************************************

data 86:   0%|          | 0/512 [00:00<?, ?it/s]
data 86:   2%|▏         | 10/512 [00:32<27:12,  3.25s/it]
data 86:   4%|▍         | 20/512 [01:01<24:47,  3.02s/it]
data 86:   6%|▌         | 30/512 [01:20<20:25,  2.54s/it]
data 86:   8%|▊         | 40/512 [01:33<16:06,  2.05s/it]
data 86:   8%|▊         | 40/512 [01:44<20:35,  2.62s/it]
INFO:root:函数头: 
def hmac_digest(secret, message, encoding="utf-8"):

INFO:root:目标函数体: 
    
    if isinstance(secret, str):
        secret = secret.encode(encoding)
    return hmac.new(secret, message.encode(encoding), hashlib.sha256).hexdigest()

INFO:root:生成结果: 
    import hashlib
    import hmac

    secret_bytes = secret.encode(encoding)
    message_bytes = message.encode(encoding)
    digest = hmac.digest(secret_bytes, message_bytes, hashlib.sha256)
    return digest.hex()




INFO:root:----------------------------------------
INFO:root:max length: 6661
INFO:root:max position: 8662
INFO:root:target_namespace: kinto.kinto<folder>.core<folder>.utils<file>.hmac_digest<func>
INFO:root:****************************************

data 86:   0%|          | 0/512 [00:00<?, ?it/s]
data 86:   2%|▏         | 10/512 [00:31<26:20,  3.15s/it]
data 86:   4%|▍         | 20/512 [00:55<22:14,  2.71s/it]
data 86:   6%|▌         | 30/512 [01:19<20:40,  2.57s/it]
data 86:   8%|▊         | 40/512 [01:32<16:20,  2.08s/it]
data 86:   8%|▊         | 40/512 [01:35<18:46,  2.39s/it]
INFO:root:函数头: 
def hmac_digest(secret, message, encoding="utf-8"):

INFO:root:目标函数体: 
    
    if isinstance(secret, str):
        secret = secret.encode(encoding)
    return hmac.new(secret, message.encode(encoding), hashlib.sha256).hexdigest()

INFO:root:生成结果: 
    import hashlib
    import hmac

    if isinstance(secret, str):
        secret = secret.encode(encoding)

    return hmac.digest(secret, message.encode(encoding), hashlib.sha256).hex()




INFO:root:----------------------------------------
INFO:root:max length: 6446
INFO:root:max position: 8337
INFO:root:target_namespace: kinto.kinto<folder>.core<folder>.utils<file>.hmac_digest<func>
INFO:root:****************************************
INFO:root:--------data 87--------

data 87:   0%|          | 0/512 [00:00<?, ?it/s]
data 87:   2%|▏         | 10/512 [00:32<26:56,  3.22s/it]
data 87:   4%|▍         | 20/512 [01:14<31:16,  3.81s/it]
data 87:   6%|▌         | 30/512 [01:52<30:44,  3.83s/it]
data 87:   8%|▊         | 40/512 [02:08<22:55,  2.91s/it]
data 87:  10%|▉         | 50/512 [02:40<23:15,  3.02s/it]
data 87:  10%|▉         | 50/512 [05:55<54:46,  7.11s/it]
INFO:root:函数头: 
def current_service(request):

INFO:root:目标函数体: 
    
    if request.matched_route:
        services = request.registry.cornice_services
        pattern = request.matched_route.pattern
        try:
            service = services[pattern]
        except KeyError:
            return None
        else:
            return service

INFO:root:生成结果: 
    registry = request.registry
    services = registry[" pyramid configurator"].services
    match_result = services.match(request=request)
    if match_result:
        service_name = match_result["name"]
        service = services[service_name]
        return service
    return None




INFO:root:----------------------------------------
INFO:root:max length: 7229
INFO:root:max position: 9113
INFO:root:target_namespace: kinto.kinto<folder>.core<folder>.utils<file>.current_service<func>
INFO:root:****************************************

data 87:   0%|          | 0/512 [00:00<?, ?it/s]
data 87:   2%|▏         | 10/512 [03:29<2:55:08, 20.93s/it]
data 87:   4%|▍         | 20/512 [04:12<1:31:30, 11.16s/it]
data 87:   6%|▌         | 30/512 [04:58<1:05:44,  8.18s/it]
data 87:   8%|▊         | 40/512 [05:21<45:54,  5.84s/it]  
data 87:  10%|▉         | 50/512 [05:43<35:00,  4.55s/it]
data 87:  12%|█▏        | 60/512 [06:06<28:26,  3.78s/it]
data 87:  14%|█▎        | 70/512 [06:29<24:07,  3.28s/it]
data 87:  16%|█▌        | 80/512 [06:55<22:04,  3.07s/it]
data 87:  18%|█▊        | 90/512 [07:15<19:10,  2.73s/it]
data 87:  20%|█▉        | 100/512 [07:45<19:23,  2.82s/it]
data 87:  20%|█▉        | 100/512 [08:02<33:08,  4.83s/it]
INFO:root:函数头: 
def current_service(request):

INFO:root:目标函数体: 
    
    if request.matched_route:
        services = request.registry.cornice_services
        pattern = request.matched_route.pattern
        try:
            service = services[pattern]
        except KeyError:
            return None
        else:
            return service

INFO:root:生成结果: 
    registry = request.registry
    services = registry["services"]
    routes_mapper = registry[ "routes_mapper"]

    # Get the route matching the request
    route = routes_mapper.match(request)

    # If no route matches, return None
    if route is None:
        return None

    # Get the service associated with the route
    service = services.get(route.name)

    # If no service is found, return None
    if service is None:
        return None

    return service




INFO:root:----------------------------------------
INFO:root:max length: 7317
INFO:root:max position: 9358
INFO:root:target_namespace: kinto.kinto<folder>.core<folder>.utils<file>.current_service<func>
INFO:root:****************************************

data 87:   0%|          | 0/512 [00:00<?, ?it/s]
data 87:   2%|▏         | 10/512 [00:28<23:39,  2.83s/it]
data 87:   4%|▍         | 20/512 [01:14<31:41,  3.86s/it]
data 87:   6%|▌         | 30/512 [01:54<31:31,  3.92s/it]
data 87:   8%|▊         | 40/512 [02:08<23:11,  2.95s/it]
data 87:  10%|▉         | 50/512 [02:30<20:33,  2.67s/it]
data 87:  12%|█▏        | 60/512 [02:58<20:32,  2.73s/it]
data 87:  14%|█▎        | 70/512 [03:22<19:06,  2.59s/it]
data 87:  16%|█▌        | 80/512 [03:48<18:42,  2.60s/it]
data 87:  18%|█▊        | 90/512 [04:08<17:01,  2.42s/it]
data 87:  20%|█▉        | 100/512 [04:44<19:13,  2.80s/it]
data 87:  21%|██▏       | 110/512 [05:11<18:31,  2.77s/it]
data 87:  21%|██▏       | 110/512 [05:26<19:51,  2.96s/it]
INFO:root:函数头: 
def current_service(request):

INFO:root:目标函数体: 
    
    if request.matched_route:
        services = request.registry.cornice_services
        pattern = request.matched_route.pattern
        try:
            service = services[pattern]
        except KeyError:
            return None
        else:
            return service

INFO:root:生成结果: 
    registry = request.registry
    services = registry[" pyramid.config"].services
    route_name = request.route_name
    match_result = request.matchdict

    # Try to match the route name with the service names
    for service_name in services.keys():
        if service_name == route_name:
            return services[service_name]

    # Try to match the route name with the service names using matchdict
    for service_name in services.keys():
        service = services[service_name]
        if service.match(match_result):
            return service

    return None


INFO:root:----------------------------------------
INFO:root:max length: 7235
INFO:root:max position: 9216
INFO:root:target_namespace: kinto.kinto<folder>.core<folder>.utils<file>.current_service<func>
INFO:root:****************************************

data 87:   0%|          | 0/512 [00:00<?, ?it/s]
data 87:   2%|▏         | 10/512 [00:31<26:33,  3.17s/it]
data 87:   4%|▍         | 20/512 [01:14<31:32,  3.85s/it]
data 87:   6%|▌         | 30/512 [01:57<32:24,  4.03s/it]
data 87:   8%|▊         | 40/512 [02:15<24:54,  3.17s/it]
data 87:  10%|▉         | 50/512 [02:41<22:44,  2.95s/it]
data 87:  10%|▉         | 50/512 [03:06<28:38,  3.72s/it]
INFO:root:函数头: 
def current_service(request):

INFO:root:目标函数体: 
    
    if request.matched_route:
        services = request.registry.cornice_services
        pattern = request.matched_route.pattern
        try:
            service = services[pattern]
        except KeyError:
            return None
        else:
            return service

INFO:root:生成结果: 
    registry = request.registry
    services = registry["services"]
    route_pattern = request.route_pattern

    # Find the service that matches the request route pattern
    for service in services.values():
        if service.route_pattern == route_pattern:
            return service

    return None


INFO:root:----------------------------------------
INFO:root:max length: 7742
INFO:root:max position: 10420
INFO:root:target_namespace: kinto.kinto<folder>.core<folder>.utils<file>.current_service<func>
INFO:root:****************************************

data 87:   0%|          | 0/512 [00:00<?, ?it/s]
data 87:   2%|▏         | 10/512 [00:27<23:14,  2.78s/it]
data 87:   4%|▍         | 20/512 [01:10<30:12,  3.68s/it]
data 87:   6%|▌         | 30/512 [01:53<31:39,  3.94s/it]
data 87:   8%|▊         | 40/512 [02:11<24:20,  3.10s/it]
data 87:  10%|▉         | 50/512 [02:33<21:26,  2.79s/it]
data 87:  12%|█▏        | 60/512 [02:52<18:31,  2.46s/it]
data 87:  14%|█▎        | 70/512 [03:15<17:44,  2.41s/it]
data 87:  16%|█▌        | 80/512 [03:40<17:43,  2.46s/it]
data 87:  18%|█▊        | 90/512 [04:00<16:18,  2.32s/it]
data 87:  20%|█▉        | 100/512 [04:32<17:37,  2.57s/it]
data 87:  20%|█▉        | 100/512 [04:58<20:30,  2.99s/it]
INFO:root:函数头: 
def current_service(request):

INFO:root:目标函数体: 
    
    if request.matched_route:
        services = request.registry.cornice_services
        pattern = request.matched_route.pattern
        try:
            service = services[pattern]
        except KeyError:
            return None
        else:
            return service

INFO:root:生成结果: 
    registry = request.registry
    services = registry["services"]
    routes = registry["routes"]

    # Find the route that matches the request path
    matched_route = next((route for route in routes if route.match(request.path)), None)

    # If no route matches, return None
    if matched_route is None:
        return None

    # Get the service associated with the matched route
    service = services.get(matched_route.name)

    # Return the service if found, otherwise return None
    return service




INFO:root:----------------------------------------
INFO:root:max length: 7396
INFO:root:max position: 9227
INFO:root:target_namespace: kinto.kinto<folder>.core<folder>.utils<file>.current_service<func>
INFO:root:****************************************
INFO:root:--------data 88--------

data 88:   0%|          | 0/512 [00:00<?, ?it/s]
data 88:   2%|▏         | 10/512 [00:16<13:48,  1.65s/it]
data 88:   4%|▍         | 20/512 [00:52<22:57,  2.80s/it]
data 88:   6%|▌         | 30/512 [01:35<27:58,  3.48s/it]
data 88:   8%|▊         | 40/512 [01:57<23:32,  2.99s/it]
data 88:  10%|▉         | 50/512 [02:31<23:57,  3.11s/it]
data 88:  12%|█▏        | 60/512 [03:10<25:27,  3.38s/it]
data 88:  14%|█▎        | 70/512 [03:59<28:42,  3.90s/it]
data 88:  16%|█▌        | 80/512 [04:50<30:45,  4.27s/it]
data 88:  18%|█▊        | 90/512 [05:33<30:12,  4.30s/it]
data 88:  20%|█▉        | 100/512 [05:49<23:44,  3.46s/it]
data 88:  21%|██▏       | 110/512 [06:05<19:21,  2.89s/it]
data 88:  23%|██▎       | 120/512 [06:24<16:56,  2.59s/it]
data 88:  23%|██▎       | 120/512 [06:32<21:23,  3.27s/it]
INFO:root:函数头: 
def prefixed_principals(request):

INFO:root:目标函数体: 
    
    principals = request.effective_principals
    if Authenticated not in principals:
        return principals

    # Remove unprefixed user id on effective_principals to avoid conflicts.
    # (it is added via Pyramid Authn policy effective principals)
    prefix, userid = request.prefixed_userid.split(":", 1)
    principals = [p for p in principals if p != userid]

    if request.prefixed_userid not in principals:
        principals = [request.prefixed_userid] + principals

    return principals

INFO:root:生成结果: 
    # Import necessary resources here
    from kinto.core.auth import principals

    # Get the list of effective principals from the request object
    effective_principals = request.effective principals

    # Check if the "Authenticated" principal is in the list
    if "Authenticated" in effective principals:
        # Remove the unprefix user id from the effective principals to avoid conflicts
        effective_principals.remove(request.selected_userid)

    # Add the prefixed user id to the beginning of the list
    effective_principals.insert(0, request.selected_userid)

    return effective_principals


INFO:root:----------------------------------------
INFO:root:max length: 7884
INFO:root:max position: 9503
INFO:root:target_namespace: kinto.kinto<folder>.core<folder>.utils<file>.prefixed_principals<func>
INFO:root:****************************************

data 88:   0%|          | 0/512 [00:00<?, ?it/s]
data 88:   2%|▏         | 10/512 [00:14<11:49,  1.41s/it]
data 88:   4%|▍         | 20/512 [00:45<19:57,  2.43s/it]
data 88:   6%|▌         | 30/512 [01:17<22:29,  2.80s/it]
data 88:   8%|▊         | 40/512 [01:37<19:14,  2.45s/it]
data 88:  10%|▉         | 50/512 [02:08<20:53,  2.71s/it]
data 88:  12%|█▏        | 60/512 [02:44<22:36,  3.00s/it]
data 88:  14%|█▎        | 70/512 [03:35<27:10,  3.69s/it]
data 88:  16%|█▌        | 80/512 [04:26<29:48,  4.14s/it]
data 88:  18%|█▊        | 90/512 [05:06<28:48,  4.10s/it]
data 88:  20%|█▉        | 100/512 [05:25<23:27,  3.42s/it]
data 88:  21%|██▏       | 110/512 [05:51<21:14,  3.17s/it]
data 88:  23%|██▎       | 120/512 [06:07<17:30,  2.68s/it]
data 88:  25%|██▌       | 130/512 [06:23<14:58,  2.35s/it]
data 88:  27%|██▋       | 140/512 [06:39<13:13,  2.13s/it]
data 88:  29%|██▉       | 150/512 [06:56<11:59,  1.99s/it]
data 88:  31%|███▏      | 160/512 [07:12<11:02,  1.88s/it]
data 88:  33%|███▎      | 170/512 [07:28<10:16,  1.80s/it]
data 88:  33%|███▎      | 170/512 [07:41<15:28,  2.71s/it]
INFO:root:函数头: 
def prefixed_principals(request):

INFO:root:目标函数体: 
    
    principals = request.effective_principals
    if Authenticated not in principals:
        return principals

    # Remove unprefixed user id on effective_principals to avoid conflicts.
    # (it is added via Pyramid Authn policy effective principals)
    prefix, userid = request.prefixed_userid.split(":", 1)
    principals = [p for p in principals if p != userid]

    if request.prefixed_userid not in principals:
        principals = [request.prefixed_userid] + principals

    return principals

INFO:root:生成结果: 
    # Import necessary resources
    from kinto.core import auth

    # Get the list of effective principals from the request object
    effective_principals = request.effective_principals

    # Get the authenticated principal from the request object
    authenticated_principal = request.authenticated_userid

    # If the authenticated principal is not in the effective principals list, return the original list of effective principals
    if authenticated_principal not in effective_principals:
        return effective_principals

    # Remove the unp prefixed user id from the effective principals list to avoid conflicts
    effective_principals.remove(authenticated_principal)

    # Add the prefixed user id to the beginning of the effective principals list
    effective_principals.insert(0, authenticated_principal)

    # Return the list of effective principals with the prefixed user id
    return effective_principals


INFO:root:----------------------------------------
INFO:root:max length: 7580
INFO:root:max position: 9597
INFO:root:target_namespace: kinto.kinto<folder>.core<folder>.utils<file>.prefixed_principals<func>
INFO:root:****************************************

data 88:   0%|          | 0/512 [00:00<?, ?it/s]
data 88:   2%|▏         | 10/512 [00:17<14:35,  1.74s/it]
data 88:   4%|▍         | 20/512 [00:50<21:38,  2.64s/it]
data 88:   6%|▌         | 30/512 [01:26<25:00,  3.11s/it]
data 88:   8%|▊         | 40/512 [01:52<22:50,  2.90s/it]
data 88:  10%|▉         | 50/512 [02:30<24:40,  3.20s/it]
data 88:  12%|█▏        | 60/512 [03:19<28:38,  3.80s/it]
data 88:  14%|█▎        | 70/512 [04:08<30:40,  4.16s/it]
data 88:  16%|█▌        | 80/512 [04:59<32:01,  4.45s/it]
data 88:  18%|█▊        | 90/512 [05:25<27:15,  3.87s/it]
data 88:  20%|█▉        | 100/512 [05:41<21:46,  3.17s/it]
data 88:  21%|██▏       | 110/512 [05:57<18:02,  2.69s/it]
data 88:  23%|██▎       | 120/512 [06:16<16:01,  2.45s/it]
data 88:  25%|██▌       | 130/512 [06:32<13:53,  2.18s/it]
data 88:  25%|██▌       | 130/512 [06:35<19:21,  3.04s/it]
INFO:root:函数头: 
def prefixed_principals(request):

INFO:root:目标函数体: 
    
    principals = request.effective_principals
    if Authenticated not in principals:
        return principals

    # Remove unprefixed user id on effective_principals to avoid conflicts.
    # (it is added via Pyramid Authn policy effective principals)
    prefix, userid = request.prefixed_userid.split(":", 1)
    principals = [p for p in principals if p != userid]

    if request.prefixed_userid not in principals:
        principals = [request.prefixed_userid] + principals

    return principals

INFO:root:生成结果: 
    principals = request principals.get("effective principals", [])
    authn_type = request.authn_type
    authn_id = request.authn_id

    if authn_type == "authenticated":
        authn_id = authn_id.split(":")[1]

    if authn_id not in principals:
        return principals

    # Remove the authn_id from effective principals to avoid conflicts
    effective principals = [p for p in request principals if p != authn_id]

    # Add the prefixed authn_id to the beginning of the list
    return [authn_type + ":" + authn_id] + effective principals


INFO:root:----------------------------------------
INFO:root:max length: 8073
INFO:root:max position: 9524
INFO:root:target_namespace: kinto.kinto<folder>.core<folder>.utils<file>.prefixed_principals<func>
INFO:root:****************************************

data 88:   0%|          | 0/512 [00:00<?, ?it/s]
data 88:   2%|▏         | 10/512 [00:14<11:55,  1.43s/it]
data 88:   4%|▍         | 20/512 [00:47<20:50,  2.54s/it]
data 88:   6%|▌         | 30/512 [01:19<22:54,  2.85s/it]
data 88:   8%|▊         | 40/512 [01:38<19:34,  2.49s/it]
data 88:  10%|▉         | 50/512 [02:18<23:10,  3.01s/it]
data 88:  12%|█▏        | 60/512 [03:04<26:40,  3.54s/it]
data 88:  14%|█▎        | 70/512 [03:55<29:58,  4.07s/it]
data 88:  16%|█▌        | 80/512 [07:37<1:10:55,  9.85s/it]
data 88:  18%|█▊        | 90/512 [08:15<55:50,  7.94s/it]  
data 88:  20%|█▉        | 100/512 [08:38<42:33,  6.20s/it]
data 88:  21%|██▏       | 110/512 [08:54<32:08,  4.80s/it]
data 88:  23%|██▎       | 120/512 [09:13<25:38,  3.93s/it]
data 88:  25%|██▌       | 130/512 [09:30<20:32,  3.23s/it]
data 88:  27%|██▋       | 140/512 [09:46<17:00,  2.74s/it]
data 88:  29%|██▉       | 150/512 [10:02<14:31,  2.41s/it]
data 88:  31%|███▏      | 160/512 [10:18<12:45,  2.17s/it]
data 88:  33%|███▎      | 170/512 [10:35<11:26,  2.01s/it]
data 88:  33%|███▎      | 170/512 [10:38<21:24,  3.75s/it]
INFO:root:函数头: 
def prefixed_principals(request):

INFO:root:目标函数体: 
    
    principals = request.effective_principals
    if Authenticated not in principals:
        return principals

    # Remove unprefixed user id on effective_principals to avoid conflicts.
    # (it is added via Pyramid Authn policy effective principals)
    prefix, userid = request.prefixed_userid.split(":", 1)
    principals = [p for p in principals if p != userid]

    if request.prefixed_userid not in principals:
        principals = [request.prefixed_userid] + principals

    return principals

INFO:root:生成结果: 
    # Importing the necessary resource
    from kinto.core.auth import get_user_id

    # Get the list of principals from the request object
    principals = request principals.get("effective principals", [])

    # Get the user id from the request object
    user_id = request principals.get("Authenticated")

    # If the "Authenticated" principal is not in the list, return the original list of principals
    if user_id is None:
        return principals

    # Remove the unprefix user id from the effective principals to avoid conflicts
    effective principals = [p for p in request principals if p != user_id]

    # Add the prefixed user id to the beginning of the list
    effective principals.insert(0, user_id)

    # Return the list of principals with the prefixed user id
    return effective principals


INFO:root:----------------------------------------
INFO:root:max length: 7963
INFO:root:max position: 9455
INFO:root:target_namespace: kinto.kinto<folder>.core<folder>.utils<file>.prefixed_principals<func>
INFO:root:****************************************

data 88:   0%|          | 0/512 [00:00<?, ?it/s]
data 88:   2%|▏         | 10/512 [00:17<14:42,  1.76s/it]
data 88:   4%|▍         | 20/512 [00:46<20:03,  2.45s/it]
data 88:   6%|▌         | 30/512 [01:19<22:37,  2.82s/it]
data 88:   8%|▊         | 40/512 [01:38<19:22,  2.46s/it]
data 88:  10%|▉         | 50/512 [02:11<21:22,  2.78s/it]
data 88:  12%|█▏        | 60/512 [02:57<25:20,  3.36s/it]
data 88:  14%|█▎        | 70/512 [03:49<29:14,  3.97s/it]
data 88:  16%|█▌        | 80/512 [04:32<29:19,  4.07s/it]
data 88:  16%|█▌        | 80/512 [04:53<26:26,  3.67s/it]
INFO:root:函数头: 
def prefixed_principals(request):

INFO:root:目标函数体: 
    
    principals = request.effective_principals
    if Authenticated not in principals:
        return principals

    # Remove unprefixed user id on effective_principals to avoid conflicts.
    # (it is added via Pyramid Authn policy effective principals)
    prefix, userid = request.prefixed_userid.split(":", 1)
    principals = [p for p in principals if p != userid]

    if request.prefixed_userid not in principals:
        principals = [request.prefixed_userid] + principals

    return principals

INFO:root:生成结果: 
    principals = request principals.get("effective principals", [])
    authenticated_principal = request principals.get("Authenticated")
    if authenticated_principal:
        # Remove the unp prefixed user id from effective principals to avoid conflicts
        effective principals = [p for p in effective principals if p != authenticated_principal]
        # Add the prefixed user id to the beginning of the list
        principals.insert(0, authenticated_principal)
    return principals


INFO:root:----------------------------------------
INFO:root:max length: 8676
INFO:root:max position: 9538
INFO:root:target_namespace: kinto.kinto<folder>.core<folder>.utils<file>.prefixed_principals<func>
INFO:root:****************************************
INFO:root:--------data 89--------

data 89:   0%|          | 0/512 [00:00<?, ?it/s]
data 89:   2%|▏         | 10/512 [00:11<09:33,  1.14s/it]
data 89:   4%|▍         | 20/512 [00:21<08:42,  1.06s/it]
data 89:   6%|▌         | 30/512 [00:31<08:15,  1.03s/it]
data 89:   8%|▊         | 40/512 [00:41<08:02,  1.02s/it]
data 89:   8%|▊         | 40/512 [00:51<10:08,  1.29s/it]
INFO:root:函数头: 
@subscriber(ResourceChanged, for_resources=("account",), for_actions=(ACTIONS.CREATE,))
def on_account_created(event):

INFO:root:目标函数体: 
    request = event.request
    settings = request.registry.settings
    if not settings.get("account_validation", False):
        return

    for impacted_object in event.impacted_objects:
        account = impacted_object["new"]
        user_email = account["id"]
        activation_key = get_cached_validation_key(user_email, request.registry)
        if activation_key is None:
            continue

        # Send an email to the user with the link to activate their account.
        Emailer(request, account).send_activation(activation_key)

INFO:root:生成结果: 
    request = event.request

    for obj in event.imp impacted_objects:
        # Extract username and password from current user
        username = obj["old"]["id"]
        # Delete cache
        delete_cached_account(username, request.registry)


INFO:root:----------------------------------------
INFO:root:max length: 4797
INFO:root:max position: 4905
INFO:root:target_namespace: kinto.kinto<folder>.plugins<folder>.accounts<folder>.views<folder>.__init__<file>.on_account_created<func>
INFO:root:****************************************

data 89:   0%|          | 0/512 [00:00<?, ?it/s]
data 89:   2%|▏         | 10/512 [00:09<08:03,  1.04it/s]
data 89:   4%|▍         | 20/512 [00:19<08:08,  1.01it/s]
data 89:   6%|▌         | 30/512 [00:29<08:03,  1.00s/it]
data 89:   8%|▊         | 40/512 [00:40<07:58,  1.01s/it]
data 89:  10%|▉         | 50/512 [00:50<07:50,  1.02s/it]
data 89:  12%|█▏        | 60/512 [01:00<07:39,  1.02s/it]
data 89:  14%|█▎        | 70/512 [01:11<07:32,  1.02s/it]
data 89:  16%|█▌        | 80/512 [01:21<07:24,  1.03s/it]
data 89:  18%|█▊        | 90/512 [01:31<07:15,  1.03s/it]
data 89:  20%|█▉        | 100/512 [01:42<07:05,  1.03s/it]
data 89:  21%|██▏       | 110/512 [01:52<06:54,  1.03s/it]
data 89:  23%|██▎       | 120/512 [02:02<06:42,  1.03s/it]
data 89:  25%|██▌       | 130/512 [02:12<06:33,  1.03s/it]
data 89:  27%|██▋       | 140/512 [02:22<06:20,  1.02s/it]
data 89:  27%|██▋       | 140/512 [02:25<06:25,  1.04s/it]
INFO:root:函数头: 
@subscriber(ResourceChanged, for_resources=("account",), for_actions=(ACTIONS.CREATE,))
def on_account_created(event):

INFO:root:目标函数体: 
    request = event.request
    settings = request.registry.settings
    if not settings.get("account_validation", False):
        return

    for impacted_object in event.impacted_objects:
        account = impacted_object["new"]
        user_email = account["id"]
        activation_key = get_cached_validation_key(user_email, request.registry)
        if activation_key is None:
            continue

        # Send an email to the user with the link to activate their account.
        Emailer(request, account).send_activation(activation_key)

INFO:root:生成结果: 
    request = event.request
    settings = request.registry.settings
    # Check if account validation is enabled
    account_validation_enabled = asbool(settings.get("account_validation", False))
    if account_validation_enabled:
        for obj in event.imp impacted_objects:
            # Extract username and password from current user
            username = obj["old"]["id"]
            # Retrieve account information
            account_info = obj["old"]
            # Check if activation key is present
            activation_key = account_info.get("validated")
            if activation_key is None:
                continue
            # Send activation email to user
            emailer = Emailer(request)
            emailer.send_activation(username, activation_key)




INFO:root:----------------------------------------
INFO:root:max length: 5210
INFO:root:max position: 5405
INFO:root:target_namespace: kinto.kinto<folder>.plugins<folder>.accounts<folder>.views<folder>.__init__<file>.on_account_created<func>
INFO:root:****************************************

data 89:   0%|          | 0/512 [00:00<?, ?it/s]
data 89:   2%|▏         | 10/512 [00:09<08:04,  1.04it/s]
data 89:   4%|▍         | 20/512 [00:19<08:05,  1.01it/s]
data 89:   6%|▌         | 30/512 [00:29<08:01,  1.00it/s]
data 89:   8%|▊         | 40/512 [00:40<07:55,  1.01s/it]
data 89:  10%|▉         | 50/512 [00:49<07:42,  1.00s/it]
data 89:  12%|█▏        | 60/512 [00:59<07:33,  1.00s/it]
data 89:  14%|█▎        | 70/512 [01:10<07:25,  1.01s/it]
data 89:  16%|█▌        | 80/512 [01:20<07:15,  1.01s/it]
data 89:  18%|█▊        | 90/512 [01:30<07:06,  1.01s/it]
data 89:  20%|█▉        | 100/512 [01:40<06:57,  1.01s/it]
data 89:  21%|██▏       | 110/512 [01:50<06:47,  1.01s/it]
data 89:  23%|██▎       | 120/512 [02:00<06:36,  1.01s/it]
data 89:  25%|██▌       | 130/512 [02:10<06:26,  1.01s/it]
data 89:  27%|██▋       | 140/512 [02:20<06:15,  1.01s/it]
data 89:  29%|██▉       | 150/512 [02:31<06:06,  1.01s/it]
data 89:  29%|██▉       | 150/512 [02:34<06:11,  1.03s/it]
INFO:root:函数头: 
@subscriber(ResourceChanged, for_resources=("account",), for_actions=(ACTIONS.CREATE,))
def on_account_created(event):

INFO:root:目标函数体: 
    request = event.request
    settings = request.registry.settings
    if not settings.get("account_validation", False):
        return

    for impacted_object in event.impacted_objects:
        account = impacted_object["new"]
        user_email = account["id"]
        activation_key = get_cached_validation_key(user_email, request.registry)
        if activation_key is None:
            continue

        # Send an email to the user with the link to activate their account.
        Emailer(request, account).send_activation(activation_key)

INFO:root:生成结果: 
    request = event.request

    # Check if account validation is enabled in settings
    settings = request.registry.settings
    validation_enabled = settings.get("account_validation", False)

    # If account validation is enabled, send activation email
    if validation_enabled:
        for obj in event.imp impacted_objects:
            # Retrieve account information
            username = obj["old"]["id"]
            email = obj["old"]["email"]
            activation_key = obj["old"]["activation_key"]

            # If activation key is not found, skip to next object
            if activation_key is None:
                continue

            # Send activation email using Emailer class
            emailer = Emailer(request)
            emailer.send_activation(username, email, activation_key)




INFO:root:----------------------------------------
INFO:root:max length: 4920
INFO:root:max position: 5008
INFO:root:target_namespace: kinto.kinto<folder>.plugins<folder>.accounts<folder>.views<folder>.__init__<file>.on_account_created<func>
INFO:root:****************************************

data 89:   0%|          | 0/512 [00:00<?, ?it/s]
data 89:   2%|▏         | 10/512 [00:09<08:04,  1.04it/s]
data 89:   4%|▍         | 20/512 [00:19<08:09,  1.00it/s]
data 89:   6%|▌         | 30/512 [00:29<08:03,  1.00s/it]
data 89:   8%|▊         | 40/512 [00:39<07:52,  1.00s/it]
data 89:  10%|▉         | 50/512 [00:49<07:42,  1.00s/it]
data 89:  12%|█▏        | 60/512 [01:00<07:35,  1.01s/it]
data 89:  14%|█▎        | 70/512 [01:10<07:25,  1.01s/it]
data 89:  16%|█▌        | 80/512 [01:20<07:15,  1.01s/it]
data 89:  16%|█▌        | 80/512 [01:25<07:40,  1.07s/it]
INFO:root:函数头: 
@subscriber(ResourceChanged, for_resources=("account",), for_actions=(ACTIONS.CREATE,))
def on_account_created(event):

INFO:root:目标函数体: 
    request = event.request
    settings = request.registry.settings
    if not settings.get("account_validation", False):
        return

    for impacted_object in event.impacted_objects:
        account = impacted_object["new"]
        user_email = account["id"]
        activation_key = get_cached_validation_key(user_email, request.registry)
        if activation_key is None:
            continue

        # Send an email to the user with the link to activate their account.
        Emailer(request, account).send_activation(activation_key)

INFO:root:生成结果: 
    request = event.request
    settings = request.registry.settings
    if settings.get("account_validation", False):
        for obj in event.imp impacted_objects:
            account = obj["old"]
            username = account["id"]
            activation_key = account.get("validated")
            if activation_key is None:
                continue

            emailer = Emailer(request)
            emailer.send_activation(username, activation_key)




INFO:root:----------------------------------------
INFO:root:max length: 4851
INFO:root:max position: 4940
INFO:root:target_namespace: kinto.kinto<folder>.plugins<folder>.accounts<folder>.views<folder>.__init__<file>.on_account_created<func>
INFO:root:****************************************

data 89:   0%|          | 0/512 [00:00<?, ?it/s]
data 89:   2%|▏         | 10/512 [00:09<08:02,  1.04it/s]
data 89:   4%|▍         | 20/512 [00:19<08:07,  1.01it/s]
data 89:   6%|▌         | 30/512 [05:31<1:58:43, 14.78s/it]
data 89:   8%|▊         | 40/512 [05:42<1:13:42,  9.37s/it]
data 89:  10%|▉         | 50/512 [05:52<49:01,  6.37s/it]  
data 89:  12%|█▏        | 60/512 [06:02<34:15,  4.55s/it]
data 89:  14%|█▎        | 70/512 [06:13<24:58,  3.39s/it]
data 89:  16%|█▌        | 80/512 [06:23<18:59,  2.64s/it]
data 89:  18%|█▊        | 90/512 [06:33<15:02,  2.14s/it]
data 89:  20%|█▉        | 100/512 [06:45<12:37,  1.84s/it]
data 89:  21%|██▏       | 110/512 [06:57<10:56,  1.63s/it]
data 89:  21%|██▏       | 110/512 [07:00<25:36,  3.82s/it]
INFO:root:函数头: 
@subscriber(ResourceChanged, for_resources=("account",), for_actions=(ACTIONS.CREATE,))
def on_account_created(event):

INFO:root:目标函数体: 
    request = event.request
    settings = request.registry.settings
    if not settings.get("account_validation", False):
        return

    for impacted_object in event.impacted_objects:
        account = impacted_object["new"]
        user_email = account["id"]
        activation_key = get_cached_validation_key(user_email, request.registry)
        if activation_key is None:
            continue

        # Send an email to the user with the link to activate their account.
        Emailer(request, account).send_activation(activation_key)

INFO:root:生成结果: 
    request = event.request
    settings = request.registry.settings

    # Check if account validation is enabled
    if settings.get("account_validation", False):
        for obj in event.imp impacted_objects:
            # Get account information
            account = obj["old"]
            user_email = account.get("id")
            activation_key = account.get("activation_key")

            # Skip if activation key is None
            if activation_key is None:
                continue

            # Send activation email
            Emailer(request).send_activation(user_email, activation_key)




INFO:root:----------------------------------------
INFO:root:max length: 4888
INFO:root:max position: 4968
INFO:root:target_namespace: kinto.kinto<folder>.plugins<folder>.accounts<folder>.views<folder>.__init__<file>.on_account_created<func>
INFO:root:****************************************
INFO:root:--------data 90--------

data 90:   0%|          | 0/512 [00:00<?, ?it/s]
data 90:   2%|▏         | 10/512 [00:08<07:25,  1.13it/s]
data 90:   4%|▍         | 20/512 [00:17<06:56,  1.18it/s]
data 90:   6%|▌         | 30/512 [01:25<28:51,  3.59s/it]
data 90:   6%|▌         | 30/512 [01:30<24:13,  3.02s/it]
INFO:root:函数头: 
def hash_password(password):
    # Store password safely in database as str
    # (bcrypt.hashpw returns base64 bytes).

INFO:root:目标函数体: 
    pwd_str = password.encode(encoding="utf-8")
    hashed = bcrypt.hashpw(pwd_str, bcrypt.gensalt())
    return hashed.decode(encoding="utf-8")

INFO:root:生成结果: 
    salt = bcrypt.ggen_salt()
    hashed_password = bcrypt.hashpw(password.encode("utf-8"), salt)
    return hashed_password.decode("utf-8")




INFO:root:----------------------------------------
INFO:root:max length: 3543
INFO:root:max position: 3543
INFO:root:target_namespace: kinto.kinto<folder>.plugins<folder>.accounts<folder>.utils<file>.hash_password<func>
INFO:root:****************************************

data 90:   0%|          | 0/512 [00:00<?, ?it/s]
data 90:   2%|▏         | 10/512 [00:07<06:06,  1.37it/s]
data 90:   4%|▍         | 20/512 [00:15<06:20,  1.29it/s]
data 90:   6%|▌         | 30/512 [00:23<06:23,  1.26it/s]
data 90:   6%|▌         | 30/512 [00:28<07:34,  1.06it/s]
INFO:root:函数头: 
def hash_password(password):
    # Store password safely in database as str
    # (bcrypt.hashpw returns base64 bytes).

INFO:root:目标函数体: 
    pwd_str = password.encode(encoding="utf-8")
    hashed = bcrypt.hashpw(pwd_str, bcrypt.gensalt())
    return hashed.decode(encoding="utf-8")

INFO:root:生成结果: 
    salt = bcrypt.g gen_salt()
    hashed_password = bcrypt.hashpw(password.encode("utf-8"), salt)
    return hashed_password.decode("utf-8")




INFO:root:----------------------------------------
INFO:root:max length: 3543
INFO:root:max position: 3543
INFO:root:target_namespace: kinto.kinto<folder>.plugins<folder>.accounts<folder>.utils<file>.hash_password<func>
INFO:root:****************************************

data 90:   0%|          | 0/512 [00:00<?, ?it/s]
data 90:   2%|▏         | 10/512 [00:07<05:56,  1.41it/s]
data 90:   4%|▍         | 20/512 [00:15<06:16,  1.31it/s]
data 90:   6%|▌         | 30/512 [00:22<06:12,  1.29it/s]
data 90:   6%|▌         | 30/512 [00:27<07:28,  1.08it/s]
INFO:root:函数头: 
def hash_password(password):
    # Store password safely in database as str
    # (bcrypt.hashpw returns base64 bytes).

INFO:root:目标函数体: 
    pwd_str = password.encode(encoding="utf-8")
    hashed = bcrypt.hashpw(pwd_str, bcrypt.gensalt())
    return hashed.decode(encoding="utf-8")

INFO:root:生成结果: 
    salt = bcrypt.ggen_salt()
    hashed_password = bcrypt.hashpw(password.encode("utf-8"), salt)
    return hashed_password.decode("utf-8")




INFO:root:----------------------------------------
INFO:root:max length: 3543
INFO:root:max position: 3543
INFO:root:target_namespace: kinto.kinto<folder>.plugins<folder>.accounts<folder>.utils<file>.hash_password<func>
INFO:root:****************************************

data 90:   0%|          | 0/512 [00:00<?, ?it/s]
data 90:   2%|▏         | 10/512 [00:07<06:00,  1.39it/s]
data 90:   4%|▍         | 20/512 [00:15<06:14,  1.31it/s]
data 90:   6%|▌         | 30/512 [00:23<06:17,  1.28it/s]
data 90:   6%|▌         | 30/512 [00:27<07:29,  1.07it/s]
INFO:root:函数头: 
def hash_password(password):
    # Store password safely in database as str
    # (bcrypt.hashpw returns base64 bytes).

INFO:root:目标函数体: 
    pwd_str = password.encode(encoding="utf-8")
    hashed = bcrypt.hashpw(pwd_str, bcrypt.gensalt())
    return hashed.decode(encoding="utf-8")

INFO:root:生成结果: 
    salt = bcrypt.g gen_salt()
    hashed_password = bcrypt.hashpw(password.encode('utf-8'), salt)
    return hashed_password.decode('utf-8')




INFO:root:----------------------------------------
INFO:root:max length: 3543
INFO:root:max position: 3543
INFO:root:target_namespace: kinto.kinto<folder>.plugins<folder>.accounts<folder>.utils<file>.hash_password<func>
INFO:root:****************************************

data 90:   0%|          | 0/512 [00:00<?, ?it/s]
data 90:   2%|▏         | 10/512 [00:07<06:13,  1.35it/s]
data 90:   4%|▍         | 20/512 [00:15<06:17,  1.30it/s]
data 90:   6%|▌         | 30/512 [00:23<06:15,  1.28it/s]
data 90:   6%|▌         | 30/512 [00:27<07:29,  1.07it/s]
INFO:root:函数头: 
def hash_password(password):
    # Store password safely in database as str
    # (bcrypt.hashpw returns base64 bytes).

INFO:root:目标函数体: 
    pwd_str = password.encode(encoding="utf-8")
    hashed = bcrypt.hashpw(pwd_str, bcrypt.gensalt())
    return hashed.decode(encoding="utf-8")

INFO:root:生成结果: 
    salt = bcrypt.g gen_salt()
    hashed_password = bcrypt.hashpw(password.encode('utf-8'), salt)
    return hashed_password.decode('utf-8')




INFO:root:----------------------------------------
INFO:root:max length: 3543
INFO:root:max position: 3543
INFO:root:target_namespace: kinto.kinto<folder>.plugins<folder>.accounts<folder>.utils<file>.hash_password<func>
INFO:root:****************************************
INFO:root:--------data 91--------

data 91:   0%|          | 0/512 [00:00<?, ?it/s]
data 91:   2%|▏         | 10/512 [00:09<07:53,  1.06it/s]
data 91:   4%|▍         | 20/512 [00:18<07:21,  1.11it/s]
data 91:   6%|▌         | 30/512 [00:26<07:01,  1.14it/s]
data 91:   8%|▊         | 40/512 [00:35<06:47,  1.16it/s]
data 91:  10%|▉         | 50/512 [00:43<06:38,  1.16it/s]
data 91:  12%|█▏        | 60/512 [00:52<06:27,  1.17it/s]
data 91:  12%|█▏        | 60/512 [00:57<07:10,  1.05it/s]
INFO:root:函数头: 
def get_parent_uri(object_uri):

INFO:root:目标函数体: 
    
    path = object_uri.rsplit("/", 2)
    # len(path) == 1: no '/', probably a broken URL?
    # len(path) == 2: one '/', doesn't conform to our URL scheme
    if len(path) < 3:
        return ""

    return path[0]

INFO:root:生成结果: 
    try:
        parts = object_uri.split("/")
        if len(parts) < 3:
            return ""
        parent_uri = parts[0] + "/" + parts[1]
        return parent_uri
    except Exception as e:
        print(f"Error retrieving parent URI: {e}")
        return ""




INFO:root:----------------------------------------
INFO:root:max length: 3748
INFO:root:max position: 3748
INFO:root:target_namespace: kinto.kinto<folder>.views<folder>.admin<file>.get_parent_uri<func>
INFO:root:****************************************

data 91:   0%|          | 0/512 [00:00<?, ?it/s]
data 91:   2%|▏         | 10/512 [00:07<06:30,  1.29it/s]
data 91:   4%|▍         | 20/512 [00:16<06:40,  1.23it/s]
data 91:   6%|▌         | 30/512 [00:24<06:44,  1.19it/s]
data 91:   8%|▊         | 40/512 [00:33<06:39,  1.18it/s]
data 91:   8%|▊         | 40/512 [00:41<08:06,  1.03s/it]
INFO:root:函数头: 
def get_parent_uri(object_uri):

INFO:root:目标函数体: 
    
    path = object_uri.rsplit("/", 2)
    # len(path) == 1: no '/', probably a broken URL?
    # len(path) == 2: one '/', doesn't conform to our URL scheme
    if len(path) < 3:
        return ""

    return path[0]

INFO:root:生成结果: 
    if object_uri.startswith("http"):
        parts = object_uri.split("/")
        if len(parts) < 3:
            return ""
        return parts[0] + "/" + parts[1]
    else:
        return ""




INFO:root:----------------------------------------
INFO:root:max length: 3731
INFO:root:max position: 3731
INFO:root:target_namespace: kinto.kinto<folder>.views<folder>.admin<file>.get_parent_uri<func>
INFO:root:****************************************

data 91:   0%|          | 0/512 [00:00<?, ?it/s]
data 91:   2%|▏         | 10/512 [00:07<06:32,  1.28it/s]
data 91:   4%|▍         | 20/512 [00:16<06:36,  1.24it/s]
data 91:   6%|▌         | 30/512 [00:24<06:36,  1.22it/s]
data 91:   8%|▊         | 40/512 [00:32<06:29,  1.21it/s]
data 91:   8%|▊         | 40/512 [00:39<07:46,  1.01it/s]
INFO:root:函数头: 
def get_parent_uri(object_uri):

INFO:root:目标函数体: 
    
    path = object_uri.rsplit("/", 2)
    # len(path) == 1: no '/', probably a broken URL?
    # len(path) == 2: one '/', doesn't conform to our URL scheme
    if len(path) < 3:
        return ""

    return path[0]

INFO:root:生成结果: 
    if object_uri.startswith("http"):
        parts = object_uri.split("/")
        if len(parts) < 3:
            return ""
        return parts[0] + "/" + parts[1]
    else:
        return ""



INFO:root:----------------------------------------
INFO:root:max length: 3730
INFO:root:max position: 3730
INFO:root:target_namespace: kinto.kinto<folder>.views<folder>.admin<file>.get_parent_uri<func>
INFO:root:****************************************

data 91:   0%|          | 0/512 [00:00<?, ?it/s]
data 91:   2%|▏         | 10/512 [00:07<06:25,  1.30it/s]
data 91:   4%|▍         | 20/512 [00:15<06:33,  1.25it/s]
data 91:   6%|▌         | 30/512 [00:24<06:29,  1.24it/s]
data 91:   8%|▊         | 40/512 [00:32<06:30,  1.21it/s]
data 91:  10%|▉         | 50/512 [00:41<06:23,  1.20it/s]
data 91:  12%|█▏        | 60/512 [00:49<06:16,  1.20it/s]
data 91:  12%|█▏        | 60/512 [00:50<06:18,  1.19it/s]
INFO:root:函数头: 
def get_parent_uri(object_uri):

INFO:root:目标函数体: 
    
    path = object_uri.rsplit("/", 2)
    # len(path) == 1: no '/', probably a broken URL?
    # len(path) == 2: one '/', doesn't conform to our URL scheme
    if len(path) < 3:
        return ""

    return path[0]

INFO:root:生成结果: 
    try:
        path = object_uri.split("/")
        if len(path) < 3:
            return ""
        return path[0] + "/" + path[1]
    except Exception as e:
        print(f"Error occurred while getting parent URI: {e}")
        return ""




INFO:root:----------------------------------------
INFO:root:max length: 3743
INFO:root:max position: 3743
INFO:root:target_namespace: kinto.kinto<folder>.views<folder>.admin<file>.get_parent_uri<func>
INFO:root:****************************************

data 91:   0%|          | 0/512 [00:00<?, ?it/s]
data 91:   2%|▏         | 10/512 [00:07<06:17,  1.33it/s]
data 91:   4%|▍         | 20/512 [00:15<06:33,  1.25it/s]
data 91:   6%|▌         | 30/512 [00:24<06:29,  1.24it/s]
data 91:   8%|▊         | 40/512 [00:32<06:25,  1.22it/s]
data 91:  10%|▉         | 50/512 [00:40<06:20,  1.21it/s]
data 91:  12%|█▏        | 60/512 [00:49<06:14,  1.21it/s]
data 91:  14%|█▎        | 70/512 [00:57<06:08,  1.20it/s]
data 91:  16%|█▌        | 80/512 [01:05<05:58,  1.21it/s]
data 91:  16%|█▌        | 80/512 [01:06<05:58,  1.20it/s]
INFO:root:函数头: 
def get_parent_uri(object_uri):

INFO:root:目标函数体: 
    
    path = object_uri.rsplit("/", 2)
    # len(path) == 1: no '/', probably a broken URL?
    # len(path) == 2: one '/', doesn't conform to our URL scheme
    if len(path) < 3:
        return ""

    return path[0]

INFO:root:生成结果: 
    if object_uri.startswith("http"):
        parts = object_uri.split("/")
        if len(parts) < 3:
            return ""
        return parts[0] + "/" + parts[1] + "/"
    else:
        parts = object_uri.split("/")
        if len(parts) < 3:
            return ""
        return parts[0] + "/" + parts[1] + "/"


INFO:root:----------------------------------------
INFO:root:max length: 3763
INFO:root:max position: 3763
INFO:root:target_namespace: kinto.kinto<folder>.views<folder>.admin<file>.get_parent_uri<func>
INFO:root:****************************************
INFO:root:--------data 92--------

data 92:   0%|          | 0/512 [00:00<?, ?it/s]
data 92:   2%|▏         | 10/512 [00:12<10:12,  1.22s/it]
data 92:   4%|▍         | 20/512 [00:22<09:11,  1.12s/it]
data 92:   4%|▍         | 20/512 [00:26<10:40,  1.30s/it]
INFO:root:函数头: 
def register(name: str) -> Callable:

INFO:root:目标函数体: 
    

    def decorate(fn):
        # Omit body code

    return decorate

INFO:root:生成结果: 
    def decorator(func):
        _registry[name] = func
        return func

    return decorator




INFO:root:----------------------------------------
INFO:root:max length: 2098
INFO:root:max position: 2098
INFO:root:target_namespace: alembic.alembic<folder>.script<folder>.write_hooks<file>.register<func>
INFO:root:****************************************

data 92:   0%|          | 0/512 [00:00<?, ?it/s]
data 92:   2%|▏         | 10/512 [00:09<08:02,  1.04it/s]
data 92:   4%|▍         | 20/512 [00:19<08:14,  1.00s/it]
data 92:   4%|▍         | 20/512 [00:28<11:44,  1.43s/it]
INFO:root:函数头: 
def register(name: str) -> Callable:

INFO:root:目标函数体: 
    

    def decorate(fn):
        # Omit body code

    return decorate

INFO:root:生成结果: 
    def decorator(func: Callable) -> Callable:
        _registry[name] = func
        return func

    return decorator




INFO:root:----------------------------------------
INFO:root:max length: 2104
INFO:root:max position: 2104
INFO:root:target_namespace: alembic.alembic<folder>.script<folder>.write_hooks<file>.register<func>
INFO:root:****************************************

data 92:   0%|          | 0/512 [00:00<?, ?it/s]
data 92:   2%|▏         | 10/512 [01:09<58:32,  7.00s/it]
data 92:   4%|▍         | 20/512 [01:21<29:03,  3.54s/it]
data 92:   4%|▍         | 20/512 [01:24<34:36,  4.22s/it]
INFO:root:函数头: 
def register(name: str) -> Callable:

INFO:root:目标函数体: 
    

    def decorate(fn):
        # Omit body code

    return decorate

INFO:root:生成结果: 
    def decorator(func):
        _registry[name] = func
        return func

    return decorator




INFO:root:----------------------------------------
INFO:root:max length: 2098
INFO:root:max position: 2098
INFO:root:target_namespace: alembic.alembic<folder>.script<folder>.write_hooks<file>.register<func>
INFO:root:****************************************

data 92:   0%|          | 0/512 [00:00<?, ?it/s]
data 92:   2%|▏         | 10/512 [00:09<08:18,  1.01it/s]
data 92:   4%|▍         | 20/512 [00:20<08:33,  1.04s/it]
data 92:   4%|▍         | 20/512 [00:29<12:01,  1.47s/it]
INFO:root:函数头: 
def register(name: str) -> Callable:

INFO:root:目标函数体: 
    

    def decorate(fn):
        # Omit body code

    return decorate

INFO:root:生成结果: 
    def decorator(func: Callable) -> Callable:
        _registry[name] = func
        return func

    return decorator




INFO:root:----------------------------------------
INFO:root:max length: 2104
INFO:root:max position: 2104
INFO:root:target_namespace: alembic.alembic<folder>.script<folder>.write_hooks<file>.register<func>
INFO:root:****************************************

data 92:   0%|          | 0/512 [00:00<?, ?it/s]
data 92:   2%|▏         | 10/512 [00:09<08:14,  1.02it/s]
data 92:   4%|▍         | 20/512 [00:20<08:14,  1.00s/it]
data 92:   4%|▍         | 20/512 [00:28<11:50,  1.44s/it]
INFO:root:函数头: 
def register(name: str) -> Callable:

INFO:root:目标函数体: 
    

    def decorate(fn):
        # Omit body code

    return decorate

INFO:root:生成结果: 
    def decorator(func: Callable) -> Callable:
        _registry[name] = func
        return func

    return decorator




INFO:root:----------------------------------------
INFO:root:max length: 2104
INFO:root:max position: 2104
INFO:root:target_namespace: alembic.alembic<folder>.script<folder>.write_hooks<file>.register<func>
INFO:root:****************************************
INFO:root:--------data 93--------

data 93:   0%|          | 0/512 [00:00<?, ?it/s]
data 93:   2%|▏         | 10/512 [00:57<48:30,  5.80s/it]
data 93:   4%|▍         | 20/512 [02:03<51:11,  6.24s/it]
data 93:   6%|▌         | 30/512 [03:06<50:13,  6.25s/it]
data 93:   6%|▌         | 30/512 [03:17<52:51,  6.58s/it]
INFO:root:函数头: 
def match_replace_regex(regex, src_namespace, dest_namespace):

INFO:root:目标函数体: 
    
    match = regex.match(src_namespace)
    if match:
        return dest_namespace.replace("*", match.group(1))
    return None

INFO:root:生成结果: 
    match_obj = re.match(regex, src_namespace)
    if match_obj:
        return dest_namespace.format(*match_obj.groups())
    return None




INFO:root:----------------------------------------
INFO:root:max length: 8095
INFO:root:max position: 11242
INFO:root:target_namespace: mongo-doc-manager.mongo_connector<folder>.namespace_config<file>.match_replace_regex<func>
INFO:root:****************************************

data 93:   0%|          | 0/512 [00:00<?, ?it/s]
data 93:   2%|▏         | 10/512 [00:55<46:14,  5.53s/it]
data 93:   4%|▍         | 20/512 [02:58<1:17:55,  9.50s/it]
data 93:   4%|▍         | 20/512 [03:56<1:37:07, 11.84s/it]
INFO:root:函数头: 
def match_replace_regex(regex, src_namespace, dest_namespace):

INFO:root:目标函数体: 
    
    match = regex.match(src_namespace)
    if match:
        return dest_namespace.replace("*", match.group(1))
    return None

INFO:root:生成结果: 
    match_obj = regex.match(src_namespace)
    if match_obj:
        return dest_namespace.format(*match_obj.groups())
    return None


INFO:root:----------------------------------------
INFO:root:max length: 7761
INFO:root:max position: 10887
INFO:root:target_namespace: mongo-doc-manager.mongo_connector<folder>.namespace_config<file>.match_replace_regex<func>
INFO:root:****************************************

data 93:   0%|          | 0/512 [00:00<?, ?it/s]
data 93:   2%|▏         | 10/512 [00:55<46:34,  5.57s/it]
data 93:   4%|▍         | 20/512 [03:58<1:46:51, 13.03s/it]
data 93:   4%|▍         | 20/512 [05:01<2:03:30, 15.06s/it]
INFO:root:函数头: 
def match_replace_regex(regex, src_namespace, dest_namespace):

INFO:root:目标函数体: 
    
    match = regex.match(src_namespace)
    if match:
        return dest_namespace.replace("*", match.group(1))
    return None

INFO:root:生成结果: 
    match_obj = regex.match(src_namespace)
    if match_obj:
        return dest_namespace.format(*match_obj.groups())
    return None


INFO:root:----------------------------------------
INFO:root:max length: 8081
INFO:root:max position: 11664
INFO:root:target_namespace: mongo-doc-manager.mongo_connector<folder>.namespace_config<file>.match_replace_regex<func>
INFO:root:****************************************

data 93:   0%|          | 0/512 [00:00<?, ?it/s]
data 93:   2%|▏         | 10/512 [00:57<47:57,  5.73s/it]
data 93:   4%|▍         | 20/512 [02:01<50:08,  6.12s/it]
data 93:   6%|▌         | 30/512 [03:04<50:06,  6.24s/it]
data 93:   8%|▊         | 40/512 [04:07<49:09,  6.25s/it]
data 93:  10%|▉         | 50/512 [05:09<48:03,  6.24s/it]
data 93:  10%|▉         | 50/512 [05:16<48:41,  6.32s/it]
INFO:root:函数头: 
def match_replace_regex(regex, src_namespace, dest_namespace):

INFO:root:目标函数体: 
    
    match = regex.match(src_namespace)
    if match:
        return dest_namespace.replace("*", match.group(1))
    return None

INFO:root:生成结果: 
    match_obj = regex.match(src_namespace)
    if match_obj:
        # Replace '*' with the corresponding group from the match
        dest_namespace = dest_namespace.replace('*', match_obj.group(1))
        return dest_namespace
    return None


INFO:root:----------------------------------------
INFO:root:max length: 8750
INFO:root:max position: 11937
INFO:root:target_namespace: mongo-doc-manager.mongo_connector<folder>.namespace_config<file>.match_replace_regex<func>
INFO:root:****************************************

data 93:   0%|          | 0/512 [00:00<?, ?it/s]
data 93:   2%|▏         | 10/512 [00:55<46:07,  5.51s/it]
data 93:   4%|▍         | 20/512 [02:59<1:18:43,  9.60s/it]
data 93:   6%|▌         | 30/512 [04:02<1:05:02,  8.10s/it]
data 93:   6%|▌         | 30/512 [04:39<1:14:53,  9.32s/it]
INFO:root:函数头: 
def match_replace_regex(regex, src_namespace, dest_namespace):

INFO:root:目标函数体: 
    
    match = regex.match(src_namespace)
    if match:
        return dest_namespace.replace("*", match.group(1))
    return None

INFO:root:生成结果: 
    import re
    match_obj = re.match(regex, src_namespace)
    if match_obj:
        return dest_namespace.format(*match_obj.groups())
    return None


INFO:root:----------------------------------------
INFO:root:max length: 8180
INFO:root:max position: 11488
INFO:root:target_namespace: mongo-doc-manager.mongo_connector<folder>.namespace_config<file>.match_replace_regex<func>
INFO:root:****************************************
INFO:root:--------data 94--------

data 94:   0%|          | 0/512 [00:00<?, ?it/s]
data 94:   2%|▏         | 10/512 [00:59<50:09,  5.99s/it]
data 94:   4%|▍         | 20/512 [02:08<53:12,  6.49s/it]
data 94:   6%|▌         | 30/512 [04:14<1:14:36,  9.29s/it]
data 94:   8%|▊         | 40/512 [05:21<1:05:02,  8.27s/it]
data 94:  10%|▉         | 50/512 [06:24<58:13,  7.56s/it]  
data 94:  12%|█▏        | 60/512 [07:28<54:02,  7.17s/it]
data 94:  14%|█▎        | 70/512 [08:32<51:01,  6.93s/it]
data 94:  16%|█▌        | 80/512 [09:38<49:00,  6.81s/it]
data 94:  18%|█▊        | 90/512 [13:47<1:27:42, 12.47s/it]
data 94:  20%|█▉        | 100/512 [14:57<1:13:59, 10.77s/it]
data 94:  20%|█▉        | 100/512 [15:26<1:03:38,  9.27s/it]
INFO:root:函数头: 
def namespace_to_regex(namespace):

INFO:root:目标函数体: 
    
    db_name, coll_name = namespace.split(".", 1)
    # A database name cannot contain a '.' character
    db_regex = re.escape(db_name).replace(r"\*", "([^.]*)")
    # But a collection name can.
    coll_regex = re.escape(coll_name).replace(r"\*", "(.*)")
    return re.compile(r"\A" + db_regex + r"\." + coll_regex + r"\Z")

INFO:root:生成结果: 
    parts = namespace.split("/")
    db_pattern = ""
    collection_pattern = ""
    for part in parts:
        if db_pattern:
            db_pattern += "/"
        db_pattern += "(?:.*\\.)?" + part.replace "*", "(.*)"
        if collection_pattern:
            collection_pattern += "/"
        collection_pattern += "(?:.*\\.)?" + part.replace "*", "(.*)"
    db_regex = re.compile(db_pattern)
    collection_regex = re.compile(collection_pattern)
    return db_regex, collection_regex




INFO:root:----------------------------------------
INFO:root:max length: 8448
INFO:root:max position: 11546
INFO:root:target_namespace: mongo-doc-manager.mongo_connector<folder>.namespace_config<file>.namespace_to_regex<func>
INFO:root:****************************************

data 94:   0%|          | 0/512 [00:00<?, ?it/s]
data 94:   2%|▏         | 10/512 [00:59<50:04,  5.98s/it]
data 94:   4%|▍         | 20/512 [02:09<53:53,  6.57s/it]
data 94:   6%|▌         | 30/512 [03:18<53:56,  6.72s/it]
data 94:   8%|▊         | 40/512 [04:27<53:15,  6.77s/it]
data 94:  10%|▉         | 50/512 [05:35<52:20,  6.80s/it]
data 94:  10%|▉         | 50/512 [05:43<52:51,  6.86s/it]
INFO:root:函数头: 
def namespace_to_regex(namespace):

INFO:root:目标函数体: 
    
    db_name, coll_name = namespace.split(".", 1)
    # A database name cannot contain a '.' character
    db_regex = re.escape(db_name).replace(r"\*", "([^.]*)")
    # But a collection name can.
    coll_regex = re.escape(coll_name).replace(r"\*", "(.*)")
    return re.compile(r"\A" + db_regex + r"\." + coll_regex + r"\Z")

INFO:root:生成结果: 
    db, collection = namespace.split(".", 1)
    db_regex = re.compile(db)
    collection_regex = re.compile(collection)
    return re.compile(r"^" + db_regex.pattern + r"\." + collection_regex.pattern + "$")




INFO:root:----------------------------------------
INFO:root:max length: 7604
INFO:root:max position: 11091
INFO:root:target_namespace: mongo-doc-manager.mongo_connector<folder>.namespace_config<file>.namespace_to_regex<func>
INFO:root:****************************************

data 94:   0%|          | 0/512 [00:00<?, ?it/s]
data 94:   2%|▏         | 10/512 [01:02<52:38,  6.29s/it]
data 94:   4%|▍         | 20/512 [02:15<56:28,  6.89s/it]
data 94:   6%|▌         | 30/512 [03:26<56:04,  6.98s/it]
data 94:   8%|▊         | 40/512 [04:38<55:35,  7.07s/it]
data 94:   8%|▊         | 40/512 [04:58<58:42,  7.46s/it]
INFO:root:函数头: 
def namespace_to_regex(namespace):

INFO:root:目标函数体: 
    
    db_name, coll_name = namespace.split(".", 1)
    # A database name cannot contain a '.' character
    db_regex = re.escape(db_name).replace(r"\*", "([^.]*)")
    # But a collection name can.
    coll_regex = re.escape(coll_name).replace(r"\*", "(.*)")
    return re.compile(r"\A" + db_regex + r"\." + coll_regex + r"\Z")

INFO:root:生成结果: 
    db, collection = namespace.split(".", 1)
    db_regex = re.compile(db)
    collection_regex = re.compile(collection)
    return re.compile(f"{db_regex.pattern}.{collection_regex.pattern}")


INFO:root:----------------------------------------
INFO:root:max length: 7473
INFO:root:max position: 11015
INFO:root:target_namespace: mongo-doc-manager.mongo_connector<folder>.namespace_config<file>.namespace_to_regex<func>
INFO:root:****************************************

data 94:   0%|          | 0/512 [00:00<?, ?it/s]
data 94:   2%|▏         | 10/512 [01:00<50:59,  6.10s/it]
data 94:   4%|▍         | 20/512 [02:10<53:53,  6.57s/it]
data 94:   6%|▌         | 30/512 [03:21<54:51,  6.83s/it]
data 94:   8%|▊         | 40/512 [04:30<54:07,  6.88s/it]
data 94:  10%|▉         | 50/512 [08:41<1:43:21, 13.42s/it]
data 94:  12%|█▏        | 60/512 [09:51<1:24:39, 11.24s/it]
data 94:  14%|█▎        | 70/512 [14:02<1:56:14, 15.78s/it]
data 94:  16%|█▌        | 80/512 [15:13<1:33:39, 13.01s/it]
data 94:  18%|█▊        | 90/512 [16:25<1:18:42, 11.19s/it]
data 94:  20%|█▉        | 100/512 [17:38<1:08:41, 10.00s/it]
data 94:  21%|██▏       | 110/512 [18:51<1:01:26,  9.17s/it]
data 94:  21%|██▏       | 110/512 [19:12<1:10:12, 10.48s/it]
INFO:root:函数头: 
def namespace_to_regex(namespace):

INFO:root:目标函数体: 
    
    db_name, coll_name = namespace.split(".", 1)
    # A database name cannot contain a '.' character
    db_regex = re.escape(db_name).replace(r"\*", "([^.]*)")
    # But a collection name can.
    coll_regex = re.escape(coll_name).replace(r"\*", "(.*)")
    return re.compile(r"\A" + db_regex + r"\." + coll_regex + r"\Z")

INFO:root:生成结果: 
    parts = namespace.split(".")
    db_regex = ""
    collection_regex = ""
    for i, part in enumerate(parts):
        if wildcard_pattern_match(part):
            db_regex += "(?:.*\\.)?"
            collection_regex += "(?:.*\\.)?"
        else:
            db_regex += "(?:.*\\.)?" + re.escape(part)
            collection_regex += "(?:.*\\.)?" + re.escape(part)
    db_regex += "$"
    collection_regex += "$"
    return re.compile(db_regex + "\\." + collection_regex)




INFO:root:----------------------------------------
INFO:root:max length: 8420
INFO:root:max position: 12201
INFO:root:target_namespace: mongo-doc-manager.mongo_connector<folder>.namespace_config<file>.namespace_to_regex<func>
INFO:root:****************************************

data 94:   0%|          | 0/512 [00:00<?, ?it/s]
data 94:   2%|▏         | 10/512 [02:03<1:43:07, 12.33s/it]
data 94:   4%|▍         | 20/512 [03:11<1:14:23,  9.07s/it]
data 94:   6%|▌         | 30/512 [04:23<1:06:05,  8.23s/it]
data 94:   8%|▊         | 40/512 [05:35<1:01:37,  7.83s/it]
data 94:  10%|▉         | 50/512 [06:45<57:50,  7.51s/it]  
data 94:  10%|▉         | 50/512 [07:19<1:07:45,  8.80s/it]
INFO:root:函数头: 
def namespace_to_regex(namespace):

INFO:root:目标函数体: 
    
    db_name, coll_name = namespace.split(".", 1)
    # A database name cannot contain a '.' character
    db_regex = re.escape(db_name).replace(r"\*", "([^.]*)")
    # But a collection name can.
    coll_regex = re.escape(coll_name).replace(r"\*", "(.*)")
    return re.compile(r"\A" + db_regex + r"\." + coll_regex + r"\Z")

INFO:root:生成结果: 
    db, collection = namespace.split(".", 1)
    db_regex = re.compile("^" + db + "$")
    collection_regex = re.compile("^" + collection + "$")
    return re.compile(db_regex.pattern + ".*" + collection_regex.pattern)




INFO:root:----------------------------------------
INFO:root:max length: 8484
INFO:root:max position: 11503
INFO:root:target_namespace: mongo-doc-manager.mongo_connector<folder>.namespace_config<file>.namespace_to_regex<func>
INFO:root:****************************************
INFO:root:--------data 95--------

data 95:   0%|          | 0/512 [00:00<?, ?it/s]
data 95:   2%|▏         | 10/512 [00:52<43:53,  5.25s/it]
data 95:   2%|▏         | 10/512 [01:08<57:36,  6.89s/it]
INFO:root:函数头: 
def long_to_bson_ts(val):

INFO:root:目标函数体: 
    
    seconds = val >> 32
    increment = val & 0xFFFFFFFF

    return Timestamp(seconds, increment)

INFO:root:生成结果: 
    # Implement the conversion logic here
    pass




INFO:root:----------------------------------------
INFO:root:max length: 6980
INFO:root:max position: 8555
INFO:root:target_namespace: mongo-doc-manager.mongo_connector<folder>.util<file>.long_to_bson_ts<func>
INFO:root:****************************************

data 95:   0%|          | 0/512 [00:00<?, ?it/s]
data 95:   2%|▏         | 10/512 [00:50<41:59,  5.02s/it]
data 95:   2%|▏         | 10/512 [01:31<1:16:13,  9.11s/it]
INFO:root:函数头: 
def long_to_bson_ts(val):

INFO:root:目标函数体: 
    
    seconds = val >> 32
    increment = val & 0xFFFFFFFF

    return Timestamp(seconds, increment)

INFO:root:生成结果: 
    return Timestamp(val >> 32, val & 0xFFFFFFFF)




INFO:root:----------------------------------------
INFO:root:max length: 6688
INFO:root:max position: 8817
INFO:root:target_namespace: mongo-doc-manager.mongo_connector<folder>.util<file>.long_to_bson_ts<func>
INFO:root:****************************************

data 95:   0%|          | 0/512 [00:00<?, ?it/s]
data 95:   2%|▏         | 10/512 [00:49<41:34,  4.97s/it]
data 95:   4%|▍         | 20/512 [01:46<44:24,  5.42s/it]
data 95:   4%|▍         | 20/512 [02:35<1:03:41,  7.77s/it]
INFO:root:函数头: 
def long_to_bson_ts(val):

INFO:root:目标函数体: 
    
    seconds = val >> 32
    increment = val & 0xFFFFFFFF

    return Timestamp(seconds, increment)

INFO:root:生成结果: 
    timestamp = Timestamp(val >> 32, val & ((1 << 32) - 1))
    return timestamp




INFO:root:----------------------------------------
INFO:root:max length: 7050
INFO:root:max position: 9544
INFO:root:target_namespace: mongo-doc-manager.mongo_connector<folder>.util<file>.long_to_bson_ts<func>
INFO:root:****************************************

data 95:   0%|          | 0/512 [00:00<?, ?it/s]
data 95:   2%|▏         | 10/512 [00:48<40:36,  4.85s/it]
data 95:   4%|▍         | 20/512 [01:44<43:32,  5.31s/it]
data 95:   4%|▍         | 20/512 [01:54<47:06,  5.74s/it]
INFO:root:函数头: 
def long_to_bson_ts(val):

INFO:root:目标函数体: 
    
    seconds = val >> 32
    increment = val & 0xFFFFFFFF

    return Timestamp(seconds, increment)

INFO:root:生成结果: 
    timestamp = Timestamp(val >> 32, val & 0xFFFFFFFF)
    return timestamp




INFO:root:----------------------------------------
INFO:root:max length: 7053
INFO:root:max position: 9020
INFO:root:target_namespace: mongo-doc-manager.mongo_connector<folder>.util<file>.long_to_bson_ts<func>
INFO:root:****************************************

data 95:   0%|          | 0/512 [00:00<?, ?it/s]
data 95:   2%|▏         | 10/512 [00:48<40:20,  4.82s/it]
data 95:   4%|▍         | 20/512 [01:44<43:39,  5.32s/it]
data 95:   6%|▌         | 30/512 [02:41<44:09,  5.50s/it]
data 95:   6%|▌         | 30/512 [03:25<55:05,  6.86s/it]
INFO:root:函数头: 
def long_to_bson_ts(val):

INFO:root:目标函数体: 
    
    seconds = val >> 32
    increment = val & 0xFFFFFFFF

    return Timestamp(seconds, increment)

INFO:root:生成结果: 
    time_part = val >> 32
    inc_part = val & ((1 << 32) - 1)
    return Timestamp(time_part, inc_part)




INFO:root:----------------------------------------
INFO:root:max length: 6830
INFO:root:max position: 9191
INFO:root:target_namespace: mongo-doc-manager.mongo_connector<folder>.util<file>.long_to_bson_ts<func>
INFO:root:****************************************
INFO:root:已生成95条结果
INFO:root:--------data 96--------

data 96:   0%|          | 0/512 [00:00<?, ?it/s]
data 96:   2%|▏         | 10/512 [00:11<09:23,  1.12s/it]
data 96:   4%|▍         | 20/512 [00:21<08:46,  1.07s/it]
data 96:   6%|▌         | 30/512 [00:31<08:19,  1.04s/it]
data 96:   8%|▊         | 40/512 [00:41<08:11,  1.04s/it]
data 96:  10%|▉         | 50/512 [00:52<07:59,  1.04s/it]
data 96:  12%|█▏        | 60/512 [01:03<08:00,  1.06s/it]
data 96:  14%|█▎        | 70/512 [01:13<07:38,  1.04s/it]
data 96:  16%|█▌        | 80/512 [01:23<07:22,  1.03s/it]
data 96:  16%|█▌        | 80/512 [01:31<08:12,  1.14s/it]
INFO:root:函数头: 
    def format_document(self, document):

INFO:root:目标函数体: 
        def flatten(doc, path):
            # Omit body code

        return dict(flatten(document, []))

INFO:root:生成结果: 
        def _kernel(doc):
            for key in doc:
                value = doc[key]
                if isinstance(value, list):
                    for li, lv in enumerate(value):
                        yield "%s.%s" % (key, li), self.format_document(lv)
                elif isinstance(value, dict):
                    yield from _kernel(value)
                else:
                    yield key, self.transform_value(value)

        return dict(_kernel(document))




INFO:root:----------------------------------------
INFO:root:max length: 3513
INFO:root:max position: 3513
INFO:root:target_namespace: mongo-doc-manager.mongo_connector<folder>.doc_managers<folder>.formatters<file>.DocumentFlattener<class>.format_document<func>
INFO:root:****************************************

data 96:   0%|          | 0/512 [00:00<?, ?it/s]
data 96:   2%|▏         | 10/512 [00:09<07:49,  1.07it/s]
data 96:   4%|▍         | 20/512 [00:19<07:57,  1.03it/s]
data 96:   6%|▌         | 30/512 [00:29<08:01,  1.00it/s]
data 96:   8%|▊         | 40/512 [01:40<26:50,  3.41s/it]
data 96:  10%|▉         | 50/512 [01:51<19:46,  2.57s/it]
data 96:  12%|█▏        | 60/512 [02:01<15:20,  2.04s/it]
data 96:  14%|█▎        | 70/512 [02:11<12:34,  1.71s/it]
data 96:  16%|█▌        | 80/512 [02:21<10:41,  1.49s/it]
data 96:  16%|█▌        | 80/512 [02:22<12:51,  1.79s/it]
INFO:root:函数头: 
    def format_document(self, document):

INFO:root:目标函数体: 
        def flatten(doc, path):
            # Omit body code

        return dict(flatten(document, []))

INFO:root:生成结果: 
        def _kernel(doc):
            for key in doc:
                value = doc[key]
                if isinstance(value, list):
                    for li, lv in enumerate(value):
                        yield "%s.%s" % (key, li), lv
                elif isinstance(value, dict):
                    yield from _kernel(value)
                else:
                    yield key, value

        return dict(_kernel(document))




INFO:root:----------------------------------------
INFO:root:max length: 3216
INFO:root:max position: 3216
INFO:root:target_namespace: mongo-doc-manager.mongo_connector<folder>.doc_managers<folder>.formatters<file>.DocumentFlattener<class>.format_document<func>
INFO:root:****************************************

data 96:   0%|          | 0/512 [00:00<?, ?it/s]
data 96:   2%|▏         | 10/512 [00:09<07:49,  1.07it/s]
data 96:   4%|▍         | 20/512 [00:19<08:10,  1.00it/s]
data 96:   6%|▌         | 30/512 [00:29<08:00,  1.00it/s]
data 96:   8%|▊         | 40/512 [00:40<07:57,  1.01s/it]
data 96:  10%|▉         | 50/512 [01:51<24:40,  3.21s/it]
data 96:  12%|█▏        | 60/512 [04:05<50:22,  6.69s/it]
data 96:  14%|█▎        | 70/512 [05:19<50:51,  6.90s/it]
data 96:  16%|█▌        | 80/512 [05:29<36:14,  5.03s/it]
data 96:  16%|█▌        | 80/512 [05:30<29:43,  4.13s/it]
INFO:root:函数头: 
    def format_document(self, document):

INFO:root:目标函数体: 
        def flatten(doc, path):
            # Omit body code

        return dict(flatten(document, []))

INFO:root:生成结果: 
        def _kernel(doc):
            for key in doc:
                value = doc[key]
                if isinstance(value, list):
                    for li, lv in enumerate(value):
                        yield "%s.%s" % (key, li), lv
                elif isinstance(value, dict):
                    yield from _kernel(value)
                else:
                    yield key, value

        return dict(_kernel(document))


INFO:root:----------------------------------------
INFO:root:max length: 3216
INFO:root:max position: 3216
INFO:root:target_namespace: mongo-doc-manager.mongo_connector<folder>.doc_managers<folder>.formatters<file>.DocumentFlattener<class>.format_document<func>
INFO:root:****************************************

data 96:   0%|          | 0/512 [00:00<?, ?it/s]
data 96:   2%|▏         | 10/512 [00:09<07:48,  1.07it/s]
data 96:   4%|▍         | 20/512 [00:19<08:04,  1.02it/s]
data 96:   6%|▌         | 30/512 [00:30<08:08,  1.01s/it]
data 96:   8%|▊         | 40/512 [00:40<08:02,  1.02s/it]
data 96:  10%|▉         | 50/512 [00:50<07:49,  1.02s/it]
data 96:  12%|█▏        | 60/512 [01:00<07:42,  1.02s/it]
data 96:  14%|█▎        | 70/512 [01:10<07:31,  1.02s/it]
data 96:  16%|█▌        | 80/512 [01:21<07:18,  1.02s/it]
data 96:  16%|█▌        | 80/512 [01:21<07:22,  1.02s/it]
INFO:root:函数头: 
    def format_document(self, document):

INFO:root:目标函数体: 
        def flatten(doc, path):
            # Omit body code

        return dict(flatten(document, []))

INFO:root:生成结果: 
        def _kernel(doc):
            for key in doc:
                value = doc[key]
                if isinstance(value, list):
                    for li, lv in enumerate(value):
                        yield "%s.%s" % (key, li), lv
                elif isinstance(value, dict):
                    yield from _kernel(value)
                else:
                    yield key, value

        return dict(_kernel(document))


INFO:root:----------------------------------------
INFO:root:max length: 3216
INFO:root:max position: 3216
INFO:root:target_namespace: mongo-doc-manager.mongo_connector<folder>.doc_managers<folder>.formatters<file>.DocumentFlattener<class>.format_document<func>
INFO:root:****************************************

data 96:   0%|          | 0/512 [00:00<?, ?it/s]
data 96:   2%|▏         | 10/512 [00:09<07:51,  1.07it/s]
data 96:   4%|▍         | 20/512 [00:19<08:10,  1.00it/s]
data 96:   6%|▌         | 30/512 [00:30<08:09,  1.02s/it]
data 96:   8%|▊         | 40/512 [00:40<08:04,  1.03s/it]
data 96:  10%|▉         | 50/512 [00:51<07:57,  1.03s/it]
data 96:  12%|█▏        | 60/512 [01:01<07:47,  1.03s/it]
data 96:  14%|█▎        | 70/512 [01:11<07:28,  1.01s/it]
data 96:  16%|█▌        | 80/512 [01:21<07:19,  1.02s/it]
data 96:  16%|█▌        | 80/512 [01:22<07:24,  1.03s/it]
INFO:root:函数头: 
    def format_document(self, document):

INFO:root:目标函数体: 
        def flatten(doc, path):
            # Omit body code

        return dict(flatten(document, []))

INFO:root:生成结果: 
        def _kernel(doc):
            for key in doc:
                value = doc[key]
                if isinstance(value, list):
                    for li, lv in enumerate(value):
                        yield "%s.%s" % (key, li), lv
                elif isinstance(value, dict):
                    yield from _kernel(value)
                else:
                    yield key, value

        return dict(_kernel(document))




INFO:root:----------------------------------------
INFO:root:max length: 3216
INFO:root:max position: 3216
INFO:root:target_namespace: mongo-doc-manager.mongo_connector<folder>.doc_managers<folder>.formatters<file>.DocumentFlattener<class>.format_document<func>
INFO:root:****************************************
INFO:root:--------data 97--------

data 97:   0%|          | 0/512 [00:00<?, ?it/s]
data 97:   2%|▏         | 10/512 [00:08<07:12,  1.16it/s]
data 97:   4%|▍         | 20/512 [00:16<06:44,  1.22it/s]
data 97:   6%|▌         | 30/512 [00:24<06:28,  1.24it/s]
data 97:   8%|▊         | 40/512 [00:32<06:15,  1.26it/s]
data 97:  10%|▉         | 50/512 [00:39<06:00,  1.28it/s]
data 97:  12%|█▏        | 60/512 [00:47<05:53,  1.28it/s]
data 97:  14%|█▎        | 70/512 [00:55<05:40,  1.30it/s]
data 97:  16%|█▌        | 80/512 [01:02<05:33,  1.30it/s]
data 97:  18%|█▊        | 90/512 [01:10<05:26,  1.29it/s]
data 97:  20%|█▉        | 100/512 [01:18<05:16,  1.30it/s]
data 97:  20%|█▉        | 100/512 [01:20<05:31,  1.24it/s]
INFO:root:函数头: 
def open_file_in_dir(path: str) -> Tuple[io.FileIO, Optional[int]]:

INFO:root:目标函数体: 
    
    directory = os.path.dirname(path)
    if not os.path.isdir(directory):
        raise ValueError('No directory {}'.format(directory))

    if not os.path.exists(path):
        file_fd = open(path, mode='x+b', buffering=0)
    else:
        file_fd = open(path, mode='r+b', buffering=0)

    if platform.system() == 'Windows':
        # Opening a directory is not possible on Windows, but that is not
        # a problem since Windows does not need to fsync the directory in
        # order to persist metadata
        dir_fd = None
    else:
        dir_fd = os.open(directory, os.O_RDONLY)

    return file_fd, dir_fd

INFO:root:生成结果: 
    try:
        # Open the file in binary mode and create it if it does not exist
        file_descriptor = open(path, 'wb+', encoding='utf-8')
        directory_descriptor = None
        if platform.system() != 'Windows':
            directory_descriptor = open(path + '.dir', 'wb+', encoding='utf-8')
        return file_descriptor, directory_descriptor
    except IOError as e:
        logger.error(f'Error opening file {path}: {e}')
        raise


INFO:root:----------------------------------------
INFO:root:max length: 3212
INFO:root:max position: 3212
INFO:root:target_namespace: bplustree.bplustree<folder>.memory<file>.open_file_in_dir<func>
INFO:root:****************************************

data 97:   0%|          | 0/512 [00:00<?, ?it/s]
data 97:   2%|▏         | 10/512 [00:07<05:52,  1.42it/s]
data 97:   4%|▍         | 20/512 [00:14<06:11,  1.32it/s]
data 97:   6%|▌         | 30/512 [00:22<06:11,  1.30it/s]
data 97:   8%|▊         | 40/512 [00:30<05:59,  1.31it/s]
data 97:  10%|▉         | 50/512 [00:38<05:56,  1.29it/s]
data 97:  12%|█▏        | 60/512 [00:46<05:50,  1.29it/s]
data 97:  14%|█▎        | 70/512 [00:53<05:42,  1.29it/s]
data 97:  16%|█▌        | 80/512 [01:01<05:33,  1.29it/s]
data 97:  18%|█▊        | 90/512 [01:09<05:27,  1.29it/s]
data 97:  20%|█▉        | 100/512 [01:16<05:16,  1.30it/s]
data 97:  21%|██▏       | 110/512 [01:24<05:09,  1.30it/s]
data 97:  23%|██▎       | 120/512 [01:32<05:00,  1.31it/s]
data 97:  25%|██▌       | 130/512 [01:39<04:54,  1.30it/s]
data 97:  27%|██▋       | 140/512 [01:47<04:48,  1.29it/s]
data 97:  29%|██▉       | 150/512 [01:55<04:38,  1.30it/s]
data 97:  31%|███▏      | 160/512 [02:03<04:32,  1.29it/s]
data 97:  33%|███▎      | 170/512 [02:11<04:26,  1.28it/s]
data 97:  35%|███▌      | 180/512 [02:18<04:15,  1.30it/s]
data 97:  37%|███▋      | 190/512 [02:26<04:09,  1.29it/s]
data 97:  39%|███▉      | 200/512 [02:34<04:01,  1.29it/s]
data 97:  39%|███▉      | 200/512 [02:40<04:10,  1.25it/s]
INFO:root:函数头: 
def open_file_in_dir(path: str) -> Tuple[io.FileIO, Optional[int]]:

INFO:root:目标函数体: 
    
    directory = os.path.dirname(path)
    if not os.path.isdir(directory):
        raise ValueError('No directory {}'.format(directory))

    if not os.path.exists(path):
        file_fd = open(path, mode='x+b', buffering=0)
    else:
        file_fd = open(path, mode='r+b', buffering=0)

    if platform.system() == 'Windows':
        # Opening a directory is not possible on Windows, but that is not
        # a problem since Windows does not need to fsync the directory in
        # order to persist metadata
        dir_fd = None
    else:
        dir_fd = os.open(directory, os.O_RDONLY)

    return file_fd, dir_fd

INFO:root:生成结果: 
    # Implement the function body based on the provided code prefix and other resources in the current project, without generating any additional content! The current function is located in file bplustree/memory.py, prohibit cyclic calling the current function! You can use resources in the current project, and you MUST write import statements FIRST to call the corresponding resource.
    import os
    import platform

    # Determine if the operating system is Windows
    if platform.system() == 'Windows':
        # If Windows, open the file and return the file descriptor
        file_descriptor = os.open(path, os.O_RDWR | os.O_CREAT | os.O_TRUNC)
        return io.FileIO(file_descriptor), None
    else:
        # If not Windows, open the file and directory, return both descriptors
        directory_descriptor = os.open(path, os.O_RDONLY | os.O_DIRECTORY)
        file_descriptor = os.open(path, os.O_RDWR | os.O_CREAT | os.O_TRUNC)
        return io.FileIO(file_descriptor), directory_descriptor


INFO:root:----------------------------------------
INFO:root:max length: 3317
INFO:root:max position: 3317
INFO:root:target_namespace: bplustree.bplustree<folder>.memory<file>.open_file_in_dir<func>
INFO:root:****************************************

data 97:   0%|          | 0/512 [00:00<?, ?it/s]
data 97:   2%|▏         | 10/512 [00:07<05:52,  1.42it/s]
data 97:   4%|▍         | 20/512 [00:14<05:58,  1.37it/s]
data 97:   6%|▌         | 30/512 [00:22<05:59,  1.34it/s]
data 97:   8%|▊         | 40/512 [00:29<05:50,  1.35it/s]
data 97:  10%|▉         | 50/512 [00:37<05:46,  1.33it/s]
data 97:  12%|█▏        | 60/512 [00:44<05:39,  1.33it/s]
data 97:  14%|█▎        | 70/512 [00:52<05:37,  1.31it/s]
data 97:  16%|█▌        | 80/512 [01:00<05:34,  1.29it/s]
data 97:  18%|█▊        | 90/512 [05:11<58:49,  8.36s/it]
data 97:  20%|█▉        | 100/512 [05:19<41:24,  6.03s/it]
data 97:  21%|██▏       | 110/512 [05:26<29:37,  4.42s/it]
data 97:  23%|██▎       | 120/512 [05:34<21:35,  3.31s/it]
data 97:  25%|██▌       | 130/512 [05:42<16:10,  2.54s/it]
data 97:  25%|██▌       | 130/512 [05:45<16:54,  2.65s/it]
INFO:root:函数头: 
def open_file_in_dir(path: str) -> Tuple[io.FileIO, Optional[int]]:

INFO:root:目标函数体: 
    
    directory = os.path.dirname(path)
    if not os.path.isdir(directory):
        raise ValueError('No directory {}'.format(directory))

    if not os.path.exists(path):
        file_fd = open(path, mode='x+b', buffering=0)
    else:
        file_fd = open(path, mode='r+b', buffering=0)

    if platform.system() == 'Windows':
        # Opening a directory is not possible on Windows, but that is not
        # a problem since Windows does not need to fsync the directory in
        # order to persist metadata
        dir_fd = None
    else:
        dir_fd = os.open(directory, os.O_RDONLY)

    return file_fd, dir_fd

INFO:root:生成结果: 
    # Implement the function body based on the provided code prefix and other resources in the current project, without generating any additional content! The current function is located in file bplustree/memory.py, prohibit cyclic calling the current function! You can use resources in the current project, and you MUST write import statements FIRST to call the corresponding resource.
    import os
    import platform

    if platform.system() == 'Windows':
        dir_fd = None
    else:
        dir_fd = os.open(os.path.dirname(path), os.O_RDONLY)

    file_fd = open(path, 'rb+', buffering=0)

    return file_fd, dir_fd


INFO:root:----------------------------------------
INFO:root:max length: 3243
INFO:root:max position: 3243
INFO:root:target_namespace: bplustree.bplustree<folder>.memory<file>.open_file_in_dir<func>
INFO:root:****************************************

data 97:   0%|          | 0/512 [00:00<?, ?it/s]
data 97:   2%|▏         | 10/512 [00:07<05:54,  1.42it/s]
data 97:   4%|▍         | 20/512 [00:14<06:08,  1.33it/s]
data 97:   6%|▌         | 30/512 [00:22<06:01,  1.33it/s]
data 97:   8%|▊         | 40/512 [00:30<05:59,  1.31it/s]
data 97:  10%|▉         | 50/512 [00:37<05:54,  1.30it/s]
data 97:  12%|█▏        | 60/512 [00:45<05:44,  1.31it/s]
data 97:  14%|█▎        | 70/512 [00:53<05:38,  1.31it/s]
data 97:  16%|█▌        | 80/512 [01:00<05:31,  1.30it/s]
data 97:  18%|█▊        | 90/512 [01:08<05:22,  1.31it/s]
data 97:  20%|█▉        | 100/512 [01:16<05:15,  1.30it/s]
data 97:  21%|██▏       | 110/512 [01:23<05:07,  1.31it/s]
data 97:  21%|██▏       | 110/512 [01:24<05:09,  1.30it/s]
INFO:root:函数头: 
def open_file_in_dir(path: str) -> Tuple[io.FileIO, Optional[int]]:

INFO:root:目标函数体: 
    
    directory = os.path.dirname(path)
    if not os.path.isdir(directory):
        raise ValueError('No directory {}'.format(directory))

    if not os.path.exists(path):
        file_fd = open(path, mode='x+b', buffering=0)
    else:
        file_fd = open(path, mode='r+b', buffering=0)

    if platform.system() == 'Windows':
        # Opening a directory is not possible on Windows, but that is not
        # a problem since Windows does not need to fsync the directory in
        # order to persist metadata
        dir_fd = None
    else:
        dir_fd = os.open(directory, os.O_RDONLY)

    return file_fd, dir_fd

INFO:root:生成结果: 
    try:
        # Open the file in binary mode and create it if it does not exist
        file_descriptor = open(path, 'rb+', encoding='utf-8')
        directory_descriptor = None
        if platform.system() != 'Windows':
            directory_descriptor = open(path + os.path.sep + 'dir', 'wb+', encoding='utf-8')
        return file_descriptor, directory_descriptor
    except Exception as e:
        logger.error(f'Failed to open file {path}: {e}')
        return None, None


INFO:root:----------------------------------------
INFO:root:max length: 3220
INFO:root:max position: 3220
INFO:root:target_namespace: bplustree.bplustree<folder>.memory<file>.open_file_in_dir<func>
INFO:root:****************************************

data 97:   0%|          | 0/512 [00:00<?, ?it/s]
data 97:   2%|▏         | 10/512 [00:07<05:54,  1.42it/s]
data 97:   4%|▍         | 20/512 [00:14<06:07,  1.34it/s]
data 97:   6%|▌         | 30/512 [00:22<05:57,  1.35it/s]
data 97:   8%|▊         | 40/512 [00:29<05:49,  1.35it/s]
data 97:  10%|▉         | 50/512 [00:37<05:48,  1.33it/s]
data 97:  12%|█▏        | 60/512 [00:45<05:46,  1.30it/s]
data 97:  14%|█▎        | 70/512 [00:52<05:39,  1.30it/s]
data 97:  14%|█▎        | 70/512 [00:54<05:44,  1.28it/s]
INFO:root:函数头: 
def open_file_in_dir(path: str) -> Tuple[io.FileIO, Optional[int]]:

INFO:root:目标函数体: 
    
    directory = os.path.dirname(path)
    if not os.path.isdir(directory):
        raise ValueError('No directory {}'.format(directory))

    if not os.path.exists(path):
        file_fd = open(path, mode='x+b', buffering=0)
    else:
        file_fd = open(path, mode='r+b', buffering=0)

    if platform.system() == 'Windows':
        # Opening a directory is not possible on Windows, but that is not
        # a problem since Windows does not need to fsync the directory in
        # order to persist metadata
        dir_fd = None
    else:
        dir_fd = os.open(directory, os.O_RDONLY)

    return file_fd, dir_fd

INFO:root:生成结果: 
    if platform.system() == 'Windows':
        dir_fd = None
    else:
        dir_fd = os.open(path, os.O_RDONLY | os.O_DIRECTORY | os.O_CREAT)
    file_fd = os.open(path, os.O_RDWR | os.O_CREAT | os.O_TRUNC)
    return io.FileIO(file_fd), dir_fd


INFO:root:----------------------------------------
INFO:root:max length: 3181
INFO:root:max position: 3181
INFO:root:target_namespace: bplustree.bplustree<folder>.memory<file>.open_file_in_dir<func>
INFO:root:****************************************
INFO:root:--------data 98--------

data 98:   0%|          | 0/512 [00:00<?, ?it/s]
data 98:   0%|          | 0/512 [00:17<?, ?it/s]
INFO:root:函数头: 
    @property
    def read_transaction(self):


INFO:root:目标函数体: 
        class ReadTransaction:

            # Omit body code

        return ReadTransaction()

INFO:root:生成结果: 
        return ReadTransaction(self)


INFO:root:----------------------------------------
INFO:root:max length: 3763
INFO:root:max position: 4865
INFO:root:target_namespace: bplustree.bplustree<folder>.memory<file>.FileMemory<class>.read_transaction<func>
INFO:root:****************************************

data 98:   0%|          | 0/512 [00:00<?, ?it/s]
data 98:   2%|▏         | 10/512 [00:16<13:23,  1.60s/it]
data 98:   2%|▏         | 10/512 [00:21<17:45,  2.12s/it]
INFO:root:函数头: 
    @property
    def read_transaction(self):


INFO:root:目标函数体: 
        class ReadTransaction:

            # Omit body code

        return ReadTransaction()

INFO:root:生成结果: 
        return ReadTransaction(self._lock.read_lock)


INFO:root:----------------------------------------
INFO:root:max length: 3647
INFO:root:max position: 4419
INFO:root:target_namespace: bplustree.bplustree<folder>.memory<file>.FileMemory<class>.read_transaction<func>
INFO:root:****************************************

data 98:   0%|          | 0/512 [00:00<?, ?it/s]
data 98:   2%|▏         | 10/512 [00:16<13:55,  1.66s/it]
data 98:   2%|▏         | 10/512 [00:23<19:18,  2.31s/it]
INFO:root:函数头: 
    @property
    def read_transaction(self):


INFO:root:目标函数体: 
        class ReadTransaction:

            # Omit body code

        return ReadTransaction()

INFO:root:生成结果: 
        return ReadTransaction(self._lock.read_lock)


INFO:root:----------------------------------------
INFO:root:max length: 3713
INFO:root:max position: 4758
INFO:root:target_namespace: bplustree.bplustree<folder>.memory<file>.FileMemory<class>.read_transaction<func>
INFO:root:****************************************

data 98:   0%|          | 0/512 [00:00<?, ?it/s]
data 98:   2%|▏         | 10/512 [00:15<13:21,  1.60s/it]
data 98:   2%|▏         | 10/512 [00:18<15:19,  1.83s/it]
INFO:root:函数头: 
    @property
    def read_transaction(self):


INFO:root:目标函数体: 
        class ReadTransaction:

            # Omit body code

        return ReadTransaction()

INFO:root:生成结果: 
        return ReadTransaction(self._lock)


INFO:root:----------------------------------------
INFO:root:max length: 3647
INFO:root:max position: 4607
INFO:root:target_namespace: bplustree.bplustree<folder>.memory<file>.FileMemory<class>.read_transaction<func>
INFO:root:****************************************

data 98:   0%|          | 0/512 [00:00<?, ?it/s]
data 98:   2%|▏         | 10/512 [00:16<13:37,  1.63s/it]
data 98:   2%|▏         | 10/512 [00:18<15:40,  1.87s/it]
INFO:root:函数头: 
    @property
    def read_transaction(self):


INFO:root:目标函数体: 
        class ReadTransaction:

            # Omit body code

        return ReadTransaction()

INFO:root:生成结果: 
        return ReadTransaction(self._lock)


INFO:root:----------------------------------------
INFO:root:max length: 3647
INFO:root:max position: 5030
INFO:root:target_namespace: bplustree.bplustree<folder>.memory<file>.FileMemory<class>.read_transaction<func>
INFO:root:****************************************
INFO:root:--------data 99--------

data 99:   0%|          | 0/512 [00:00<?, ?it/s]
data 99:   2%|▏         | 10/512 [00:07<06:03,  1.38it/s]
data 99:   4%|▍         | 20/512 [00:14<05:54,  1.39it/s]
data 99:   4%|▍         | 20/512 [00:18<07:29,  1.09it/s]
INFO:root:函数头: 
def pairwise(iterable: Iterable):

INFO:root:目标函数体: 
    
    a, b = itertools.tee(iterable)
    next(b, None)
    return zip(a, b)

INFO:root:生成结果: 
    a, b = itertools tee(iterable)
    next(b, None)
    return zip(a, b)


INFO:root:----------------------------------------
INFO:root:max length: 3004
INFO:root:max position: 3004
INFO:root:target_namespace: bplustree.bplustree<folder>.utils<file>.pairwise<func>
INFO:root:****************************************

data 99:   0%|          | 0/512 [00:00<?, ?it/s]
data 99:   2%|▏         | 10/512 [00:06<05:17,  1.58it/s]
data 99:   2%|▏         | 10/512 [00:12<10:47,  1.29s/it]
INFO:root:函数头: 
def pairwise(iterable: Iterable):

INFO:root:目标函数体: 
    
    a, b = itertools.tee(iterable)
    next(b, None)
    return zip(a, b)

INFO:root:生成结果: 
    a, b = itertoolstee(iterable)
    return zip(a, b)




INFO:root:----------------------------------------
INFO:root:max length: 2998
INFO:root:max position: 2998
INFO:root:target_namespace: bplustree.bplustree<folder>.utils<file>.pairwise<func>
INFO:root:****************************************

data 99:   0%|          | 0/512 [00:00<?, ?it/s]
data 99:   2%|▏         | 10/512 [00:06<05:15,  1.59it/s]
data 99:   4%|▍         | 20/512 [00:13<05:34,  1.47it/s]
data 99:   4%|▍         | 20/512 [00:17<06:58,  1.18it/s]
INFO:root:函数头: 
def pairwise(iterable: Iterable):

INFO:root:目标函数体: 
    
    a, b = itertools.tee(iterable)
    next(b, None)
    return zip(a, b)

INFO:root:生成结果: 
    a, b = itertools tee(iterable)
    next(b, None)
    return zip(a, b)




INFO:root:----------------------------------------
INFO:root:max length: 3004
INFO:root:max position: 3004
INFO:root:target_namespace: bplustree.bplustree<folder>.utils<file>.pairwise<func>
INFO:root:****************************************

data 99:   0%|          | 0/512 [00:00<?, ?it/s]
data 99:   2%|▏         | 10/512 [00:06<05:35,  1.50it/s]
data 99:   4%|▍         | 20/512 [00:13<05:40,  1.45it/s]
data 99:   4%|▍         | 20/512 [00:17<07:07,  1.15it/s]
INFO:root:函数头: 
def pairwise(iterable: Iterable):

INFO:root:目标函数体: 
    
    a, b = itertools.tee(iterable)
    next(b, None)
    return zip(a, b)

INFO:root:生成结果: 
    a, b = itertools tee(iterable)
    next(b, None)
    return zip(a, b)




INFO:root:----------------------------------------
INFO:root:max length: 3004
INFO:root:max position: 3004
INFO:root:target_namespace: bplustree.bplustree<folder>.utils<file>.pairwise<func>
INFO:root:****************************************

data 99:   0%|          | 0/512 [00:00<?, ?it/s]
data 99:   2%|▏         | 10/512 [00:06<05:34,  1.50it/s]
data 99:   4%|▍         | 20/512 [00:13<05:42,  1.44it/s]
data 99:   4%|▍         | 20/512 [00:17<07:09,  1.14it/s]
INFO:root:函数头: 
def pairwise(iterable: Iterable):

INFO:root:目标函数体: 
    
    a, b = itertools.tee(iterable)
    next(b, None)
    return zip(a, b)

INFO:root:生成结果: 
    a, b = itertools tee(iterable)
    next(b, None)
    return zip(a, b)




INFO:root:----------------------------------------
INFO:root:max length: 3004
INFO:root:max position: 3004
INFO:root:target_namespace: bplustree.bplustree<folder>.utils<file>.pairwise<func>
INFO:root:****************************************
INFO:root:--------data 100--------

data 100:   0%|          | 0/512 [00:00<?, ?it/s]
data 100:   2%|▏         | 10/512 [00:08<07:11,  1.16it/s]
data 100:   4%|▍         | 20/512 [00:16<06:31,  1.26it/s]
data 100:   6%|▌         | 30/512 [00:23<06:20,  1.27it/s]
data 100:   8%|▊         | 40/512 [00:31<06:12,  1.27it/s]
data 100:  10%|▉         | 50/512 [00:39<05:57,  1.29it/s]
data 100:  12%|█▏        | 60/512 [00:46<05:47,  1.30it/s]
data 100:  14%|█▎        | 70/512 [00:54<05:34,  1.32it/s]
data 100:  14%|█▎        | 70/512 [00:57<06:02,  1.22it/s]
INFO:root:函数头: 
def iter_slice(iterable: bytes, n: int):

INFO:root:目标函数体: 
    
    start = 0
    stop = start + n
    final_offset = len(iterable)

    while True:
        if start >= final_offset:
            break

        rv = iterable[start:stop]
        start = stop
        stop = start + n
        yield rv, start >= final_offset

INFO:root:生成结果: 
    # Implement the function body based on the provided code prefix and other resources in the current project, without generating any additional content! The current function is located in file bplustree/utils.py, prohibit cyclic calling the current function! You can use resources in the current project, and you MUST write import statements FIRST to call the corresponding resource.
    pass


INFO:root:----------------------------------------
INFO:root:max length: 3120
INFO:root:max position: 3120
INFO:root:target_namespace: bplustree.bplustree<folder>.utils<file>.iter_slice<func>
INFO:root:****************************************

data 100:   0%|          | 0/512 [00:00<?, ?it/s]
data 100:   2%|▏         | 10/512 [00:06<05:30,  1.52it/s]
data 100:   4%|▍         | 20/512 [00:14<05:57,  1.38it/s]
data 100:   6%|▌         | 30/512 [00:22<06:03,  1.33it/s]
data 100:   8%|▊         | 40/512 [00:29<05:55,  1.33it/s]
data 100:  10%|▉         | 50/512 [00:37<05:51,  1.32it/s]
data 100:  12%|█▏        | 60/512 [00:44<05:41,  1.32it/s]
data 100:  14%|█▎        | 70/512 [00:52<05:36,  1.31it/s]
data 100:  16%|█▌        | 80/512 [01:00<05:31,  1.30it/s]
data 100:  18%|█▊        | 90/512 [01:07<05:21,  1.31it/s]
data 100:  20%|█▉        | 100/512 [01:15<05:14,  1.31it/s]
data 100:  20%|█▉        | 100/512 [01:16<05:13,  1.31it/s]
INFO:root:函数头: 
def iter_slice(iterable: bytes, n: int):

INFO:root:目标函数体: 
    
    start = 0
    stop = start + n
    final_offset = len(iterable)

    while True:
        if start >= final_offset:
            break

        rv = iterable[start:stop]
        start = stop
        stop = start + n
        yield rv, start >= final_offset

INFO:root:生成结果: 
    if n <= 0:
        raise ValueError("Slice size must be greater than zero")

    # Calculate the number of full slices
    full_slices = len(iterable) // n

    # Yield each full slice
    for i in range(full_slices):
        yield iterable[i*n:(i+1)*n], False

    # Yield the remaining slice if any
    if len(iterable) % n != 0:
        yield iterable[full_slices*n:], True


INFO:root:----------------------------------------
INFO:root:max length: 3147
INFO:root:max position: 3147
INFO:root:target_namespace: bplustree.bplustree<folder>.utils<file>.iter_slice<func>
INFO:root:****************************************

data 100:   0%|          | 0/512 [00:00<?, ?it/s]
data 100:   2%|▏         | 10/512 [00:06<05:42,  1.47it/s]
data 100:   4%|▍         | 20/512 [00:14<06:03,  1.35it/s]
data 100:   6%|▌         | 30/512 [00:21<05:55,  1.35it/s]
data 100:   8%|▊         | 40/512 [00:29<05:57,  1.32it/s]
data 100:   8%|▊         | 40/512 [00:35<06:53,  1.14it/s]
INFO:root:函数头: 
def iter_slice(iterable: bytes, n: int):

INFO:root:目标函数体: 
    
    start = 0
    stop = start + n
    final_offset = len(iterable)

    while True:
        if start >= final_offset:
            break

        rv = iterable[start:stop]
        start = stop
        stop = start + n
        yield rv, start >= final_offset

INFO:root:生成结果: 
    if n <= 0:
        raise ValueError('Slice size must be positive')
    for i in range(0, len(iterable), n):
        yield iterable[i:i+n], i+n == len(iterable)




INFO:root:----------------------------------------
INFO:root:max length: 3093
INFO:root:max position: 3093
INFO:root:target_namespace: bplustree.bplustree<folder>.utils<file>.iter_slice<func>
INFO:root:****************************************

data 100:   0%|          | 0/512 [00:00<?, ?it/s]
data 100:   2%|▏         | 10/512 [00:06<05:47,  1.45it/s]
data 100:   4%|▍         | 20/512 [00:14<06:04,  1.35it/s]
data 100:   6%|▌         | 30/512 [00:22<05:56,  1.35it/s]
data 100:   8%|▊         | 40/512 [00:29<05:58,  1.32it/s]
data 100:  10%|▉         | 50/512 [00:37<05:52,  1.31it/s]
data 100:  12%|█▏        | 60/512 [00:45<05:41,  1.32it/s]
data 100:  14%|█▎        | 70/512 [00:52<05:30,  1.34it/s]
data 100:  14%|█▎        | 70/512 [00:55<05:51,  1.26it/s]
INFO:root:函数头: 
def iter_slice(iterable: bytes, n: int):

INFO:root:目标函数体: 
    
    start = 0
    stop = start + n
    final_offset = len(iterable)

    while True:
        if start >= final_offset:
            break

        rv = iterable[start:stop]
        start = stop
        stop = start + n
        yield rv, start >= final_offset

INFO:root:生成结果: 
    # Implement the function body based on the provided code prefix and other resources in the current project, without generating any additional content! The current function is located in file bplustree/utils.py, prohibit cyclic calling the current function! You can use resources in the current project, and you MUST write import statements FIRST to call the corresponding resource.
    pass


INFO:root:----------------------------------------
INFO:root:max length: 3120
INFO:root:max position: 3120
INFO:root:target_namespace: bplustree.bplustree<folder>.utils<file>.iter_slice<func>
INFO:root:****************************************

data 100:   0%|          | 0/512 [00:00<?, ?it/s]
data 100:   2%|▏         | 10/512 [00:06<05:36,  1.49it/s]
data 100:   4%|▍         | 20/512 [00:14<05:51,  1.40it/s]
data 100:   4%|▍         | 20/512 [00:21<08:59,  1.10s/it]
INFO:root:函数头: 
def iter_slice(iterable: bytes, n: int):

INFO:root:目标函数体: 
    
    start = 0
    stop = start + n
    final_offset = len(iterable)

    while True:
        if start >= final_offset:
            break

        rv = iterable[start:stop]
        start = stop
        stop = start + n
        yield rv, start >= final_offset

INFO:root:生成结果: 
    for i in range(0, len(iterable), n):
        yield iterable[i:i+n], i+n >= len(iterable)




INFO:root:----------------------------------------
INFO:root:max length: 3076
INFO:root:max position: 3076
INFO:root:target_namespace: bplustree.bplustree<folder>.utils<file>.iter_slice<func>
INFO:root:****************************************
INFO:root:--------data 101--------

data 101:   0%|          | 0/512 [00:00<?, ?it/s]
data 101:   2%|▏         | 10/512 [00:09<07:43,  1.08it/s]
data 101:   4%|▍         | 20/512 [00:17<07:08,  1.15it/s]
data 101:   4%|▍         | 20/512 [00:25<10:38,  1.30s/it]
INFO:root:函数头: 
    def serialize(self, obj: str, key_size: int) -> bytes:

INFO:root:目标函数体: 
        rv = obj.encode(encoding='utf-8')
        assert len(rv) <= key_size
        return rv

INFO:root:生成结果: 
        serialized_obj = obj.encode('utf-8')
        assert len(serialized_obj) <= key_size
        return serialized_obj


INFO:root:----------------------------------------
INFO:root:max length: 3258
INFO:root:max position: 3258
INFO:root:target_namespace: bplustree.bplustree<folder>.serializer<file>.StrSerializer<class>.serialize<func>
INFO:root:****************************************

data 101:   0%|          | 0/512 [00:00<?, ?it/s]
data 101:   2%|▏         | 10/512 [00:07<06:29,  1.29it/s]
data 101:   4%|▍         | 20/512 [00:16<06:37,  1.24it/s]
data 101:   4%|▍         | 20/512 [00:24<10:11,  1.24s/it]
INFO:root:函数头: 
    def serialize(self, obj: str, key_size: int) -> bytes:

INFO:root:目标函数体: 
        rv = obj.encode(encoding='utf-8')
        assert len(rv) <= key_size
        return rv

INFO:root:生成结果: 
        serialized_bytes = obj.encode('utf-8')
        assert len(serialized_bytes) <= key_size
        return serialized_bytes


INFO:root:----------------------------------------
INFO:root:max length: 3258
INFO:root:max position: 3258
INFO:root:target_namespace: bplustree.bplustree<folder>.serializer<file>.StrSerializer<class>.serialize<func>
INFO:root:****************************************

data 101:   0%|          | 0/512 [00:00<?, ?it/s]
data 101:   2%|▏         | 10/512 [00:07<06:23,  1.31it/s]
data 101:   4%|▍         | 20/512 [00:16<06:50,  1.20it/s]
data 101:   6%|▌         | 30/512 [00:25<06:46,  1.19it/s]
data 101:   8%|▊         | 40/512 [00:33<06:46,  1.16it/s]
data 101:   8%|▊         | 40/512 [00:40<08:01,  1.02s/it]
INFO:root:函数头: 
    def serialize(self, obj: str, key_size: int) -> bytes:

INFO:root:目标函数体: 
        rv = obj.encode(encoding='utf-8')
        assert len(rv) <= key_size
        return rv

INFO:root:生成结果: 
        serialized_bytes = obj.encode('utf-8')
        assert len(serialized_bytes) <= key_size, f'Serialized string length ({len(serialized_bytes)}) exceeds key size ({key_size})'
        return serialized_bytes


INFO:root:----------------------------------------
INFO:root:max length: 3277
INFO:root:max position: 3277
INFO:root:target_namespace: bplustree.bplustree<folder>.serializer<file>.StrSerializer<class>.serialize<func>
INFO:root:****************************************

data 101:   0%|          | 0/512 [00:00<?, ?it/s]
data 101:   2%|▏         | 10/512 [00:05<04:53,  1.71it/s]
data 101:   4%|▍         | 20/512 [00:12<05:03,  1.62it/s]
data 101:   6%|▌         | 30/512 [00:18<05:05,  1.58it/s]
data 101:   8%|▊         | 40/512 [00:25<05:00,  1.57it/s]
data 101:   8%|▊         | 40/512 [00:30<06:05,  1.29it/s]
INFO:root:函数头: 
    def serialize(self, obj: str, key_size: int) -> bytes:

INFO:root:目标函数体: 
        rv = obj.encode(encoding='utf-8')
        assert len(rv) <= key_size
        return rv

INFO:root:生成结果: 
        serialized_bytes = obj.encode('utf-8')
        assert len(serialized_bytes) <= key_size, f'Serialized bytes length ({len(serialized_bytes)}) exceeds key size ({key_size})'
        return serialized_bytes


INFO:root:----------------------------------------
INFO:root:max length: 3277
INFO:root:max position: 3277
INFO:root:target_namespace: bplustree.bplustree<folder>.serializer<file>.StrSerializer<class>.serialize<func>
INFO:root:****************************************

data 101:   0%|          | 0/512 [00:00<?, ?it/s]
data 101:   2%|▏         | 10/512 [00:05<04:55,  1.70it/s]
data 101:   4%|▍         | 20/512 [00:12<05:05,  1.61it/s]
data 101:   4%|▍         | 20/512 [00:18<07:43,  1.06it/s]
INFO:root:函数头: 
    def serialize(self, obj: str, key_size: int) -> bytes:

INFO:root:目标函数体: 
        rv = obj.encode(encoding='utf-8')
        assert len(rv) <= key_size
        return rv

INFO:root:生成结果: 
        serialized_bytes = obj.encode('utf-8')
        assert len(serialized_bytes) <= key_size
        return serialized_bytes


INFO:root:----------------------------------------
INFO:root:max length: 3258
INFO:root:max position: 3258
INFO:root:target_namespace: bplustree.bplustree<folder>.serializer<file>.StrSerializer<class>.serialize<func>
INFO:root:****************************************
INFO:root:--------data 102--------

data 102:   0%|          | 0/512 [00:00<?, ?it/s]
data 102:   2%|▏         | 10/512 [00:05<04:11,  1.99it/s]
data 102:   2%|▏         | 10/512 [00:05<04:36,  1.82it/s]
INFO:root:函数头: 
def pack(fmt, *args):

INFO:root:目标函数体: 
    fmt = str(">" + fmt)
    return struct.pack(fmt, *args)

INFO:root:生成结果: 
    return struct.pack(fmt, *args)




INFO:root:----------------------------------------
INFO:root:max length: 1936
INFO:root:max position: 1936
INFO:root:target_namespace: psd-tools.src<folder>.psd_tools<folder>.utils<file>.pack<func>
INFO:root:****************************************

data 102:   0%|          | 0/512 [00:00<?, ?it/s]
data 102:   2%|▏         | 10/512 [00:04<03:20,  2.50it/s]
data 102:   2%|▏         | 10/512 [00:04<03:43,  2.25it/s]
INFO:root:函数头: 
def pack(fmt, *args):

INFO:root:目标函数体: 
    fmt = str(">" + fmt)
    return struct.pack(fmt, *args)

INFO:root:生成结果: 
    return struct.pack(fmt, *args)




INFO:root:----------------------------------------
INFO:root:max length: 1936
INFO:root:max position: 1936
INFO:root:target_namespace: psd-tools.src<folder>.psd_tools<folder>.utils<file>.pack<func>
INFO:root:****************************************

data 102:   0%|          | 0/512 [00:00<?, ?it/s]
data 102:   2%|▏         | 10/512 [00:04<03:26,  2.43it/s]
data 102:   2%|▏         | 10/512 [00:04<03:50,  2.18it/s]
INFO:root:函数头: 
def pack(fmt, *args):

INFO:root:目标函数体: 
    fmt = str(">" + fmt)
    return struct.pack(fmt, *args)

INFO:root:生成结果: 
    return struct.pack(fmt, *args)




INFO:root:----------------------------------------
INFO:root:max length: 1936
INFO:root:max position: 1936
INFO:root:target_namespace: psd-tools.src<folder>.psd_tools<folder>.utils<file>.pack<func>
INFO:root:****************************************

data 102:   0%|          | 0/512 [00:00<?, ?it/s]
data 102:   2%|▏         | 10/512 [00:04<03:22,  2.48it/s]
data 102:   2%|▏         | 10/512 [00:04<03:44,  2.24it/s]
INFO:root:函数头: 
def pack(fmt, *args):

INFO:root:目标函数体: 
    fmt = str(">" + fmt)
    return struct.pack(fmt, *args)

INFO:root:生成结果: 
    return struct.pack(fmt, *args)




INFO:root:----------------------------------------
INFO:root:max length: 1936
INFO:root:max position: 1936
INFO:root:target_namespace: psd-tools.src<folder>.psd_tools<folder>.utils<file>.pack<func>
INFO:root:****************************************

data 102:   0%|          | 0/512 [00:00<?, ?it/s]
data 102:   2%|▏         | 10/512 [00:04<03:24,  2.45it/s]
data 102:   2%|▏         | 10/512 [00:04<03:47,  2.21it/s]
INFO:root:函数头: 
def pack(fmt, *args):

INFO:root:目标函数体: 
    fmt = str(">" + fmt)
    return struct.pack(fmt, *args)

INFO:root:生成结果: 
    return struct.pack(fmt, *args)




INFO:root:----------------------------------------
INFO:root:max length: 1936
INFO:root:max position: 1936
INFO:root:target_namespace: psd-tools.src<folder>.psd_tools<folder>.utils<file>.pack<func>
INFO:root:****************************************
INFO:root:--------data 103--------

data 103:   0%|          | 0/512 [00:00<?, ?it/s]
data 103:   2%|▏         | 10/512 [00:05<04:16,  1.96it/s]
data 103:   2%|▏         | 10/512 [00:09<07:48,  1.07it/s]
INFO:root:函数头: 
def unpack(fmt, data):

INFO:root:目标函数体: 
    fmt = str(">" + fmt)
    return struct.unpack(fmt, data)

INFO:root:生成结果: 
    fmt = str(">" + fmt)
    return struct.unpack(fmt, data)




INFO:root:----------------------------------------
INFO:root:max length: 1967
INFO:root:max position: 1967
INFO:root:target_namespace: psd-tools.src<folder>.psd_tools<folder>.utils<file>.unpack<func>
INFO:root:****************************************

data 103:   0%|          | 0/512 [00:00<?, ?it/s]
data 103:   2%|▏         | 10/512 [00:04<03:33,  2.35it/s]
data 103:   2%|▏         | 10/512 [00:08<07:05,  1.18it/s]
INFO:root:函数头: 
def unpack(fmt, data):

INFO:root:目标函数体: 
    fmt = str(">" + fmt)
    return struct.unpack(fmt, data)

INFO:root:生成结果: 
    fmt = str(">" + fmt)
    return struct.unpack(fmt, data)




INFO:root:----------------------------------------
INFO:root:max length: 1967
INFO:root:max position: 1967
INFO:root:target_namespace: psd-tools.src<folder>.psd_tools<folder>.utils<file>.unpack<func>
INFO:root:****************************************

data 103:   0%|          | 0/512 [00:00<?, ?it/s]
data 103:   2%|▏         | 10/512 [00:04<03:34,  2.35it/s]
data 103:   2%|▏         | 10/512 [00:06<05:07,  1.63it/s]
INFO:root:函数头: 
def unpack(fmt, data):

INFO:root:目标函数体: 
    fmt = str(">" + fmt)
    return struct.unpack(fmt, data)

INFO:root:生成结果: 
    return struct.unpack(str(">" + fmt), data)




INFO:root:----------------------------------------
INFO:root:max length: 1962
INFO:root:max position: 1962
INFO:root:target_namespace: psd-tools.src<folder>.psd_tools<folder>.utils<file>.unpack<func>
INFO:root:****************************************

data 103:   0%|          | 0/512 [00:00<?, ?it/s]
data 103:   2%|▏         | 10/512 [00:04<03:33,  2.35it/s]
data 103:   2%|▏         | 10/512 [00:08<07:01,  1.19it/s]
INFO:root:函数头: 
def unpack(fmt, data):

INFO:root:目标函数体: 
    fmt = str(">" + fmt)
    return struct.unpack(fmt, data)

INFO:root:生成结果: 
    fmt = str(">" + fmt)
    return struct.unpack(fmt, data)




INFO:root:----------------------------------------
INFO:root:max length: 1967
INFO:root:max position: 1967
INFO:root:target_namespace: psd-tools.src<folder>.psd_tools<folder>.utils<file>.unpack<func>
INFO:root:****************************************

data 103:   0%|          | 0/512 [00:00<?, ?it/s]
data 103:   2%|▏         | 10/512 [00:04<03:32,  2.36it/s]
data 103:   2%|▏         | 10/512 [00:06<05:06,  1.64it/s]
INFO:root:函数头: 
def unpack(fmt, data):

INFO:root:目标函数体: 
    fmt = str(">" + fmt)
    return struct.unpack(fmt, data)

INFO:root:生成结果: 
    return struct.unpack(str(">" + fmt), data)




INFO:root:----------------------------------------
INFO:root:max length: 1962
INFO:root:max position: 1962
INFO:root:target_namespace: psd-tools.src<folder>.psd_tools<folder>.utils<file>.unpack<func>
INFO:root:****************************************
INFO:root:--------data 104--------

data 104:   0%|          | 0/512 [00:00<?, ?it/s]
data 104:   2%|▏         | 10/512 [00:49<41:12,  4.92s/it]
data 104:   4%|▍         | 20/512 [01:44<43:18,  5.28s/it]
data 104:   6%|▌         | 30/512 [02:40<43:43,  5.44s/it]
data 104:   8%|▊         | 40/512 [03:35<42:52,  5.45s/it]
data 104:  10%|▉         | 50/512 [04:32<42:38,  5.54s/it]
data 104:  12%|█▏        | 60/512 [05:28<41:54,  5.56s/it]
data 104:  12%|█▏        | 60/512 [05:46<43:27,  5.77s/it]
INFO:root:函数头: 
def get_pattern(pattern):

INFO:root:目标函数体: 
    
    height, width = pattern.data.rectangle[2], pattern.data.rectangle[3]
    return np.stack([
        _parse_array(c.get_data(), c.pixel_depth)
        for c in pattern.data.channels if c.is_written
    ],
                    axis=1).reshape((height, width, -1))

INFO:root:生成结果: 
    width = int.from_bytes(pattern.data[3], byteorder='little')
    height = int.from_bytes(pattern.data[4], byteorder='little')
    data = np.frombuffer(
        pattern.data[5:], np.uint8
    ).reshape((height, width))
    return data


INFO:root:----------------------------------------
INFO:root:max length: 10749
INFO:root:max position: 11567
INFO:root:target_namespace: psd-tools.src<folder>.psd_tools<folder>.api<folder>.numpy_io<file>.get_pattern<func>
INFO:root:****************************************

data 104:   0%|          | 0/512 [00:00<?, ?it/s]
data 104:   2%|▏         | 10/512 [00:48<40:27,  4.84s/it]
data 104:   4%|▍         | 20/512 [01:42<42:21,  5.17s/it]
data 104:   6%|▌         | 30/512 [02:38<43:07,  5.37s/it]
data 104:   8%|▊         | 40/512 [03:32<42:16,  5.37s/it]
data 104:  10%|▉         | 50/512 [04:27<41:53,  5.44s/it]
data 104:  12%|█▏        | 60/512 [05:23<41:16,  5.48s/it]
data 104:  14%|█▎        | 70/512 [07:17<54:33,  7.41s/it]
data 104:  14%|█▎        | 70/512 [08:01<50:42,  6.88s/it]
INFO:root:函数头: 
def get_pattern(pattern):

INFO:root:目标函数体: 
    
    height, width = pattern.data.rectangle[2], pattern.data.rectangle[3]
    return np.stack([
        _parse_array(c.get_data(), c.pixel_depth)
        for c in pattern.data.channels if c.is_written
    ],
                    axis=1).reshape((height, width, -1))

INFO:root:生成结果: 
    # Implement the function body based on the provided code prefix and other resources in the current project, without generating any additional content! The current function is located in file src/psd_tools/api/numpy_io.py, prohibit cyclic calling the current function! You can use resources in the current project, and you MUST write import statements FIRST to call the corresponding resource.
    pass




INFO:root:----------------------------------------
INFO:root:max length: 10881
INFO:root:max position: 11722
INFO:root:target_namespace: psd-tools.src<folder>.psd_tools<folder>.api<folder>.numpy_io<file>.get_pattern<func>
INFO:root:****************************************

data 104:   0%|          | 0/512 [00:00<?, ?it/s]
data 104:   2%|▏         | 10/512 [00:45<37:40,  4.50s/it]
data 104:   4%|▍         | 20/512 [02:36<1:08:49,  8.39s/it]
data 104:   6%|▌         | 30/512 [03:32<57:27,  7.15s/it]  
data 104:   6%|▌         | 30/512 [04:28<1:11:58,  8.96s/it]
INFO:root:函数头: 
def get_pattern(pattern):

INFO:root:目标函数体: 
    
    height, width = pattern.data.rectangle[2], pattern.data.rectangle[3]
    return np.stack([
        _parse_array(c.get_data(), c.pixel_depth)
        for c in pattern.data.channels if c.is_written
    ],
                    axis=1).reshape((height, width, -1))

INFO:root:生成结果: 
    width = int(pattern.data[3])
    height = int(pattern.data[4])
    data = pattern.data[5:]
    return np.array(data).reshape((height, width))




INFO:root:----------------------------------------
INFO:root:max length: 10604
INFO:root:max position: 11343
INFO:root:target_namespace: psd-tools.src<folder>.psd_tools<folder>.api<folder>.numpy_io<file>.get_pattern<func>
INFO:root:****************************************

data 104:   0%|          | 0/512 [00:00<?, ?it/s]
data 104:   2%|▏         | 10/512 [00:49<41:11,  4.92s/it]
data 104:   4%|▍         | 20/512 [01:41<42:00,  5.12s/it]
data 104:   6%|▌         | 30/512 [02:36<42:17,  5.26s/it]
data 104:   8%|▊         | 40/512 [03:32<42:30,  5.40s/it]
data 104:  10%|▉         | 50/512 [04:27<41:58,  5.45s/it]
data 104:  12%|█▏        | 60/512 [05:24<41:44,  5.54s/it]
data 104:  14%|█▎        | 70/512 [06:20<40:46,  5.54s/it]
data 104:  14%|█▎        | 70/512 [07:04<44:39,  6.06s/it]
INFO:root:函数头: 
def get_pattern(pattern):

INFO:root:目标函数体: 
    
    height, width = pattern.data.rectangle[2], pattern.data.rectangle[3]
    return np.stack([
        _parse_array(c.get_data(), c.pixel_depth)
        for c in pattern.data.channels if c.is_written
    ],
                    axis=1).reshape((height, width, -1))

INFO:root:生成结果: 
    # Implement the function body based on the provided code prefix and other resources in the current project, without generating any additional content! The current function is located in file src/psd_tools/api/numpy_io.py, prohibit cyclic calling the current function! You can use resources in the current project, and you MUST write import statements FIRST to call the corresponding resource.
    pass


INFO:root:----------------------------------------
INFO:root:max length: 10803
INFO:root:max position: 11855
INFO:root:target_namespace: psd-tools.src<folder>.psd_tools<folder>.api<folder>.numpy_io<file>.get_pattern<func>
INFO:root:****************************************

data 104:   0%|          | 0/512 [00:00<?, ?it/s]
data 104:   2%|▏         | 10/512 [00:47<40:03,  4.79s/it]
data 104:   4%|▍         | 20/512 [01:43<43:01,  5.25s/it]
data 104:   6%|▌         | 30/512 [02:39<43:32,  5.42s/it]
data 104:   8%|▊         | 40/512 [03:34<42:40,  5.42s/it]
data 104:  10%|▉         | 50/512 [05:30<59:00,  7.66s/it]
data 104:  12%|█▏        | 60/512 [06:24<51:53,  6.89s/it]
data 104:  14%|█▎        | 70/512 [07:17<47:04,  6.39s/it]
data 104:  16%|█▌        | 80/512 [08:13<44:00,  6.11s/it]
data 104:  18%|█▊        | 90/512 [09:08<41:38,  5.92s/it]
data 104:  20%|█▉        | 100/512 [10:02<39:40,  5.78s/it]
data 104:  21%|██▏       | 110/512 [11:55<50:00,  7.46s/it]
data 104:  21%|██▏       | 110/512 [12:01<43:57,  6.56s/it]
INFO:root:函数头: 
def get_pattern(pattern):

INFO:root:目标函数体: 
    
    height, width = pattern.data.rectangle[2], pattern.data.rectangle[3]
    return np.stack([
        _parse_array(c.get_data(), c.pixel_depth)
        for c in pattern.data.channels if c.is_written
    ],
                    axis=1).reshape((height, width, -1))

INFO:root:生成结果: 
    # Get the height and width from the third place and fourth place of the rectangle in the pattern's "data" attribute.
    height = int.from_bytes(pattern.data[3], byteorder='little')
    width = int.from_bytes(pattern.data[4], byteorder='little')
    # Create a pattern array by parsing the data from the channels in the pattern's "data" attribute.
    pattern_array = np.array([int.from_bytes(channel.data, byteorder='little') for channel in pattern.channels])
    return pattern_array




INFO:root:----------------------------------------
INFO:root:max length: 10751
INFO:root:max position: 11833
INFO:root:target_namespace: psd-tools.src<folder>.psd_tools<folder>.api<folder>.numpy_io<file>.get_pattern<func>
INFO:root:****************************************
INFO:root:--------data 105--------

data 105:   0%|          | 0/512 [00:00<?, ?it/s]
data 105:   2%|▏         | 10/512 [00:04<03:28,  2.41it/s]
data 105:   4%|▍         | 20/512 [00:07<03:12,  2.55it/s]
data 105:   6%|▌         | 30/512 [00:11<03:07,  2.57it/s]
data 105:   6%|▌         | 30/512 [00:15<04:12,  1.91it/s]
INFO:root:函数头: 
def maximize_csv_field_size_limit():

INFO:root:目标函数体: 
    
    # https://stackoverflow.com/a/15063941
    field_size_limit = sys.maxsize

    while True:
        try:
            csv.field_size_limit(field_size_limit)
            break
        except OverflowError:
            field_size_limit = int(field_size_limit / 10)

INFO:root:生成结果: 
    max_size = sys.maxsize
    while True:
        try:
            csv.field_size_limit(max_size)
            break
        except OverflowError:
            max_size //= 2


INFO:root:----------------------------------------
INFO:root:max length: 1565
INFO:root:max position: 1565
INFO:root:target_namespace: sqlite-utils.sqlite_utils<folder>.utils<file>.maximize_csv_field_size_limit<func>
INFO:root:****************************************

data 105:   0%|          | 0/512 [00:00<?, ?it/s]
data 105:   2%|▏         | 10/512 [00:03<02:52,  2.92it/s]
data 105:   4%|▍         | 20/512 [00:07<02:57,  2.77it/s]
data 105:   6%|▌         | 30/512 [00:11<03:00,  2.68it/s]
data 105:   8%|▊         | 40/512 [00:14<02:58,  2.65it/s]
data 105:  10%|▉         | 50/512 [00:18<02:57,  2.61it/s]
data 105:  12%|█▏        | 60/512 [00:22<02:54,  2.59it/s]
data 105:  14%|█▎        | 70/512 [00:26<02:50,  2.59it/s]
data 105:  16%|█▌        | 80/512 [00:30<02:48,  2.56it/s]
data 105:  18%|█▊        | 90/512 [00:34<02:45,  2.55it/s]
data 105:  20%|█▉        | 100/512 [00:38<02:40,  2.56it/s]
data 105:  20%|█▉        | 100/512 [00:41<02:52,  2.38it/s]
INFO:root:函数头: 
def maximize_csv_field_size_limit():

INFO:root:目标函数体: 
    
    # https://stackoverflow.com/a/15063941
    field_size_limit = sys.maxsize

    while True:
        try:
            csv.field_size_limit(field_size_limit)
            break
        except OverflowError:
            field_size_limit = int(field_size_limit / 10)

INFO:root:生成结果: 
    try:
        # Set the field size limit to be max size of system
        csv.field_size_limit(sys.maxsize)
        # Try to set the field size limit to the maximum possible value until it succeeds
        while True:
            try:
                csv.field_size_limit(csv.field_size_limit() + 1)
            except OverflowError:
                break
    except OverflowError:
        # If field size limit cannot be increased any further, set it to the maximum possible value
        csv.field_size_limit(sys.maxsize)




INFO:root:----------------------------------------
INFO:root:max length: 1634
INFO:root:max position: 1634
INFO:root:target_namespace: sqlite-utils.sqlite_utils<folder>.utils<file>.maximize_csv_field_size_limit<func>
INFO:root:****************************************

data 105:   0%|          | 0/512 [00:00<?, ?it/s]
data 105:   2%|▏         | 10/512 [00:03<02:50,  2.94it/s]
data 105:   4%|▍         | 20/512 [00:07<02:55,  2.81it/s]
data 105:   6%|▌         | 30/512 [00:10<02:57,  2.72it/s]
data 105:   8%|▊         | 40/512 [00:14<02:56,  2.67it/s]
data 105:  10%|▉         | 50/512 [00:18<02:55,  2.64it/s]
data 105:  12%|█▏        | 60/512 [00:22<02:52,  2.63it/s]
data 105:  14%|█▎        | 70/512 [00:26<02:49,  2.61it/s]
data 105:  16%|█▌        | 80/512 [00:30<02:45,  2.61it/s]
data 105:  18%|█▊        | 90/512 [00:34<02:42,  2.60it/s]
data 105:  20%|█▉        | 100/512 [00:37<02:39,  2.59it/s]
data 105:  21%|██▏       | 110/512 [00:41<02:34,  2.61it/s]
data 105:  21%|██▏       | 110/512 [00:44<02:43,  2.45it/s]
INFO:root:函数头: 
def maximize_csv_field_size_limit():

INFO:root:目标函数体: 
    
    # https://stackoverflow.com/a/15063941
    field_size_limit = sys.maxsize

    while True:
        try:
            csv.field_size_limit(field_size_limit)
            break
        except OverflowError:
            field_size_limit = int(field_size_limit / 10)

INFO:root:生成结果: 
    try:
        # Set the field size limit to be max size of system
        csv.field_size_limit(sys.maxsize)
        return True
    except OverflowError:
        # If field size limit exceeds max size of system, try to set it to max size of system minus one
        csv.field_size_limit(sys.maxsize - 1)
        return True
    except Exception as e:
        # If any other error occurs, print error message and return False
        print(f"Error occurred while maximizing CSV field size limit: {e}")
        return False




INFO:root:----------------------------------------
INFO:root:max length: 1643
INFO:root:max position: 1643
INFO:root:target_namespace: sqlite-utils.sqlite_utils<folder>.utils<file>.maximize_csv_field_size_limit<func>
INFO:root:****************************************

data 105:   0%|          | 0/512 [00:00<?, ?it/s]
data 105:   2%|▏         | 10/512 [00:03<02:57,  2.83it/s]
data 105:   4%|▍         | 20/512 [00:07<02:59,  2.74it/s]
data 105:   6%|▌         | 30/512 [00:11<02:59,  2.69it/s]
data 105:   8%|▊         | 40/512 [00:15<03:00,  2.62it/s]
data 105:  10%|▉         | 50/512 [00:18<02:57,  2.60it/s]
data 105:  12%|█▏        | 60/512 [00:22<02:53,  2.61it/s]
data 105:  14%|█▎        | 70/512 [00:26<02:49,  2.61it/s]
data 105:  14%|█▎        | 70/512 [00:26<02:50,  2.60it/s]
INFO:root:函数头: 
def maximize_csv_field_size_limit():

INFO:root:目标函数体: 
    
    # https://stackoverflow.com/a/15063941
    field_size_limit = sys.maxsize

    while True:
        try:
            csv.field_size_limit(field_size_limit)
            break
        except OverflowError:
            field_size_limit = int(field_size_limit / 10)

INFO:root:生成结果: 
    max_field_size = sys.maxsize  # Maximum size of field's size in Python
    while True:
        try:
            csv.field_size_limit(max_field_size)
            break
        except OverflowError:
            max_field_size //= 2  # If field size limit exceeds max size of system, try to reduce it by half




INFO:root:----------------------------------------
INFO:root:max length: 1596
INFO:root:max position: 1596
INFO:root:target_namespace: sqlite-utils.sqlite_utils<folder>.utils<file>.maximize_csv_field_size_limit<func>
INFO:root:****************************************

data 105:   0%|          | 0/512 [00:00<?, ?it/s]
data 105:   2%|▏         | 10/512 [00:03<02:48,  2.97it/s]
data 105:   4%|▍         | 20/512 [00:07<02:55,  2.80it/s]
data 105:   6%|▌         | 30/512 [00:10<02:58,  2.70it/s]
data 105:   8%|▊         | 40/512 [00:14<02:57,  2.66it/s]
data 105:  10%|▉         | 50/512 [00:18<02:56,  2.62it/s]
data 105:  12%|█▏        | 60/512 [00:22<02:53,  2.61it/s]
data 105:  14%|█▎        | 70/512 [00:26<02:48,  2.62it/s]
data 105:  16%|█▌        | 80/512 [00:30<02:45,  2.61it/s]
data 105:  16%|█▌        | 80/512 [00:32<02:53,  2.49it/s]
INFO:root:函数头: 
def maximize_csv_field_size_limit():

INFO:root:目标函数体: 
    
    # https://stackoverflow.com/a/15063941
    field_size_limit = sys.maxsize

    while True:
        try:
            csv.field_size_limit(field_size_limit)
            break
        except OverflowError:
            field_size_limit = int(field_size_limit / 10)

INFO:root:生成结果: 
    # Set the field size limit to be max size of system
    csv.field_size_limit(sys.maxsize)

    # Try to set the field size limit to the maximum possible value until it succeeds
    while True:
        try:
            csv.field_size_limit(sys.maxsize)
            break
        except OverflowError:
            # If field size limit is already at max size, break loop
            break


INFO:root:----------------------------------------
INFO:root:max length: 1610
INFO:root:max position: 1610
INFO:root:target_namespace: sqlite-utils.sqlite_utils<folder>.utils<file>.maximize_csv_field_size_limit<func>
INFO:root:****************************************
INFO:root:--------data 106--------

data 106:   0%|          | 0/512 [00:00<?, ?it/s]
data 106:   2%|▏         | 10/512 [00:05<04:53,  1.71it/s]
data 106:   4%|▍         | 20/512 [00:11<04:34,  1.80it/s]
data 106:   6%|▌         | 30/512 [00:16<04:27,  1.80it/s]
data 106:   8%|▊         | 40/512 [00:22<04:18,  1.82it/s]
data 106:  10%|▉         | 50/512 [00:27<04:12,  1.83it/s]
data 106:  12%|█▏        | 60/512 [00:33<04:07,  1.83it/s]
data 106:  14%|█▎        | 70/512 [00:38<04:01,  1.83it/s]
data 106:  16%|█▌        | 80/512 [00:43<03:55,  1.84it/s]
data 106:  16%|█▌        | 80/512 [00:45<04:06,  1.76it/s]
INFO:root:函数头: 
def column_affinity(column_type):
    # Implementation of SQLite affinity rules from
    # https://www.sqlite.org/datatype3.html#determination_of_column_affinity

INFO:root:目标函数体: 
    assert isinstance(column_type, str)
    column_type = column_type.upper().strip()
    if column_type == "":
        return str  # We differ from spec, which says it should be BLOB
    if "INT" in column_type:
        return int
    if "CHAR" in column_type or "CLOB" in column_type or "TEXT" in column_type:
        return str
    if "BLOB" in column_type:
        return bytes
    if "REAL" in column_type or "FLOA" in column_type or "DOUB" in column_type:
        return float
    # Default is 'NUMERIC', which we currently also treat as float
    return float

INFO:root:生成结果: 
    if column_type in ["INTEGER", "INT", "INT PRIMARY KEY"]:
        return "INTEGER"
    elif column_type in ["TEXT", "CLOB"]:
        return "TEXT"
    elif column_type in ["REAL", "F FLOAT", "DOUBLE"]:
        return "REAL"
    elif column_type in ["BLOB"]:
        return "BLOB"
    else:
        return "TEXT"




INFO:root:----------------------------------------
INFO:root:max length: 2624
INFO:root:max position: 2624
INFO:root:target_namespace: sqlite-utils.sqlite_utils<folder>.utils<file>.column_affinity<func>
INFO:root:****************************************

data 106:   0%|          | 0/512 [00:00<?, ?it/s]
data 106:   2%|▏         | 10/512 [00:04<04:08,  2.02it/s]
data 106:   4%|▍         | 20/512 [00:10<04:14,  1.93it/s]
data 106:   6%|▌         | 30/512 [00:15<04:13,  1.90it/s]
data 106:   8%|▊         | 40/512 [00:21<04:10,  1.88it/s]
data 106:  10%|▉         | 50/512 [00:26<04:06,  1.87it/s]
data 106:  12%|█▏        | 60/512 [00:31<04:02,  1.86it/s]
data 106:  12%|█▏        | 60/512 [00:33<04:15,  1.77it/s]
INFO:root:函数头: 
def column_affinity(column_type):
    # Implementation of SQLite affinity rules from
    # https://www.sqlite.org/datatype3.html#determination_of_column_affinity

INFO:root:目标函数体: 
    assert isinstance(column_type, str)
    column_type = column_type.upper().strip()
    if column_type == "":
        return str  # We differ from spec, which says it should be BLOB
    if "INT" in column_type:
        return int
    if "CHAR" in column_type or "CLOB" in column_type or "TEXT" in column_type:
        return str
    if "BLOB" in column_type:
        return bytes
    if "REAL" in column_type or "FLOA" in column_type or "DOUB" in column_type:
        return float
    # Default is 'NUMERIC', which we currently also treat as float
    return float

INFO:root:生成结果: 
    if column_type.startswith("INTEGER"):
        return "INT"
    elif column_type.startswith("REAL"):
        return "REAL"
    elif column_type.startswith("TEXT"):
        return "TEXT"
    elif column_type.startswith("BLOB"):
        return "BLOB"
    else:
        return "TEXT"




INFO:root:----------------------------------------
INFO:root:max length: 2605
INFO:root:max position: 2605
INFO:root:target_namespace: sqlite-utils.sqlite_utils<folder>.utils<file>.column_affinity<func>
INFO:root:****************************************

data 106:   0%|          | 0/512 [00:00<?, ?it/s]
data 106:   2%|▏         | 10/512 [00:05<04:11,  2.00it/s]
data 106:   4%|▍         | 20/512 [00:10<04:19,  1.90it/s]
data 106:   6%|▌         | 30/512 [00:15<04:16,  1.88it/s]
data 106:   8%|▊         | 40/512 [00:21<04:14,  1.86it/s]
data 106:  10%|▉         | 50/512 [00:26<04:08,  1.86it/s]
data 106:  12%|█▏        | 60/512 [00:32<04:04,  1.85it/s]
data 106:  14%|█▎        | 70/512 [00:37<03:58,  1.85it/s]
data 106:  16%|█▌        | 80/512 [00:42<03:53,  1.85it/s]
data 106:  18%|█▊        | 90/512 [00:48<03:49,  1.84it/s]
data 106:  20%|█▉        | 100/512 [00:53<03:44,  1.84it/s]
data 106:  21%|██▏       | 110/512 [00:59<03:37,  1.84it/s]
data 106:  21%|██▏       | 110/512 [01:04<03:56,  1.70it/s]
INFO:root:函数头: 
def column_affinity(column_type):
    # Implementation of SQLite affinity rules from
    # https://www.sqlite.org/datatype3.html#determination_of_column_affinity

INFO:root:目标函数体: 
    assert isinstance(column_type, str)
    column_type = column_type.upper().strip()
    if column_type == "":
        return str  # We differ from spec, which says it should be BLOB
    if "INT" in column_type:
        return int
    if "CHAR" in column_type or "CLOB" in column_type or "TEXT" in column_type:
        return str
    if "BLOB" in column_type:
        return bytes
    if "REAL" in column_type or "FLOA" in column_type or "DOUB" in column_type:
        return float
    # Default is 'NUMERIC', which we currently also treat as float
    return float

INFO:root:生成结果: 
    if column_type == "INT":
        return "INT"
    elif column_type == "CHAR":
        return "CHAR"
    elif column_type == "CLOB":
        return "CLOB"
    elif column_type == "TEXT":
        return "TEXT"
    elif column_type == "BLOB":
        return "BLOB"
    elif column_type == "REAL":
        return "REAL"
    elif column_type == "FLOAT":
        return "REAL"
    elif column_type == "DOUB":
        return "REAL"
    else:
        return "TEXT"




INFO:root:----------------------------------------
INFO:root:max length: 2661
INFO:root:max position: 2661
INFO:root:target_namespace: sqlite-utils.sqlite_utils<folder>.utils<file>.column_affinity<func>
INFO:root:****************************************

data 106:   0%|          | 0/512 [00:00<?, ?it/s]
data 106:   2%|▏         | 10/512 [00:04<04:07,  2.03it/s]
data 106:   4%|▍         | 20/512 [00:10<04:16,  1.92it/s]
data 106:   6%|▌         | 30/512 [00:15<04:16,  1.88it/s]
data 106:   8%|▊         | 40/512 [00:21<04:13,  1.86it/s]
data 106:  10%|▉         | 50/512 [00:26<04:09,  1.85it/s]
data 106:  12%|█▏        | 60/512 [00:32<04:03,  1.85it/s]
data 106:  14%|█▎        | 70/512 [00:37<03:58,  1.86it/s]
data 106:  16%|█▌        | 80/512 [00:42<03:53,  1.85it/s]
data 106:  18%|█▊        | 90/512 [00:48<03:49,  1.84it/s]
data 106:  20%|█▉        | 100/512 [00:53<03:43,  1.84it/s]
data 106:  21%|██▏       | 110/512 [00:59<03:37,  1.85it/s]
data 106:  21%|██▏       | 110/512 [01:04<03:55,  1.70it/s]
INFO:root:函数头: 
def column_affinity(column_type):
    # Implementation of SQLite affinity rules from
    # https://www.sqlite.org/datatype3.html#determination_of_column_affinity

INFO:root:目标函数体: 
    assert isinstance(column_type, str)
    column_type = column_type.upper().strip()
    if column_type == "":
        return str  # We differ from spec, which says it should be BLOB
    if "INT" in column_type:
        return int
    if "CHAR" in column_type or "CLOB" in column_type or "TEXT" in column_type:
        return str
    if "BLOB" in column_type:
        return bytes
    if "REAL" in column_type or "FLOA" in column_type or "DOUB" in column_type:
        return float
    # Default is 'NUMERIC', which we currently also treat as float
    return float

INFO:root:生成结果: 
    if column_type.startswith("INT"):
        return "INT"
    elif column_type.startswith("CHAR"):
        return "CHAR"
    elif column_type.startswith("CLOB"):
        return "CLOB"
    elif column_type.startswith("TEXT"):
        return "TEXT"
    elif column_type.startswith("BLOB"):
        return "BLOB"
    elif column_type.startswith("REAL"):
        return "REAL"
    elif column_type.startswith("F FLOAT"):
        return "FLOAT"
    elif column_type.startswith("DOUB"):
        return "DOUBLE"
    else:
        return "TEXT"




INFO:root:----------------------------------------
INFO:root:max length: 2661
INFO:root:max position: 2661
INFO:root:target_namespace: sqlite-utils.sqlite_utils<folder>.utils<file>.column_affinity<func>
INFO:root:****************************************

data 106:   0%|          | 0/512 [00:00<?, ?it/s]
data 106:   2%|▏         | 10/512 [00:04<04:07,  2.03it/s]
data 106:   4%|▍         | 20/512 [00:10<04:16,  1.92it/s]
data 106:   6%|▌         | 30/512 [00:15<04:17,  1.87it/s]
data 106:   8%|▊         | 40/512 [01:21<22:59,  2.92s/it]
data 106:  10%|▉         | 50/512 [01:27<15:53,  2.06s/it]
data 106:  12%|█▏        | 60/512 [01:32<11:45,  1.56s/it]
data 106:  14%|█▎        | 70/512 [01:38<09:02,  1.23s/it]
data 106:  16%|█▌        | 80/512 [01:43<07:16,  1.01s/it]
data 106:  18%|█▊        | 90/512 [01:49<06:04,  1.16it/s]
data 106:  20%|█▉        | 100/512 [01:54<05:15,  1.31it/s]
data 106:  21%|██▏       | 110/512 [02:00<04:39,  1.44it/s]
data 106:  21%|██▏       | 110/512 [02:05<07:38,  1.14s/it]
INFO:root:函数头: 
def column_affinity(column_type):
    # Implementation of SQLite affinity rules from
    # https://www.sqlite.org/datatype3.html#determination_of_column_affinity

INFO:root:目标函数体: 
    assert isinstance(column_type, str)
    column_type = column_type.upper().strip()
    if column_type == "":
        return str  # We differ from spec, which says it should be BLOB
    if "INT" in column_type:
        return int
    if "CHAR" in column_type or "CLOB" in column_type or "TEXT" in column_type:
        return str
    if "BLOB" in column_type:
        return bytes
    if "REAL" in column_type or "FLOA" in column_type or "DOUB" in column_type:
        return float
    # Default is 'NUMERIC', which we currently also treat as float
    return float

INFO:root:生成结果: 
    if column_type.startswith("INT"):
        return "INT"
    elif column_type.startswith("CHAR"):
        return "CHAR"
    elif column_type.startswith("CLOB"):
        return "CLOB"
    elif column_type.startswith("TEXT"):
        return "TEXT"
    elif column_type.startswith("BLOB"):
        return "BLOB"
    elif column_type.startswith("REAL"):
        return "REAL"
    elif column_type.startswith("F FLOAT"):
        return "REAL"
    elif column_type.startswith("DOUB"):
        return "REAL"
    else:
        return "TEXT"




INFO:root:----------------------------------------
INFO:root:max length: 2661
INFO:root:max position: 2661
INFO:root:target_namespace: sqlite-utils.sqlite_utils<folder>.utils<file>.column_affinity<func>
INFO:root:****************************************
INFO:root:--------data 107--------

data 107:   0%|          | 0/512 [00:00<?, ?it/s]
data 107:   2%|▏         | 10/512 [00:06<05:10,  1.62it/s]
data 107:   4%|▍         | 20/512 [00:11<04:51,  1.69it/s]
data 107:   6%|▌         | 30/512 [00:17<04:40,  1.72it/s]
data 107:   8%|▊         | 40/512 [00:23<04:33,  1.72it/s]
data 107:  10%|▉         | 50/512 [00:29<04:26,  1.74it/s]
data 107:  12%|█▏        | 60/512 [00:34<04:20,  1.74it/s]
data 107:  14%|█▎        | 70/512 [00:40<04:13,  1.74it/s]
data 107:  16%|█▌        | 80/512 [00:46<04:06,  1.75it/s]
data 107:  18%|█▊        | 90/512 [00:51<04:01,  1.75it/s]
data 107:  18%|█▊        | 90/512 [00:55<04:20,  1.62it/s]
INFO:root:函数头: 
def decode_base64_values(doc):
    # Looks for '{"$base64": true..., "encoded": ...}' values and decodes them

INFO:root:目标函数体: 
    to_fix = [
        k
        for k in doc
        if isinstance(doc[k], dict)
        and doc[k].get("$base64") is True
        and "encoded" in doc[k]
    ]
    if not to_fix:
        return doc
    return dict(doc, **{k: base64.b64decode(doc[k]["encoded"]) for k in to_fix})

INFO:root:生成结果: 
    for key, value in doc.items():
        if isinstance(value, dict) and "$base64" in value:
            encoded_value = value.get("encoded")
            if encoded_value:
                try:
                    doc[key] = base64.b64decode(encoded_value).decode("utf-16")
                except Exception as e:
                    raise ValueError(f"Error decoding base64 value for key '{key}': {e}")
    return doc




INFO:root:----------------------------------------
INFO:root:max length: 2816
INFO:root:max position: 2816
INFO:root:target_namespace: sqlite-utils.sqlite_utils<folder>.utils<file>.decode_base64_values<func>
INFO:root:****************************************

data 107:   0%|          | 0/512 [00:00<?, ?it/s]
data 107:   2%|▏         | 10/512 [00:05<04:17,  1.95it/s]
data 107:   4%|▍         | 20/512 [00:10<04:28,  1.83it/s]
data 107:   6%|▌         | 30/512 [00:16<04:28,  1.80it/s]
data 107:   8%|▊         | 40/512 [00:22<04:23,  1.79it/s]
data 107:  10%|▉         | 50/512 [00:27<04:19,  1.78it/s]
data 107:  12%|█▏        | 60/512 [00:33<04:15,  1.77it/s]
data 107:  14%|█▎        | 70/512 [00:39<04:11,  1.76it/s]
data 107:  16%|█▌        | 80/512 [00:44<04:05,  1.76it/s]
data 107:  18%|█▊        | 90/512 [00:50<03:59,  1.77it/s]
data 107:  20%|█▉        | 100/512 [00:56<03:54,  1.76it/s]
data 107:  21%|██▏       | 110/512 [01:02<03:50,  1.75it/s]
data 107:  23%|██▎       | 120/512 [01:07<03:44,  1.75it/s]
data 107:  25%|██▌       | 130/512 [01:13<03:39,  1.74it/s]
data 107:  27%|██▋       | 140/512 [01:19<03:33,  1.74it/s]
data 107:  29%|██▉       | 150/512 [01:25<03:27,  1.75it/s]
data 107:  31%|███▏      | 160/512 [01:30<03:22,  1.74it/s]
data 107:  33%|███▎      | 170/512 [01:36<03:17,  1.73it/s]
data 107:  35%|███▌      | 180/512 [01:42<03:12,  1.73it/s]
data 107:  37%|███▋      | 190/512 [01:48<03:05,  1.74it/s]
data 107:  39%|███▉      | 200/512 [01:53<02:58,  1.75it/s]
data 107:  41%|████      | 210/512 [01:59<02:53,  1.74it/s]
data 107:  43%|████▎     | 220/512 [02:05<02:48,  1.74it/s]
data 107:  43%|████▎     | 220/512 [02:05<02:47,  1.75it/s]
INFO:root:函数头: 
def decode_base64_values(doc):
    # Looks for '{"$base64": true..., "encoded": ...}' values and decodes them

INFO:root:目标函数体: 
    to_fix = [
        k
        for k in doc
        if isinstance(doc[k], dict)
        and doc[k].get("$base64") is True
        and "encoded" in doc[k]
    ]
    if not to_fix:
        return doc
    return dict(doc, **{k: base64.b64decode(doc[k]["encoded"]) for k in to_fix})

INFO:root:生成结果: 
    def decode_base64_value(value):
        if isinstance(value, dict) and "$base64" in value:
            encoded_value = value["$base64"]["encoded"]
            decoded_value = base64.b64decode(encoded_value).decode("utf-2")
            return decoded_value
        return value

    doc_copy = doc.copy()
    doc_copy["$base64"] = False  # Reset the "$base64" flag
    doc_copy["$base64_values"] = {}
    doc_copy["$base64_encoded"] = {}

    for key, value in doc_copy.items():
        if isinstance(value, dict) and "$base64" in value:
            doc_copy["$base64"] = True
            doc_copy["$base64_values"][key] = value["$base64"]["encoded"]
            doc_copy["$base64_encoded"][key] = decode_base64_value(value["$base64"]["encoded"])
        else:
            doc_copy[key] = decode_base64_value(value)

    return doc_copy




INFO:root:----------------------------------------
INFO:root:max length: 2941
INFO:root:max position: 2941
INFO:root:target_namespace: sqlite-utils.sqlite_utils<folder>.utils<file>.decode_base64_values<func>
INFO:root:****************************************

data 107:   0%|          | 0/512 [00:00<?, ?it/s]
data 107:   2%|▏         | 10/512 [00:05<04:25,  1.89it/s]
data 107:   4%|▍         | 20/512 [00:11<04:34,  1.79it/s]
data 107:   6%|▌         | 30/512 [00:16<04:31,  1.78it/s]
data 107:   8%|▊         | 40/512 [00:22<04:25,  1.78it/s]
data 107:  10%|▉         | 50/512 [00:28<04:20,  1.77it/s]
data 107:  12%|█▏        | 60/512 [00:33<04:16,  1.76it/s]
data 107:  14%|█▎        | 70/512 [00:39<04:11,  1.76it/s]
data 107:  14%|█▎        | 70/512 [01:43<10:55,  1.48s/it]
INFO:root:函数头: 
def decode_base64_values(doc):
    # Looks for '{"$base64": true..., "encoded": ...}' values and decodes them

INFO:root:目标函数体: 
    to_fix = [
        k
        for k in doc
        if isinstance(doc[k], dict)
        and doc[k].get("$base64") is True
        and "encoded" in doc[k]
    ]
    if not to_fix:
        return doc
    return dict(doc, **{k: base64.b64decode(doc[k]["encoded"]) for k in to_fix})

INFO:root:生成结果: 
    def decode_value(value):
        if isinstance(value, dict) and "$base64" in value:
            encoded_value = value["encoded"]
            decoded_value = base64.b64decode(encoded_value).decode("utf-<|fim_suffix|>        return decoded_value
        return value

    return {k: decode_value(v) for k, v in doc.items}




INFO:root:----------------------------------------
INFO:root:max length: 2797
INFO:root:max position: 2797
INFO:root:target_namespace: sqlite-utils.sqlite_utils<folder>.utils<file>.decode_base64_values<func>
INFO:root:****************************************

data 107:   0%|          | 0/512 [00:00<?, ?it/s]
data 107:   2%|▏         | 10/512 [00:05<04:18,  1.94it/s]
data 107:   4%|▍         | 20/512 [00:10<04:29,  1.83it/s]
data 107:   6%|▌         | 30/512 [00:16<04:28,  1.80it/s]
data 107:   8%|▊         | 40/512 [00:22<04:33,  1.73it/s]
data 107:  10%|▉         | 50/512 [00:28<04:24,  1.75it/s]
data 107:  12%|█▏        | 60/512 [00:33<04:18,  1.75it/s]
data 107:  12%|█▏        | 60/512 [00:39<04:54,  1.54it/s]
INFO:root:函数头: 
def decode_base64_values(doc):
    # Looks for '{"$base64": true..., "encoded": ...}' values and decodes them

INFO:root:目标函数体: 
    to_fix = [
        k
        for k in doc
        if isinstance(doc[k], dict)
        and doc[k].get("$base64") is True
        and "encoded" in doc[k]
    ]
    if not to_fix:
        return doc
    return dict(doc, **{k: base64.b64decode(doc[k]["encoded"]) for k in to_fix})

INFO:root:生成结果: 
    for key, value in doc.items():
        if isinstance(value, dict) and "$base64" in value:
            encoded = value["encoded"]
            decoded = base64.b64decode(encoded).decode("utf-<|fim_suffix|>e.decode("utf-8")
            doc[key] = decoded
    return doc




INFO:root:----------------------------------------
INFO:root:max length: 2789
INFO:root:max position: 2789
INFO:root:target_namespace: sqlite-utils.sqlite_utils<folder>.utils<file>.decode_base64_values<func>
INFO:root:****************************************

data 107:   0%|          | 0/512 [00:00<?, ?it/s]
data 107:   2%|▏         | 10/512 [00:05<04:20,  1.93it/s]
data 107:   4%|▍         | 20/512 [00:10<04:30,  1.82it/s]
data 107:   6%|▌         | 30/512 [00:16<04:28,  1.79it/s]
data 107:   8%|▊         | 40/512 [00:22<04:24,  1.79it/s]
data 107:  10%|▉         | 50/512 [00:27<04:20,  1.78it/s]
data 107:  12%|█▏        | 60/512 [00:33<04:16,  1.76it/s]
data 107:  14%|█▎        | 70/512 [00:39<04:10,  1.76it/s]
data 107:  14%|█▎        | 70/512 [00:40<04:15,  1.73it/s]
INFO:root:函数头: 
def decode_base64_values(doc):
    # Looks for '{"$base64": true..., "encoded": ...}' values and decodes them

INFO:root:目标函数体: 
    to_fix = [
        k
        for k in doc
        if isinstance(doc[k], dict)
        and doc[k].get("$base64") is True
        and "encoded" in doc[k]
    ]
    if not to_fix:
        return doc
    return dict(doc, **{k: base64.b64decode(doc[k]["encoded"]) for k in to_fix})

INFO:root:生成结果: 
    if not doc:
        return doc

    decoded_doc = {}
    for key, value in doc.items():
        if isinstance(value, dict) and "$base64" in value:
            encoded_value = value["encoded"]
            decoded_value = base64.b64decode(encoded_value).decode("utf-<|fim_suffix|>n decoded_doc




INFO:root:----------------------------------------
INFO:root:max length: 2792
INFO:root:max position: 2792
INFO:root:target_namespace: sqlite-utils.sqlite_utils<folder>.utils<file>.decode_base64_values<func>
INFO:root:****************************************
INFO:root:--------data 108--------

data 108:   0%|          | 0/512 [00:00<?, ?it/s]
data 108:   2%|▏         | 10/512 [00:12<10:45,  1.29s/it]
data 108:   4%|▍         | 20/512 [00:30<12:59,  1.59s/it]
data 108:   4%|▍         | 20/512 [00:35<14:41,  1.79s/it]
INFO:root:函数头: 
def chunks(sequence: Iterable, size: int) -> Iterable[Iterable]:

INFO:root:目标函数体: 
    
    iterator = iter(sequence)
    for item in iterator:
        yield itertools.chain([item], itertools.islice(iterator, size - 1))

INFO:root:生成结果: 
    for i in range(0, len(sequence), size):
        yield sequence[i:i + size]




INFO:root:----------------------------------------
INFO:root:max length: 3171
INFO:root:max position: 3887
INFO:root:target_namespace: sqlite-utils.sqlite_utils<folder>.utils<file>.chunks<func>
INFO:root:****************************************

data 108:   0%|          | 0/512 [00:00<?, ?it/s]
data 108:   2%|▏         | 10/512 [00:15<13:18,  1.59s/it]
data 108:   4%|▍         | 20/512 [00:33<13:59,  1.71s/it]
data 108:   4%|▍         | 20/512 [00:38<15:58,  1.95s/it]
INFO:root:函数头: 
def chunks(sequence: Iterable, size: int) -> Iterable[Iterable]:

INFO:root:目标函数体: 
    
    iterator = iter(sequence)
    for item in iterator:
        yield itertools.chain([item], itertools.islice(iterator, size - 1))

INFO:root:生成结果: 
    for i in range(0, len(sequence), size):
        yield sequence[i:i + size]




INFO:root:----------------------------------------
INFO:root:max length: 3144
INFO:root:max position: 3888
INFO:root:target_namespace: sqlite-utils.sqlite_utils<folder>.utils<file>.chunks<func>
INFO:root:****************************************

data 108:   0%|          | 0/512 [00:00<?, ?it/s]
data 108:   2%|▏         | 10/512 [00:15<12:57,  1.55s/it]
data 108:   4%|▍         | 20/512 [00:33<13:40,  1.67s/it]
data 108:   4%|▍         | 20/512 [00:37<15:34,  1.90s/it]
INFO:root:函数头: 
def chunks(sequence: Iterable, size: int) -> Iterable[Iterable]:

INFO:root:目标函数体: 
    
    iterator = iter(sequence)
    for item in iterator:
        yield itertools.chain([item], itertools.islice(iterator, size - 1))

INFO:root:生成结果: 
    for i in range(0, len(sequence), size):
        yield sequence[i:i + size]




INFO:root:----------------------------------------
INFO:root:max length: 3156
INFO:root:max position: 3888
INFO:root:target_namespace: sqlite-utils.sqlite_utils<folder>.utils<file>.chunks<func>
INFO:root:****************************************

data 108:   0%|          | 0/512 [00:00<?, ?it/s]
data 108:   2%|▏         | 10/512 [00:15<12:47,  1.53s/it]
data 108:   4%|▍         | 20/512 [00:32<13:27,  1.64s/it]
data 108:   4%|▍         | 20/512 [00:37<15:19,  1.87s/it]
INFO:root:函数头: 
def chunks(sequence: Iterable, size: int) -> Iterable[Iterable]:

INFO:root:目标函数体: 
    
    iterator = iter(sequence)
    for item in iterator:
        yield itertools.chain([item], itertools.islice(iterator, size - 1))

INFO:root:生成结果: 
    for i in range(0, len(sequence), size):
        yield sequence[i:i + size]




INFO:root:----------------------------------------
INFO:root:max length: 3156
INFO:root:max position: 3888
INFO:root:target_namespace: sqlite-utils.sqlite_utils<folder>.utils<file>.chunks<func>
INFO:root:****************************************

data 108:   0%|          | 0/512 [00:00<?, ?it/s]
data 108:   2%|▏         | 10/512 [00:15<12:56,  1.55s/it]
data 108:   4%|▍         | 20/512 [00:32<13:29,  1.65s/it]
data 108:   4%|▍         | 20/512 [00:37<15:21,  1.87s/it]
INFO:root:函数头: 
def chunks(sequence: Iterable, size: int) -> Iterable[Iterable]:

INFO:root:目标函数体: 
    
    iterator = iter(sequence)
    for item in iterator:
        yield itertools.chain([item], itertools.islice(iterator, size - 1))

INFO:root:生成结果: 
    for i in range(0, len(sequence), size):
        yield sequence[i:i + size]




INFO:root:----------------------------------------
INFO:root:max length: 3156
INFO:root:max position: 3888
INFO:root:target_namespace: sqlite-utils.sqlite_utils<folder>.utils<file>.chunks<func>
INFO:root:****************************************
INFO:root:--------data 109--------

data 109:   0%|          | 0/512 [00:00<?, ?it/s]
data 109:   2%|▏         | 10/512 [00:15<12:43,  1.52s/it]
data 109:   4%|▍         | 20/512 [00:41<17:36,  2.15s/it]
data 109:   6%|▌         | 30/512 [00:58<15:40,  1.95s/it]
data 109:   8%|▊         | 40/512 [01:16<15:02,  1.91s/it]
data 109:  10%|▉         | 50/512 [01:33<14:01,  1.82s/it]
data 109:  10%|▉         | 50/512 [01:38<15:08,  1.97s/it]
INFO:root:函数头: 
def hash_record(record: Dict, keys: Optional[Iterable[str]] = None):

INFO:root:目标函数体: 
    
    to_hash = record
    if keys is not None:
        to_hash = {key: record[key] for key in keys}
    return hashlib.sha1(
        json.dumps(to_hash, separators=(",", ":"), sort_keys=True, default=repr).encode(
            "utf8"
        )
    ).hexdigest()

INFO:root:生成结果: 
    import hashlib

    if keys is None:
        keys = record.keys()
    hash_object = hashlib.sha1()
    for key in keys:
        hash_object.update(str(record[key]).encode("utf-8"))
    return hash_object.hexdigest()


INFO:root:----------------------------------------
INFO:root:max length: 3453
INFO:root:max position: 3946
INFO:root:target_namespace: sqlite-utils.sqlite_utils<folder>.utils<file>.hash_record<func>
INFO:root:****************************************

data 109:   0%|          | 0/512 [00:00<?, ?it/s]
data 109:   2%|▏         | 10/512 [00:15<13:00,  1.55s/it]
data 109:   4%|▍         | 20/512 [00:32<13:21,  1.63s/it]
data 109:   6%|▌         | 30/512 [00:49<13:20,  1.66s/it]
data 109:   8%|▊         | 40/512 [01:07<13:34,  1.72s/it]
data 109:  10%|▉         | 50/512 [01:24<13:04,  1.70s/it]
data 109:  10%|▉         | 50/512 [01:29<13:43,  1.78s/it]
INFO:root:函数头: 
def hash_record(record: Dict, keys: Optional[Iterable[str]] = None):

INFO:root:目标函数体: 
    
    to_hash = record
    if keys is not None:
        to_hash = {key: record[key] for key in keys}
    return hashlib.sha1(
        json.dumps(to_hash, separators=(",", ":"), sort_keys=True, default=repr).encode(
            "utf8"
        )
    ).hexdigest()

INFO:root:生成结果: 
    import hashlib

    if keys is None:
        keys = record.keys()
    hash_object = hashlib.sha1()
    for key in keys:
        hash_object.update(str(record[key]).encode("utf-8"))
    return hash_object.hexdigest()




INFO:root:----------------------------------------
INFO:root:max length: 3453
INFO:root:max position: 3945
INFO:root:target_namespace: sqlite-utils.sqlite_utils<folder>.utils<file>.hash_record<func>
INFO:root:****************************************

data 109:   0%|          | 0/512 [00:00<?, ?it/s]
data 109:   2%|▏         | 10/512 [00:15<13:16,  1.59s/it]
data 109:   4%|▍         | 20/512 [00:32<13:24,  1.64s/it]
data 109:   6%|▌         | 30/512 [00:50<13:48,  1.72s/it]
data 109:   8%|▊         | 40/512 [01:08<13:41,  1.74s/it]
data 109:  10%|▉         | 50/512 [01:25<13:20,  1.73s/it]
data 109:  10%|▉         | 50/512 [01:28<13:41,  1.78s/it]
INFO:root:函数头: 
def hash_record(record: Dict, keys: Optional[Iterable[str]] = None):

INFO:root:目标函数体: 
    
    to_hash = record
    if keys is not None:
        to_hash = {key: record[key] for key in keys}
    return hashlib.sha1(
        json.dumps(to_hash, separators=(",", ":"), sort_keys=True, default=repr).encode(
            "utf8"
        )
    ).hexdigest()

INFO:root:生成结果: 
    import hashlib
    import json

    if keys is None:
        keys = record.keys()

    record_json = json.dumps(record, sort_keys=True)
    hash_object = hashlib.sha1(record_json.encode())
    return hash_object.hexdigest()




INFO:root:----------------------------------------
INFO:root:max length: 3510
INFO:root:max position: 3944
INFO:root:target_namespace: sqlite-utils.sqlite_utils<folder>.utils<file>.hash_record<func>
INFO:root:****************************************

data 109:   0%|          | 0/512 [00:00<?, ?it/s]
data 109:   2%|▏         | 10/512 [00:15<12:50,  1.54s/it]
data 109:   4%|▍         | 20/512 [00:32<13:17,  1.62s/it]
data 109:   6%|▌         | 30/512 [00:49<13:28,  1.68s/it]
data 109:   8%|▊         | 40/512 [01:15<16:05,  2.05s/it]
data 109:  10%|▉         | 50/512 [01:33<14:53,  1.93s/it]
data 109:  10%|▉         | 50/512 [01:38<15:08,  1.97s/it]
INFO:root:函数头: 
def hash_record(record: Dict, keys: Optional[Iterable[str]] = None):

INFO:root:目标函数体: 
    
    to_hash = record
    if keys is not None:
        to_hash = {key: record[key] for key in keys}
    return hashlib.sha1(
        json.dumps(to_hash, separators=(",", ":"), sort_keys=True, default=repr).encode(
            "utf8"
        )
    ).hexdigest()

INFO:root:生成结果: 
    import hashlib

    if keys is None:
        keys = record.keys()

    hash_obj = hashlib.sha1()
    for key in keys:
        hash_obj.update(str(record[key]).encode("utf-8"))
    return hash_obj.hexdigest()




INFO:root:----------------------------------------
INFO:root:max length: 3448
INFO:root:max position: 3945
INFO:root:target_namespace: sqlite-utils.sqlite_utils<folder>.utils<file>.hash_record<func>
INFO:root:****************************************

data 109:   0%|          | 0/512 [00:00<?, ?it/s]
data 109:   2%|▏         | 10/512 [00:15<13:06,  1.57s/it]
data 109:   4%|▍         | 20/512 [00:32<13:21,  1.63s/it]
data 109:   6%|▌         | 30/512 [00:50<13:38,  1.70s/it]
data 109:   8%|▊         | 40/512 [01:07<13:33,  1.72s/it]
data 109:   8%|▊         | 40/512 [01:23<16:21,  2.08s/it]
INFO:root:函数头: 
def hash_record(record: Dict, keys: Optional[Iterable[str]] = None):

INFO:root:目标函数体: 
    
    to_hash = record
    if keys is not None:
        to_hash = {key: record[key] for key in keys}
    return hashlib.sha1(
        json.dumps(to_hash, separators=(",", ":"), sort_keys=True, default=repr).encode(
            "utf8"
        )
    ).hexdigest()

INFO:root:生成结果: 
    import hashlib

    if keys is None:
        keys = record.keys()
    hasher = hashlib.sha1()
    for key in keys:
        hasher.update(record[key].encode("utf-8"))
    return hasher.hexdigest()




INFO:root:----------------------------------------
INFO:root:max length: 3420
INFO:root:max position: 3942
INFO:root:target_namespace: sqlite-utils.sqlite_utils<folder>.utils<file>.hash_record<func>
INFO:root:****************************************
INFO:root:--------data 110--------

data 110:   0%|          | 0/512 [00:00<?, ?it/s]
data 110:   2%|▏         | 10/512 [00:37<31:16,  3.74s/it]
data 110:   4%|▍         | 20/512 [01:19<32:56,  4.02s/it]
data 110:   6%|▌         | 30/512 [02:01<33:03,  4.12s/it]
data 110:   8%|▊         | 40/512 [02:42<32:19,  4.11s/it]
data 110:  10%|▉         | 50/512 [03:31<33:41,  4.38s/it]
data 110:  12%|█▏        | 60/512 [04:12<32:17,  4.29s/it]
data 110:  14%|█▎        | 70/512 [04:51<30:34,  4.15s/it]
data 110:  14%|█▎        | 70/512 [05:26<34:24,  4.67s/it]
INFO:root:函数头: 
def _get_host(store):

INFO:root:目标函数体: 
    ret = {}
    if store:
        try:
            if isinstance(store, (list, tuple)):
                store = store[0]
            ret['l'] = store._arctic_lib.get_name()
            ret['mnodes'] = ["{}:{}".format(h, p) for h, p in store._collection.database.client.nodes]
            ret['mhost'] = "{}".format(store._arctic_lib.arctic.mongo_host)
        except Exception:
            # Sometimes get_name(), for example, fails if we're not connected to MongoDB.
            pass
    return ret

INFO:root:生成结果: 
    if store:
        store_list = store.list_libraries()
        if store_list:
            store_name = store_list[0]
            mongo_nodes = store[store_name].list_collections()
            mongo_host = store[store_name].connection.host
            return {'store_name': store_name, 'mongo_nodes': mongo_nodes, 'mongo_host': mongo_host}
    return {}




INFO:root:----------------------------------------
INFO:root:max length: 8099
INFO:root:max position: 10541
INFO:root:target_namespace: arctic-latest.arctic<folder>.decorators<file>._get_host<func>
INFO:root:****************************************

data 110:   0%|          | 0/512 [00:00<?, ?it/s]
data 110:   2%|▏         | 10/512 [00:35<29:44,  3.55s/it]
data 110:   4%|▍         | 20/512 [01:14<30:49,  3.76s/it]
data 110:   6%|▌         | 30/512 [01:54<31:05,  3.87s/it]
data 110:   8%|▊         | 40/512 [02:35<31:06,  3.95s/it]
data 110:  10%|▉         | 50/512 [03:19<31:41,  4.11s/it]
data 110:  12%|█▏        | 60/512 [03:58<30:21,  4.03s/it]
data 110:  14%|█▎        | 70/512 [04:36<29:08,  3.96s/it]
data 110:  14%|█▎        | 70/512 [04:51<30:42,  4.17s/it]
INFO:root:函数头: 
def _get_host(store):

INFO:root:目标函数体: 
    ret = {}
    if store:
        try:
            if isinstance(store, (list, tuple)):
                store = store[0]
            ret['l'] = store._arctic_lib.get_name()
            ret['mnodes'] = ["{}:{}".format(h, p) for h, p in store._collection.database.client.nodes]
            ret['mhost'] = "{}".format(store._arctic_lib.arctic.mongo_host)
        except Exception:
            # Sometimes get_name(), for example, fails if we're not connected to MongoDB.
            pass
    return ret

INFO:root:生成结果: 
    if store:
        if isinstance(store, (list, tuple)):
            store = store[0]
        library_name = store['username.scratch']
        mongo_nodes = store['mongo_nodes']
        mongo_host = store['mongo_host']
        return {'library_name': library_name, 'mongo_nodes': mongo_nodes, 'mongo_host': mongo_host}


INFO:root:----------------------------------------
INFO:root:max length: 7665
INFO:root:max position: 10311
INFO:root:target_namespace: arctic-latest.arctic<folder>.decorators<file>._get_host<func>
INFO:root:****************************************

data 110:   0%|          | 0/512 [00:00<?, ?it/s]
data 110:   2%|▏         | 10/512 [00:35<29:42,  3.55s/it]
data 110:   4%|▍         | 20/512 [01:15<31:03,  3.79s/it]
data 110:   6%|▌         | 30/512 [01:54<30:55,  3.85s/it]
data 110:   8%|▊         | 40/512 [02:34<30:46,  3.91s/it]
data 110:  10%|▉         | 50/512 [03:14<30:29,  3.96s/it]
data 110:  12%|█▏        | 60/512 [04:05<32:39,  4.34s/it]
data 110:  14%|█▎        | 70/512 [04:44<30:53,  4.19s/it]
data 110:  14%|█▎        | 70/512 [05:00<31:36,  4.29s/it]
INFO:root:函数头: 
def _get_host(store):

INFO:root:目标函数体: 
    ret = {}
    if store:
        try:
            if isinstance(store, (list, tuple)):
                store = store[0]
            ret['l'] = store._arctic_lib.get_name()
            ret['mnodes'] = ["{}:{}".format(h, p) for h, p in store._collection.database.client.nodes]
            ret['mhost'] = "{}".format(store._arctic_lib.arctic.mongo_host)
        except Exception:
            # Sometimes get_name(), for example, fails if we're not connected to MongoDB.
            pass
    return ret

INFO:root:生成结果: 
    if store:
        if isinstance(store, (list, tuple)):
            store = store[0]
        library_name = store['username.scratch']
        mongo_nodes = store['mongo_nodes']
        mongo_host = store['mongo_host']
        return {'library_name': library_name, 'mongo_nodes': mongo_nodes, 'mongo_host': mongo_host}


INFO:root:----------------------------------------
INFO:root:max length: 7302
INFO:root:max position: 10237
INFO:root:target_namespace: arctic-latest.arctic<folder>.decorators<file>._get_host<func>
INFO:root:****************************************

data 110:   0%|          | 0/512 [00:00<?, ?it/s]
data 110:   2%|▏         | 10/512 [00:37<31:30,  3.77s/it]
data 110:   4%|▍         | 20/512 [01:19<32:45,  4.00s/it]
data 110:   6%|▌         | 30/512 [01:58<31:59,  3.98s/it]
data 110:   8%|▊         | 40/512 [02:40<31:56,  4.06s/it]
data 110:  10%|▉         | 50/512 [03:22<31:38,  4.11s/it]
data 110:  12%|█▏        | 60/512 [04:05<31:23,  4.17s/it]
data 110:  14%|█▎        | 70/512 [04:45<30:24,  4.13s/it]
data 110:  16%|█▌        | 80/512 [05:36<31:49,  4.42s/it]
data 110:  18%|█▊        | 90/512 [06:16<30:16,  4.30s/it]
data 110:  20%|█▉        | 100/512 [06:56<28:52,  4.21s/it]
data 110:  21%|██▏       | 110/512 [07:37<27:50,  4.16s/it]
data 110:  23%|██▎       | 120/512 [08:16<26:40,  4.08s/it]
data 110:  25%|██▌       | 130/512 [08:57<26:05,  4.10s/it]
data 110:  25%|██▌       | 130/512 [09:05<26:44,  4.20s/it]
INFO:root:函数头: 
def _get_host(store):

INFO:root:目标函数体: 
    ret = {}
    if store:
        try:
            if isinstance(store, (list, tuple)):
                store = store[0]
            ret['l'] = store._arctic_lib.get_name()
            ret['mnodes'] = ["{}:{}".format(h, p) for h, p in store._collection.database.client.nodes]
            ret['mhost'] = "{}".format(store._arctic_lib.arctic.mongo_host)
        except Exception:
            # Sometimes get_name(), for example, fails if we're not connected to MongoDB.
            pass
    return ret

INFO:root:生成结果: 
    if store:
        if isinstance(store, (list, tuple)):
            store = store[0]
        # Get the library name from the store object
        library_name = store['username.scratch']
        # Get the MongoDB nodes from the store object
        mongo_nodes = store['mongo_nodes']
        # Get the MongoDB host from the store object
        mongo_host = store['mongo_host']
        # Return a dictionary containing the host information
        return {'library_name': library_name, 'mongo_nodes': mongo_nodes, 'mongo_host': mongo_host}
    else:
        logger.error("Store object is empty")
        return {}


INFO:root:----------------------------------------
INFO:root:max length: 8736
INFO:root:max position: 10508
INFO:root:target_namespace: arctic-latest.arctic<folder>.decorators<file>._get_host<func>
INFO:root:****************************************

data 110:   0%|          | 0/512 [00:00<?, ?it/s]
data 110:   2%|▏         | 10/512 [00:39<32:58,  3.94s/it]
data 110:   4%|▍         | 20/512 [01:20<33:19,  4.06s/it]
data 110:   6%|▌         | 30/512 [01:59<31:49,  3.96s/it]
data 110:   8%|▊         | 40/512 [02:40<31:37,  4.02s/it]
data 110:  10%|▉         | 50/512 [03:32<34:11,  4.44s/it]
data 110:  12%|█▏        | 60/512 [04:12<32:27,  4.31s/it]
data 110:  14%|█▎        | 70/512 [04:59<32:36,  4.43s/it]
data 110:  16%|█▌        | 80/512 [05:40<31:03,  4.31s/it]
data 110:  16%|█▌        | 80/512 [06:15<33:48,  4.70s/it]
INFO:root:函数头: 
def _get_host(store):

INFO:root:目标函数体: 
    ret = {}
    if store:
        try:
            if isinstance(store, (list, tuple)):
                store = store[0]
            ret['l'] = store._arctic_lib.get_name()
            ret['mnodes'] = ["{}:{}".format(h, p) for h, p in store._collection.database.client.nodes]
            ret['mhost'] = "{}".format(store._arctic_lib.arctic.mongo_host)
        except Exception:
            # Sometimes get_name(), for example, fails if we're not connected to MongoDB.
            pass
    return ret

INFO:root:生成结果: 
    if store:
        if isinstance(store, (list, tuple)):
            store = store[0]
        library = store['username.scratch']
        mongo_nodes = [node['host'] + ':' + str(node['port']) for node in library['nodes']]
        mongo_host = library['mongo_host']
        return {'library_name': library['name'], 'mongo_nodes': mongo_nodes, 'mongo_host': mongo_host}


INFO:root:----------------------------------------
INFO:root:max length: 7617
INFO:root:max position: 10646
INFO:root:target_namespace: arctic-latest.arctic<folder>.decorators<file>._get_host<func>
INFO:root:****************************************
INFO:root:--------data 111--------

data 111:   0%|          | 0/512 [00:00<?, ?it/s]
data 111:   2%|▏         | 10/512 [00:38<31:54,  3.81s/it]
data 111:   4%|▍         | 20/512 [01:19<32:37,  3.98s/it]
data 111:   6%|▌         | 30/512 [01:58<31:52,  3.97s/it]
data 111:   8%|▊         | 40/512 [02:40<31:45,  4.04s/it]
data 111:  10%|▉         | 50/512 [04:52<56:35,  7.35s/it]
data 111:  12%|█▏        | 60/512 [05:34<47:15,  6.27s/it]
data 111:  14%|█▎        | 70/512 [06:15<41:04,  5.58s/it]
data 111:  16%|█▌        | 80/512 [06:57<36:53,  5.12s/it]
data 111:  18%|█▊        | 90/512 [07:40<34:16,  4.87s/it]
data 111:  20%|█▉        | 100/512 [08:21<31:51,  4.64s/it]
data 111:  21%|██▏       | 110/512 [10:09<43:43,  6.53s/it]
data 111:  23%|██▎       | 120/512 [10:47<37:12,  5.69s/it]
data 111:  25%|██▌       | 130/512 [11:28<33:12,  5.22s/it]
data 111:  27%|██▋       | 140/512 [12:06<29:40,  4.79s/it]
data 111:  27%|██▋       | 140/512 [12:43<33:48,  5.45s/it]
INFO:root:函数头: 
def mongo_retry(f):

INFO:root:目标函数体: 
    
    log_all_exceptions = 'arctic' in f.__module__ if f.__module__ else False

    @wraps(f)
    def f_retry(*args, **kwargs):
        # Omit body code
    return f_retry

INFO:root:生成结果: 
    @wraps(f)
    def decorated_function(*args, **kwargs):
        global _in_retry
        global _retry_count
        _in_retry = True
        _retry_count += 1
        try:
            return f(*args, **kwargs)
        except (OperationFailure, AutoReconnect) as e:
            logger.error("MongoDB operation failed: %s", e)
            if _retry_count >= _MAX_RETRIES:
                logger.error("Max retries reached. Giving up.")
                raise e
            sleep(2 ** _retry_count)
            _retry_count -= 1
            _in_retry = False
            return decorated_function(*args, **kwargs)
    return decorated_function




INFO:root:----------------------------------------
INFO:root:max length: 8600
INFO:root:max position: 11169
INFO:root:target_namespace: arctic-latest.arctic<folder>.decorators<file>.mongo_retry<func>
INFO:root:****************************************

data 111:   0%|          | 0/512 [00:00<?, ?it/s]
data 111:   2%|▏         | 10/512 [00:36<30:21,  3.63s/it]
data 111:   4%|▍         | 20/512 [01:23<35:13,  4.30s/it]
data 111:   6%|▌         | 30/512 [02:58<53:23,  6.65s/it]
data 111:   8%|▊         | 40/512 [03:37<43:47,  5.57s/it]
data 111:  10%|▉         | 50/512 [04:19<39:10,  5.09s/it]
data 111:  12%|█▏        | 60/512 [05:00<35:47,  4.75s/it]
data 111:  14%|█▎        | 70/512 [05:42<33:41,  4.57s/it]
data 111:  16%|█▌        | 80/512 [06:23<31:48,  4.42s/it]
data 111:  18%|█▊        | 90/512 [08:09<44:40,  6.35s/it]
data 111:  20%|█▉        | 100/512 [08:50<38:49,  5.65s/it]
data 111:  21%|██▏       | 110/512 [09:32<34:48,  5.20s/it]
data 111:  23%|██▎       | 120/512 [10:10<31:09,  4.77s/it]
data 111:  25%|██▌       | 130/512 [10:48<28:35,  4.49s/it]
data 111:  27%|██▋       | 140/512 [11:31<27:25,  4.42s/it]
data 111:  27%|██▋       | 140/512 [12:09<32:17,  5.21s/it]
INFO:root:函数头: 
def mongo_retry(f):

INFO:root:目标函数体: 
    
    log_all_exceptions = 'arctic' in f.__module__ if f.__module__ else False

    @wraps(f)
    def f_retry(*args, **kwargs):
        # Omit body code
    return f_retry

INFO:root:生成结果: 
    @wraps(f)
    def wrapper(*args, **kwargs):
        global _in_retry
        global _retry_count
        _retry_count += 1
        _in_retry = True
        try:
            return f(*args, **kwargs)
        except (OperationFailure, AutoReconnect) as e:
            logger.debug("Mongo operation failed: %s", e)
            if _retry_count >= _MAX_RETRIES:
                logger.error("Max retries reached for operation: %s", e)
                raise e
            sleep(2 ** _retry_count)
            _retry_count -= 1
            _in_retry = False
            return wrapper(*args, **kwargs)
    return wrapper


INFO:root:----------------------------------------
INFO:root:max length: 8028
INFO:root:max position: 10866
INFO:root:target_namespace: arctic-latest.arctic<folder>.decorators<file>.mongo_retry<func>
INFO:root:****************************************

data 111:   0%|          | 0/512 [00:00<?, ?it/s]
data 111:   2%|▏         | 10/512 [00:33<28:20,  3.39s/it]
data 111:   4%|▍         | 20/512 [01:13<30:25,  3.71s/it]
data 111:   6%|▌         | 30/512 [02:57<54:32,  6.79s/it]
data 111:   8%|▊         | 40/512 [03:40<45:27,  5.78s/it]
data 111:  10%|▉         | 50/512 [04:22<40:10,  5.22s/it]
data 111:  12%|█▏        | 60/512 [05:02<36:11,  4.80s/it]
data 111:  14%|█▎        | 70/512 [05:44<34:05,  4.63s/it]
data 111:  16%|█▌        | 80/512 [06:24<31:47,  4.41s/it]
data 111:  18%|█▊        | 90/512 [07:04<30:11,  4.29s/it]
data 111:  20%|█▉        | 100/512 [07:45<28:59,  4.22s/it]
data 111:  21%|██▏       | 110/512 [08:25<27:49,  4.15s/it]
data 111:  23%|██▎       | 120/512 [09:05<26:56,  4.12s/it]
data 111:  25%|██▌       | 130/512 [09:45<25:52,  4.06s/it]
data 111:  27%|██▋       | 140/512 [10:27<25:25,  4.10s/it]
data 111:  27%|██▋       | 140/512 [10:56<29:05,  4.69s/it]
INFO:root:函数头: 
def mongo_retry(f):

INFO:root:目标函数体: 
    
    log_all_exceptions = 'arctic' in f.__module__ if f.__module__ else False

    @wraps(f)
    def f_retry(*args, **kwargs):
        # Omit body code
    return f_retry

INFO:root:生成结果: 
    @wraps(f)
    def wrapper(*args, **kwargs):
        global _in_retry
        global _retry_count
        _in_retry = True
        _retry_count += 1
        try:
            return f(*args, **kwargs)
        except (AutoReconnect, OperationFailure) as e:
            logger.debug("Retrying operation due to MongoDB error: %s", e)
            sleep(1)  # Wait for a second before retrying
            if _retry_count > _MAX_RETRIES:
                logger.error("Max retries reached for operation")
                raise e
        finally:
            _in_retry = False
            _retry_count = 0
    return wrapper




INFO:root:----------------------------------------
INFO:root:max length: 8085
INFO:root:max position: 10889
INFO:root:target_namespace: arctic-latest.arctic<folder>.decorators<file>.mongo_retry<func>
INFO:root:****************************************

data 111:   0%|          | 0/512 [00:00<?, ?it/s]
data 111:   2%|▏         | 10/512 [00:36<30:37,  3.66s/it]
data 111:   4%|▍         | 20/512 [01:12<29:47,  3.63s/it]
data 111:   6%|▌         | 30/512 [01:48<28:59,  3.61s/it]
data 111:   8%|▊         | 40/512 [03:56<56:48,  7.22s/it]
data 111:  10%|▉         | 50/512 [05:39<1:04:20,  8.36s/it]
data 111:  12%|█▏        | 60/512 [06:18<51:22,  6.82s/it]  
data 111:  14%|█▎        | 70/512 [06:57<43:15,  5.87s/it]
data 111:  16%|█▌        | 80/512 [07:40<38:37,  5.36s/it]
data 111:  18%|█▊        | 90/512 [08:20<34:49,  4.95s/it]
data 111:  20%|█▉        | 100/512 [09:01<32:07,  4.68s/it]
data 111:  21%|██▏       | 110/512 [09:40<29:45,  4.44s/it]
data 111:  23%|██▎       | 120/512 [10:20<28:06,  4.30s/it]
data 111:  25%|██▌       | 130/512 [11:01<27:00,  4.24s/it]
data 111:  27%|██▋       | 140/512 [11:43<26:11,  4.23s/it]
data 111:  29%|██▉       | 150/512 [12:24<25:23,  4.21s/it]
data 111:  31%|███▏      | 160/512 [13:07<24:45,  4.22s/it]
data 111:  33%|███▎      | 170/512 [13:46<23:34,  4.14s/it]
data 111:  35%|███▌      | 180/512 [14:25<22:31,  4.07s/it]
data 111:  37%|███▋      | 190/512 [15:06<21:54,  4.08s/it]
data 111:  37%|███▋      | 190/512 [15:22<26:02,  4.85s/it]
INFO:root:函数头: 
def mongo_retry(f):

INFO:root:目标函数体: 
    
    log_all_exceptions = 'arctic' in f.__module__ if f.__module__ else False

    @wraps(f)
    def f_retry(*args, **kwargs):
        # Omit body code
    return f_retry

INFO:root:生成结果: 
    @wraps(f)
    def decorated_function(*args, **kwargs):
        global _retry_count, _in_retry
        _retry_count += 1
        _in_retry = True
        try:
            return f(*args, **kwargs)
        except (OperationFailure, AutoReconnect) as e:
            if 'arctic' in sys.modules:
                logger.error("Mongo operation failed: %s", e)
            else:
                logger.error("Mongo operation failed: %s", e)
            if _retry_count >= _MAX_RETRIES:
                logger.error("Maximum retries reached. Aborting operation.")
                raise e
            sleep(2 ** (_retry_count - 1))
            _retry_count -= 1
            _in_retry = False
            return decorated_function(*args, **kwargs)
        finally:
            _retry_count -= 1
            _in_retry = False
    return decorated_function




INFO:root:----------------------------------------
INFO:root:max length: 8183
INFO:root:max position: 10821
INFO:root:target_namespace: arctic-latest.arctic<folder>.decorators<file>.mongo_retry<func>
INFO:root:****************************************

data 111:   0%|          | 0/512 [00:00<?, ?it/s]
data 111:   2%|▏         | 10/512 [00:37<31:04,  3.71s/it]
data 111:   4%|▍         | 20/512 [01:16<31:38,  3.86s/it]
data 111:   6%|▌         | 30/512 [01:54<30:43,  3.82s/it]
data 111:   8%|▊         | 40/512 [02:34<30:34,  3.89s/it]
data 111:  10%|▉         | 50/512 [03:17<31:11,  4.05s/it]
data 111:  12%|█▏        | 60/512 [03:59<30:52,  4.10s/it]
data 111:  14%|█▎        | 70/512 [04:40<30:01,  4.08s/it]
data 111:  16%|█▌        | 80/512 [05:20<29:23,  4.08s/it]
data 111:  18%|█▊        | 90/512 [06:00<28:23,  4.04s/it]
data 111:  20%|█▉        | 100/512 [06:41<27:50,  4.05s/it]
data 111:  21%|██▏       | 110/512 [07:20<26:58,  4.03s/it]
data 111:  23%|██▎       | 120/512 [08:01<26:20,  4.03s/it]
data 111:  25%|██▌       | 130/512 [08:44<26:16,  4.13s/it]
data 111:  27%|██▋       | 140/512 [09:25<25:26,  4.10s/it]
data 111:  29%|██▉       | 150/512 [10:05<24:31,  4.06s/it]
data 111:  31%|███▏      | 160/512 [10:46<23:59,  4.09s/it]
data 111:  33%|███▎      | 170/512 [11:25<23:00,  4.04s/it]
data 111:  35%|███▌      | 180/512 [12:06<22:22,  4.04s/it]
data 111:  37%|███▋      | 190/512 [12:47<21:46,  4.06s/it]
data 111:  39%|███▉      | 200/512 [13:29<21:21,  4.11s/it]
data 111:  41%|████      | 210/512 [14:10<20:36,  4.10s/it]
data 111:  43%|████▎     | 220/512 [14:51<19:59,  4.11s/it]
data 111:  45%|████▍     | 230/512 [15:30<19:03,  4.06s/it]
data 111:  47%|████▋     | 240/512 [16:10<18:12,  4.02s/it]
data 111:  47%|████▋     | 240/512 [16:18<18:28,  4.08s/it]
INFO:root:函数头: 
def mongo_retry(f):

INFO:root:目标函数体: 
    
    log_all_exceptions = 'arctic' in f.__module__ if f.__module__ else False

    @wraps(f)
    def f_retry(*args, **kwargs):
        # Omit body code
    return f_retry

INFO:root:生成结果: 
    @wraps(f)
    def wrapper(*args, **kwargs):
        global _retry_count, _in_retry
        _retry_count += 1
        _in_retry = True
        try:
            return f(*args, **kwargs)
        except OperationFailure as e:
            if 'connection timed out' in str(e):
                logging.warning("Mongo connection timed out. Retrying...")
                sleep(1)
                _retry_count -= 1
                return wrapper(*args, **kwargs)
            elif 'duplicate key' in str(e):
                logging.warning("Duplicate key error. Retrying...")
                sleep(1)
                _retry_count -= 1
                return wrapper(*args, **kwargs)
            else:
                logging.error("OperationFailure occurred: %s", e)
                _retry_count -= 1
                raise
        except AutoReconnect as e:
            logging.warning("AutoReconnect occurred: %s", e)
            sleep(1)
            _retry_count -= 1
            return wrapper(*args, **kwargs)
        finally:
            _retry_count -= 1
            _in_retry = False
    return wrapper




INFO:root:----------------------------------------
INFO:root:max length: 8356
INFO:root:max position: 10892
INFO:root:target_namespace: arctic-latest.arctic<folder>.decorators<file>.mongo_retry<func>
INFO:root:****************************************
INFO:root:已生成111条结果
INFO:root:--------data 112--------

data 112:   0%|          | 0/512 [00:00<?, ?it/s]
data 112:   2%|▏         | 10/512 [00:43<36:09,  4.32s/it]
data 112:   4%|▍         | 20/512 [01:27<36:07,  4.41s/it]
data 112:   6%|▌         | 30/512 [02:10<34:59,  4.36s/it]
data 112:   8%|▊         | 40/512 [02:52<33:47,  4.30s/it]
data 112:  10%|▉         | 50/512 [03:35<33:00,  4.29s/it]
data 112:  12%|█▏        | 60/512 [04:16<31:50,  4.23s/it]
data 112:  12%|█▏        | 60/512 [04:46<35:55,  4.77s/it]
INFO:root:函数头: 
def are_equals(o1, o2, **kwargs):

INFO:root:目标函数体: 
    try:
        if isinstance(o1, DataFrame):
            assert_frame_equal(o1, o2, kwargs)
            return True
        return o1 == o2
    except Exception:
        return False

INFO:root:生成结果: 
    try:
        if isinstance(o1, DataFrame) and isinstance(o2, DataFrame):
            return assert_frame_equal(o1, o2, **kwargs)
        else:
            return o1 == o2
    except Exception as e:
        logging.debug("Comparison failed: %s", e)
        return False




INFO:root:----------------------------------------
INFO:root:max length: 8603
INFO:root:max position: 10875
INFO:root:target_namespace: arctic-latest.arctic<folder>._util<file>.are_equals<func>
INFO:root:****************************************

data 112:   0%|          | 0/512 [00:00<?, ?it/s]
data 112:   2%|▏         | 10/512 [00:37<30:58,  3.70s/it]
data 112:   4%|▍         | 20/512 [01:20<33:22,  4.07s/it]
data 112:   6%|▌         | 30/512 [02:02<33:15,  4.14s/it]
data 112:   8%|▊         | 40/512 [02:45<32:59,  4.19s/it]
data 112:  10%|▉         | 50/512 [03:27<32:25,  4.21s/it]
data 112:  12%|█▏        | 60/512 [04:09<31:41,  4.21s/it]
data 112:  12%|█▏        | 60/512 [04:42<35:25,  4.70s/it]
INFO:root:函数头: 
def are_equals(o1, o2, **kwargs):

INFO:root:目标函数体: 
    try:
        if isinstance(o1, DataFrame):
            assert_frame_equal(o1, o2, kwargs)
            return True
        return o1 == o2
    except Exception:
        return False

INFO:root:生成结果: 
    try:
        if isinstance(o1, pd.DataFrame) and isinstance(o2, pd.DataFrame):
            return assert_frame_equal(o1, o2, **kwargs)
        else:
            return o1 == o2
    except Exception as e:
        logger.error(f"Comparison failed: {e}")
        return False




INFO:root:----------------------------------------
INFO:root:max length: 8241
INFO:root:max position: 10710
INFO:root:target_namespace: arctic-latest.arctic<folder>._util<file>.are_equals<func>
INFO:root:****************************************

data 112:   0%|          | 0/512 [00:00<?, ?it/s]
data 112:   2%|▏         | 10/512 [00:37<31:20,  3.75s/it]
data 112:   4%|▍         | 20/512 [01:20<33:23,  4.07s/it]
data 112:   6%|▌         | 30/512 [02:01<32:58,  4.10s/it]
data 112:   8%|▊         | 40/512 [02:45<33:12,  4.22s/it]
data 112:  10%|▉         | 50/512 [03:29<32:52,  4.27s/it]
data 112:  12%|█▏        | 60/512 [04:11<32:04,  4.26s/it]
data 112:  12%|█▏        | 60/512 [04:23<33:04,  4.39s/it]
INFO:root:函数头: 
def are_equals(o1, o2, **kwargs):

INFO:root:目标函数体: 
    try:
        if isinstance(o1, DataFrame):
            assert_frame_equal(o1, o2, kwargs)
            return True
        return o1 == o2
    except Exception:
        return False

INFO:root:生成结果: 
    try:
        if isinstance(o1, DataFrame) and isinstance(o2, DataFrame):
            return assert_frame_equal(o1, o2, **kwargs)
        return o1 == o2
    except Exception as e:
        logger.error(f"Comparison failed: {e}")
        return False




INFO:root:----------------------------------------
INFO:root:max length: 7953
INFO:root:max position: 10818
INFO:root:target_namespace: arctic-latest.arctic<folder>._util<file>.are_equals<func>
INFO:root:****************************************

data 112:   0%|          | 0/512 [00:00<?, ?it/s]
data 112:   2%|▏         | 10/512 [00:39<33:03,  3.95s/it]
data 112:   4%|▍         | 20/512 [01:20<33:07,  4.04s/it]
data 112:   6%|▌         | 30/512 [02:04<33:38,  4.19s/it]
data 112:   8%|▊         | 40/512 [02:47<33:17,  4.23s/it]
data 112:  10%|▉         | 50/512 [03:29<32:29,  4.22s/it]
data 112:  12%|█▏        | 60/512 [04:12<32:05,  4.26s/it]
data 112:  12%|█▏        | 60/512 [04:24<33:13,  4.41s/it]
INFO:root:函数头: 
def are_equals(o1, o2, **kwargs):

INFO:root:目标函数体: 
    try:
        if isinstance(o1, DataFrame):
            assert_frame_equal(o1, o2, kwargs)
            return True
        return o1 == o2
    except Exception:
        return False

INFO:root:生成结果: 
    try:
        if isinstance(o1, DataFrame) and isinstance(o2, DataFrame):
            return assert_frame_equal(o1, o2, **kwargs)
        return o1 == o2
    except Exception as e:
        logger.debug(f"Comparison failed: {e}")
        return False




INFO:root:----------------------------------------
INFO:root:max length: 8007
INFO:root:max position: 10752
INFO:root:target_namespace: arctic-latest.arctic<folder>._util<file>.are_equals<func>
INFO:root:****************************************

data 112:   0%|          | 0/512 [00:00<?, ?it/s]
data 112:   2%|▏         | 10/512 [00:36<30:35,  3.66s/it]
data 112:   4%|▍         | 20/512 [01:19<32:58,  4.02s/it]
data 112:   6%|▌         | 30/512 [02:04<33:57,  4.23s/it]
data 112:   8%|▊         | 40/512 [02:46<33:24,  4.25s/it]
data 112:  10%|▉         | 50/512 [03:27<32:19,  4.20s/it]
data 112:  12%|█▏        | 60/512 [04:12<32:12,  4.28s/it]
data 112:  12%|█▏        | 60/512 [04:24<33:12,  4.41s/it]
INFO:root:函数头: 
def are_equals(o1, o2, **kwargs):

INFO:root:目标函数体: 
    try:
        if isinstance(o1, DataFrame):
            assert_frame_equal(o1, o2, kwargs)
            return True
        return o1 == o2
    except Exception:
        return False

INFO:root:生成结果: 
    try:
        if isinstance(o1, DataFrame) and isinstance(o2, DataFrame):
            return assert_frame_equal(o1, o2, **kwargs)
        return o1 == o2
    except Exception as e:
        logger.debug(f"Comparison failed: {e}")
        return False




INFO:root:----------------------------------------
INFO:root:max length: 7777
INFO:root:max position: 10807
INFO:root:target_namespace: arctic-latest.arctic<folder>._util<file>.are_equals<func>
INFO:root:****************************************
INFO:root:--------data 113--------

data 113:   0%|          | 0/512 [00:00<?, ?it/s]
data 113:   2%|▏         | 10/512 [00:39<32:53,  3.93s/it]
data 113:   2%|▏         | 10/512 [01:14<1:01:58,  7.41s/it]
INFO:root:函数头: 
def register_resolve_mongodb_hook(hook):

INFO:root:目标函数体: 
    global _resolve_mongodb_hook
    _resolve_mongodb_hook = hook

INFO:root:生成结果: 
    global _resolve_mongodb_hook
    _resolve_mongodb_hook = hook




INFO:root:----------------------------------------
INFO:root:max length: 6523
INFO:root:max position: 9054
INFO:root:target_namespace: arctic-latest.arctic<folder>.hooks<file>.register_resolve_mongodb_hook<func>
INFO:root:****************************************

data 113:   0%|          | 0/512 [00:00<?, ?it/s]
data 113:   2%|▏         | 10/512 [00:35<29:33,  3.53s/it]
data 113:   2%|▏         | 10/512 [01:11<1:00:05,  7.18s/it]
INFO:root:函数头: 
def register_resolve_mongodb_hook(hook):

INFO:root:目标函数体: 
    global _resolve_mongodb_hook
    _resolve_mongodb_hook = hook

INFO:root:生成结果: 
    global _resolve_mongodb_hook
    _resolve_mongodb_hook = hook




INFO:root:----------------------------------------
INFO:root:max length: 7046
INFO:root:max position: 9550
INFO:root:target_namespace: arctic-latest.arctic<folder>.hooks<file>.register_resolve_mongodb_hook<func>
INFO:root:****************************************

data 113:   0%|          | 0/512 [00:00<?, ?it/s]
data 113:   2%|▏         | 10/512 [00:33<27:41,  3.31s/it]
data 113:   2%|▏         | 10/512 [01:09<58:04,  6.94s/it]
INFO:root:函数头: 
def register_resolve_mongodb_hook(hook):

INFO:root:目标函数体: 
    global _resolve_mongodb_hook
    _resolve_mongodb_hook = hook

INFO:root:生成结果: 
    global _resolve_mongodb_hook
    _resolve_mongodb_hook = hook




INFO:root:----------------------------------------
INFO:root:max length: 7404
INFO:root:max position: 9890
INFO:root:target_namespace: arctic-latest.arctic<folder>.hooks<file>.register_resolve_mongodb_hook<func>
INFO:root:****************************************

data 113:   0%|          | 0/512 [00:00<?, ?it/s]
data 113:   2%|▏         | 10/512 [00:34<28:39,  3.43s/it]
data 113:   2%|▏         | 10/512 [01:10<58:51,  7.04s/it]
INFO:root:函数头: 
def register_resolve_mongodb_hook(hook):

INFO:root:目标函数体: 
    global _resolve_mongodb_hook
    _resolve_mongodb_hook = hook

INFO:root:生成结果: 
    global _resolve_mongodb_hook
    _resolve_mongodb_hook = hook




INFO:root:----------------------------------------
INFO:root:max length: 6622
INFO:root:max position: 9056
INFO:root:target_namespace: arctic-latest.arctic<folder>.hooks<file>.register_resolve_mongodb_hook<func>
INFO:root:****************************************

data 113:   0%|          | 0/512 [00:00<?, ?it/s]
data 113:   2%|▏         | 10/512 [00:34<29:04,  3.48s/it]
data 113:   2%|▏         | 10/512 [01:10<59:20,  7.09s/it]
INFO:root:函数头: 
def register_resolve_mongodb_hook(hook):

INFO:root:目标函数体: 
    global _resolve_mongodb_hook
    _resolve_mongodb_hook = hook

INFO:root:生成结果: 
    global _resolve_mongodb_hook
    _resolve_mongodb_hook = hook




INFO:root:----------------------------------------
INFO:root:max length: 7558
INFO:root:max position: 9613
INFO:root:target_namespace: arctic-latest.arctic<folder>.hooks<file>.register_resolve_mongodb_hook<func>
INFO:root:****************************************
INFO:root:--------data 114--------

data 114:   0%|          | 0/512 [00:00<?, ?it/s]
data 114:   2%|▏         | 10/512 [00:37<30:57,  3.70s/it]
data 114:   2%|▏         | 10/512 [01:02<52:02,  6.22s/it]
INFO:root:函数头: 
def register_log_exception_hook(hook):

INFO:root:目标函数体: 
    global _log_exception_hook
    _log_exception_hook = hook

INFO:root:生成结果: 
    global _log_exception_hook
    _log_exception_hook = hook




INFO:root:----------------------------------------
INFO:root:max length: 7136
INFO:root:max position: 9853
INFO:root:target_namespace: arctic-latest.arctic<folder>.hooks<file>.register_log_exception_hook<func>
INFO:root:****************************************

data 114:   0%|          | 0/512 [00:00<?, ?it/s]
data 114:   2%|▏         | 10/512 [00:34<28:57,  3.46s/it]
data 114:   2%|▏         | 10/512 [00:59<49:27,  5.91s/it]
INFO:root:函数头: 
def register_log_exception_hook(hook):

INFO:root:目标函数体: 
    global _log_exception_hook
    _log_exception_hook = hook

INFO:root:生成结果: 
    global _log_exception_hook
    _log_exception_hook = hook




INFO:root:----------------------------------------
INFO:root:max length: 7185
INFO:root:max position: 9243
INFO:root:target_namespace: arctic-latest.arctic<folder>.hooks<file>.register_log_exception_hook<func>
INFO:root:****************************************

data 114:   0%|          | 0/512 [00:00<?, ?it/s]
data 114:   2%|▏         | 10/512 [00:33<27:46,  3.32s/it]
data 114:   2%|▏         | 10/512 [00:59<49:33,  5.92s/it]
INFO:root:函数头: 
def register_log_exception_hook(hook):

INFO:root:目标函数体: 
    global _log_exception_hook
    _log_exception_hook = hook

INFO:root:生成结果: 
    global _log_exception_hook
    _log_exception_hook = hook




INFO:root:----------------------------------------
INFO:root:max length: 6949
INFO:root:max position: 10357
INFO:root:target_namespace: arctic-latest.arctic<folder>.hooks<file>.register_log_exception_hook<func>
INFO:root:****************************************

data 114:   0%|          | 0/512 [00:00<?, ?it/s]
data 114:   2%|▏         | 10/512 [00:34<28:48,  3.44s/it]
data 114:   2%|▏         | 10/512 [00:59<49:58,  5.97s/it]
INFO:root:函数头: 
def register_log_exception_hook(hook):

INFO:root:目标函数体: 
    global _log_exception_hook
    _log_exception_hook = hook

INFO:root:生成结果: 
    global _log_exception_hook
    _log_exception_hook = hook




INFO:root:----------------------------------------
INFO:root:max length: 7055
INFO:root:max position: 9468
INFO:root:target_namespace: arctic-latest.arctic<folder>.hooks<file>.register_log_exception_hook<func>
INFO:root:****************************************

data 114:   0%|          | 0/512 [00:00<?, ?it/s]
data 114:   2%|▏         | 10/512 [00:33<28:08,  3.36s/it]
data 114:   2%|▏         | 10/512 [01:00<50:35,  6.05s/it]
INFO:root:函数头: 
def register_log_exception_hook(hook):

INFO:root:目标函数体: 
    global _log_exception_hook
    _log_exception_hook = hook

INFO:root:生成结果: 
    global _log_exception_hook
    _log_exception_hook = hook




INFO:root:----------------------------------------
INFO:root:max length: 7578
INFO:root:max position: 10305
INFO:root:target_namespace: arctic-latest.arctic<folder>.hooks<file>.register_log_exception_hook<func>
INFO:root:****************************************
INFO:root:--------data 115--------

data 115:   0%|          | 0/512 [00:00<?, ?it/s]
data 115:   2%|▏         | 10/512 [00:37<31:17,  3.74s/it]
data 115:   2%|▏         | 10/512 [01:03<53:07,  6.35s/it]
INFO:root:函数头: 
def register_get_auth_hook(hook):

INFO:root:目标函数体: 
    global _get_auth_hook
    _get_auth_hook = hook

INFO:root:生成结果: 
    global _get_auth_hook
    _get_auth_hook = hook




INFO:root:----------------------------------------
INFO:root:max length: 6702
INFO:root:max position: 8996
INFO:root:target_namespace: arctic-latest.arctic<folder>.hooks<file>.register_get_auth_hook<func>
INFO:root:****************************************

data 115:   0%|          | 0/512 [00:00<?, ?it/s]
data 115:   2%|▏         | 10/512 [00:33<28:26,  3.40s/it]
data 115:   2%|▏         | 10/512 [00:59<49:47,  5.95s/it]
INFO:root:函数头: 
def register_get_auth_hook(hook):

INFO:root:目标函数体: 
    global _get_auth_hook
    _get_auth_hook = hook

INFO:root:生成结果: 
    global _get_auth_hook
    _get_auth_hook = hook




INFO:root:----------------------------------------
INFO:root:max length: 6904
INFO:root:max position: 8815
INFO:root:target_namespace: arctic-latest.arctic<folder>.hooks<file>.register_get_auth_hook<func>
INFO:root:****************************************

data 115:   0%|          | 0/512 [00:00<?, ?it/s]
data 115:   2%|▏         | 10/512 [00:33<28:00,  3.35s/it]
data 115:   2%|▏         | 10/512 [00:59<49:51,  5.96s/it]
INFO:root:函数头: 
def register_get_auth_hook(hook):

INFO:root:目标函数体: 
    global _get_auth_hook
    _get_auth_hook = hook

INFO:root:生成结果: 
    global _get_auth_hook
    _get_auth_hook = hook


INFO:root:----------------------------------------
INFO:root:max length: 6991
INFO:root:max position: 9624
INFO:root:target_namespace: arctic-latest.arctic<folder>.hooks<file>.register_get_auth_hook<func>
INFO:root:****************************************

data 115:   0%|          | 0/512 [00:00<?, ?it/s]
data 115:   2%|▏         | 10/512 [00:33<28:22,  3.39s/it]
data 115:   2%|▏         | 10/512 [01:01<51:30,  6.16s/it]
INFO:root:函数头: 
def register_get_auth_hook(hook):

INFO:root:目标函数体: 
    global _get_auth_hook
    _get_auth_hook = hook

INFO:root:生成结果: 
    global _get_auth_hook
    _get_auth_hook = hook




INFO:root:----------------------------------------
INFO:root:max length: 6948
INFO:root:max position: 9271
INFO:root:target_namespace: arctic-latest.arctic<folder>.hooks<file>.register_get_auth_hook<func>
INFO:root:****************************************

data 115:   0%|          | 0/512 [00:00<?, ?it/s]
data 115:   2%|▏         | 10/512 [00:34<28:27,  3.40s/it]
data 115:   2%|▏         | 10/512 [01:00<50:28,  6.03s/it]
INFO:root:函数头: 
def register_get_auth_hook(hook):

INFO:root:目标函数体: 
    global _get_auth_hook
    _get_auth_hook = hook

INFO:root:生成结果: 
    global _get_auth_hook
    _get_auth_hook = hook


INFO:root:----------------------------------------
INFO:root:max length: 7128
INFO:root:max position: 9529
INFO:root:target_namespace: arctic-latest.arctic<folder>.hooks<file>.register_get_auth_hook<func>
INFO:root:****************************************
INFO:root:--------data 116--------

data 116:   0%|          | 0/512 [00:00<?, ?it/s]
data 116:   2%|▏         | 10/512 [00:51<42:44,  5.11s/it]
data 116:   4%|▍         | 20/512 [01:48<44:54,  5.48s/it]
data 116:   6%|▌         | 30/512 [02:45<45:00,  5.60s/it]
data 116:   8%|▊         | 40/512 [03:42<44:10,  5.62s/it]
data 116:   8%|▊         | 40/512 [04:15<50:16,  6.39s/it]
INFO:root:函数头: 
def _split_arrs(array_2d, slices):

INFO:root:目标函数体: 
    
    if len(array_2d) == 0:
        return np.empty(0, dtype=object)

    rtn = np.empty(len(slices) + 1, dtype=object)
    start = 0
    for i, s in enumerate(slices):
        rtn[i] = array_2d[start:s]
        start = s
    rtn[-1] = array_2d[start:]
    return rtn

INFO:root:生成结果: 
    result = []
    start = 0
    for end in slices:
        result.append(array_2d[start:end])
        start = end
    result.append(array_2d[start:])
    return result


INFO:root:----------------------------------------
INFO:root:max length: 8536
INFO:root:max position: 13323
INFO:root:target_namespace: arctic-latest.arctic<folder>.store<folder>._version_store_utils<file>._split_arrs<func>
INFO:root:****************************************

data 116:   0%|          | 0/512 [00:00<?, ?it/s]
data 116:   2%|▏         | 10/512 [00:45<38:27,  4.60s/it]
data 116:   4%|▍         | 20/512 [01:41<42:10,  5.14s/it]
data 116:   6%|▌         | 30/512 [02:37<42:56,  5.35s/it]
data 116:   8%|▊         | 40/512 [03:29<41:50,  5.32s/it]
data 116:   8%|▊         | 40/512 [04:03<47:51,  6.08s/it]
INFO:root:函数头: 
def _split_arrs(array_2d, slices):

INFO:root:目标函数体: 
    
    if len(array_2d) == 0:
        return np.empty(0, dtype=object)

    rtn = np.empty(len(slices) + 1, dtype=object)
    start = 0
    for i, s in enumerate(slices):
        rtn[i] = array_2d[start:s]
        start = s
    rtn[-1] = array_2d[start:]
    return rtn

INFO:root:生成结果: 
    result = []
    start = 0
    for end in slices:
        result.append(array_2d[start:end])
        start = end
    result.append(array_2d[start:])
    return result




INFO:root:----------------------------------------
INFO:root:max length: 7473
INFO:root:max position: 13073
INFO:root:target_namespace: arctic-latest.arctic<folder>.store<folder>._version_store_utils<file>._split_arrs<func>
INFO:root:****************************************

data 116:   0%|          | 0/512 [00:00<?, ?it/s]
data 116:   2%|▏         | 10/512 [00:44<37:22,  4.47s/it]
data 116:   4%|▍         | 20/512 [01:39<41:45,  5.09s/it]
data 116:   6%|▌         | 30/512 [02:36<42:50,  5.33s/it]
data 116:   8%|▊         | 40/512 [03:29<42:02,  5.34s/it]
data 116:   8%|▊         | 40/512 [04:02<47:40,  6.06s/it]
INFO:root:函数头: 
def _split_arrs(array_2d, slices):

INFO:root:目标函数体: 
    
    if len(array_2d) == 0:
        return np.empty(0, dtype=object)

    rtn = np.empty(len(slices) + 1, dtype=object)
    start = 0
    for i, s in enumerate(slices):
        rtn[i] = array_2d[start:s]
        start = s
    rtn[-1] = array_2d[start:]
    return rtn

INFO:root:生成结果: 
    result = []
    start = 0
    for end in slices:
        result.append(array_2d[start:end])
        start = end
    result.append(array_2d[start:])
    return result




INFO:root:----------------------------------------
INFO:root:max length: 8035
INFO:root:max position: 12870
INFO:root:target_namespace: arctic-latest.arctic<folder>.store<folder>._version_store_utils<file>._split_arrs<func>
INFO:root:****************************************

data 116:   0%|          | 0/512 [00:00<?, ?it/s]
data 116:   2%|▏         | 10/512 [00:44<37:11,  4.45s/it]
data 116:   4%|▍         | 20/512 [01:40<41:54,  5.11s/it]
data 116:   6%|▌         | 30/512 [02:37<43:16,  5.39s/it]
data 116:   8%|▊         | 40/512 [03:32<42:44,  5.43s/it]
data 116:   8%|▊         | 40/512 [04:04<47:59,  6.10s/it]
INFO:root:函数头: 
def _split_arrs(array_2d, slices):

INFO:root:目标函数体: 
    
    if len(array_2d) == 0:
        return np.empty(0, dtype=object)

    rtn = np.empty(len(slices) + 1, dtype=object)
    start = 0
    for i, s in enumerate(slices):
        rtn[i] = array_2d[start:s]
        start = s
    rtn[-1] = array_2d[start:]
    return rtn

INFO:root:生成结果: 
    result = []
    start = 0
    for end in slices:
        result.append(array_2d[start:end])
        start = end
    result.append(array_2d[start:])
    return result




INFO:root:----------------------------------------
INFO:root:max length: 9451
INFO:root:max position: 14534
INFO:root:target_namespace: arctic-latest.arctic<folder>.store<folder>._version_store_utils<file>._split_arrs<func>
INFO:root:****************************************

data 116:   0%|          | 0/512 [00:00<?, ?it/s]
data 116:   2%|▏         | 10/512 [00:46<38:49,  4.64s/it]
data 116:   4%|▍         | 20/512 [01:41<42:06,  5.14s/it]
data 116:   6%|▌         | 30/512 [02:36<42:52,  5.34s/it]
data 116:   8%|▊         | 40/512 [03:35<43:26,  5.52s/it]
data 116:   8%|▊         | 40/512 [04:07<48:35,  6.18s/it]
INFO:root:函数头: 
def _split_arrs(array_2d, slices):

INFO:root:目标函数体: 
    
    if len(array_2d) == 0:
        return np.empty(0, dtype=object)

    rtn = np.empty(len(slices) + 1, dtype=object)
    start = 0
    for i, s in enumerate(slices):
        rtn[i] = array_2d[start:s]
        start = s
    rtn[-1] = array_2d[start:]
    return rtn

INFO:root:生成结果: 
    result = []
    start = 0
    for end in slices:
        result.append(array_2d[start:end])
        start = end
    result.append(array_2d[start:])
    return result


INFO:root:----------------------------------------
INFO:root:max length: 7478
INFO:root:max position: 12902
INFO:root:target_namespace: arctic-latest.arctic<folder>.store<folder>._version_store_utils<file>._split_arrs<func>
INFO:root:****************************************
INFO:root:--------data 117--------

data 117:   0%|          | 0/512 [00:00<?, ?it/s]
data 117:   2%|▏         | 10/512 [00:55<46:34,  5.57s/it]
data 117:   4%|▍         | 20/512 [01:51<45:46,  5.58s/it]
data 117:   6%|▌         | 30/512 [02:44<43:44,  5.44s/it]
data 117:   8%|▊         | 40/512 [03:39<42:55,  5.46s/it]
data 117:  10%|▉         | 50/512 [04:31<41:21,  5.37s/it]
data 117:  10%|▉         | 50/512 [04:47<44:14,  5.75s/it]
INFO:root:函数头: 
def checksum(symbol, doc):

INFO:root:目标函数体: 
    
    sha = hashlib.sha1()
    sha.update(symbol.encode('ascii'))
    for k in sorted(iter(doc.keys()), reverse=True):
        v = doc[k]
        if isinstance(v, bytes):
            sha.update(doc[k])
        else:
            sha.update(str(doc[k]).encode('ascii'))
    return Binary(sha.digest())

INFO:root:生成结果: 
    # Calculate the checksum using SHA1 algorithm
    sha1_hash = hashlib.sha1()
    sha1_hash.update(symbol.encode('utf-8'))
    sha1_hash.update(pickle_compat dumps(doc))
    return Binary(sha1_hash.digest())




INFO:root:----------------------------------------
INFO:root:max length: 8070
INFO:root:max position: 13207
INFO:root:target_namespace: arctic-latest.arctic<folder>.store<folder>._version_store_utils<file>.checksum<func>
INFO:root:****************************************

data 117:   0%|          | 0/512 [00:00<?, ?it/s]
data 117:   2%|▏         | 10/512 [00:47<40:02,  4.79s/it]
data 117:   4%|▍         | 20/512 [01:41<41:48,  5.10s/it]
data 117:   4%|▍         | 20/512 [01:46<43:31,  5.31s/it]
INFO:root:函数头: 
def checksum(symbol, doc):

INFO:root:目标函数体: 
    
    sha = hashlib.sha1()
    sha.update(symbol.encode('ascii'))
    for k in sorted(iter(doc.keys()), reverse=True):
        v = doc[k]
        if isinstance(v, bytes):
            sha.update(doc[k])
        else:
            sha.update(str(doc[k]).encode('ascii'))
    return Binary(sha.digest())

INFO:root:生成结果: 
    data = pickle_compat.dumps(doc)
    return Binary(hashlib.sha1(data).digest())




INFO:root:----------------------------------------
INFO:root:max length: 7457
INFO:root:max position: 11920
INFO:root:target_namespace: arctic-latest.arctic<folder>.store<folder>._version_store_utils<file>.checksum<func>
INFO:root:****************************************

data 117:   0%|          | 0/512 [00:00<?, ?it/s]
data 117:   2%|▏         | 10/512 [00:48<40:47,  4.88s/it]
data 117:   4%|▍         | 20/512 [01:41<41:58,  5.12s/it]
data 117:   6%|▌         | 30/512 [02:35<42:13,  5.26s/it]
data 117:   8%|▊         | 40/512 [03:29<41:35,  5.29s/it]
data 117:  10%|▉         | 50/512 [04:23<41:05,  5.34s/it]
data 117:  12%|█▏        | 60/512 [05:13<39:16,  5.21s/it]
data 117:  12%|█▏        | 60/512 [06:06<45:57,  6.10s/it]
INFO:root:函数头: 
def checksum(symbol, doc):

INFO:root:目标函数体: 
    
    sha = hashlib.sha1()
    sha.update(symbol.encode('ascii'))
    for k in sorted(iter(doc.keys()), reverse=True):
        v = doc[k]
        if isinstance(v, bytes):
            sha.update(doc[k])
        else:
            sha.update(str(doc[k]).encode('ascii'))
    return Binary(sha.digest())

INFO:root:生成结果: 
    # Convert the dictionary to JSON string
    doc_json = json.dumps(doc)
    
    # Calculate the SHA1 hash of the JSON string
    hash_object = hashlib.sha1(doc_json.encode())
    
    # Convert the hash object to a binary object
    checksum_binary = Binary(hash_object.digest())
    
    return checksum_binary




INFO:root:----------------------------------------
INFO:root:max length: 7621
INFO:root:max position: 13902
INFO:root:target_namespace: arctic-latest.arctic<folder>.store<folder>._version_store_utils<file>.checksum<func>
INFO:root:****************************************

data 117:   0%|          | 0/512 [00:00<?, ?it/s]
data 117:   2%|▏         | 10/512 [00:45<38:19,  4.58s/it]
data 117:   4%|▍         | 20/512 [01:37<40:26,  4.93s/it]
data 117:   6%|▌         | 30/512 [02:32<41:36,  5.18s/it]
data 117:   8%|▊         | 40/512 [03:21<40:01,  5.09s/it]
data 117:  10%|▉         | 50/512 [04:14<39:39,  5.15s/it]
data 117:  12%|█▏        | 60/512 [05:00<37:23,  4.96s/it]
data 117:  14%|█▎        | 70/512 [05:52<37:07,  5.04s/it]
data 117:  16%|█▌        | 80/512 [06:43<36:26,  5.06s/it]
data 117:  16%|█▌        | 80/512 [07:39<41:20,  5.74s/it]
INFO:root:函数头: 
def checksum(symbol, doc):

INFO:root:目标函数体: 
    
    sha = hashlib.sha1()
    sha.update(symbol.encode('ascii'))
    for k in sorted(iter(doc.keys()), reverse=True):
        v = doc[k]
        if isinstance(v, bytes):
            sha.update(doc[k])
        else:
            sha.update(str(doc[k]).encode('ascii'))
    return Binary(sha.digest())

INFO:root:生成结果: 
    import hashlib
    import bson
    import json

    # Convert the dictionary to JSON format
    json_doc = json.dumps(doc, sort_keys=True)
    
    # Calculate the SHA1 hash of the JSON document
    hash_object = hashlib.sha1(json_doc.encode('utf-8'))
    
    # Convert the hash object to a binary object
    checksum_bin = Binary(hash_object.digest())
    
    return checksum_bin




INFO:root:----------------------------------------
INFO:root:max length: 9638
INFO:root:max position: 13233
INFO:root:target_namespace: arctic-latest.arctic<folder>.store<folder>._version_store_utils<file>.checksum<func>
INFO:root:****************************************

data 117:   0%|          | 0/512 [00:00<?, ?it/s]
data 117:   2%|▏         | 10/512 [00:46<38:52,  4.65s/it]
data 117:   4%|▍         | 20/512 [01:41<42:19,  5.16s/it]
data 117:   6%|▌         | 30/512 [02:34<41:45,  5.20s/it]
data 117:   8%|▊         | 40/512 [03:28<41:30,  5.28s/it]
data 117:  10%|▉         | 50/512 [04:16<39:19,  5.11s/it]
data 117:  12%|█▏        | 60/512 [05:02<37:19,  4.95s/it]
data 117:  14%|█▎        | 70/512 [05:56<37:33,  5.10s/it]
data 117:  16%|█▌        | 80/512 [06:52<37:50,  5.26s/it]
data 117:  18%|█▊        | 90/512 [07:48<37:42,  5.36s/it]
data 117:  20%|█▉        | 100/512 [08:40<36:28,  5.31s/it]
data 117:  21%|██▏       | 110/512 [09:33<35:34,  5.31s/it]
data 117:  23%|██▎       | 120/512 [10:23<33:58,  5.20s/it]
data 117:  23%|██▎       | 120/512 [11:02<36:03,  5.52s/it]
INFO:root:函数头: 
def checksum(symbol, doc):

INFO:root:目标函数体: 
    
    sha = hashlib.sha1()
    sha.update(symbol.encode('ascii'))
    for k in sorted(iter(doc.keys()), reverse=True):
        v = doc[k]
        if isinstance(v, bytes):
            sha.update(doc[k])
        else:
            sha.update(str(doc[k]).encode('ascii'))
    return Binary(sha.digest())

INFO:root:生成结果: 
    # Convert the symbol and doc to bytes
    symbol_bytes = symbol.encode('utf-8')
    doc_bytes = pickle_compat.dumps(doc)
    
    # Calculate the SHA1 hash of the symbol bytes
    sha_hash = hashlib.sha1(symbol_bytes).digest()
    
    # Calculate the SHA1 hash of the doc bytes
    doc_hash = hashlib.sha1(doc_bytes).digest()
    
    # Combine the hashes and calculate the final checksum
    final_hash = hashlib.sha1(sha_hash + doc_hash).digest()
    
    # Return the final checksum as a Binary object
    return Binary(final_hash)




INFO:root:----------------------------------------
INFO:root:max length: 9433
INFO:root:max position: 14768
INFO:root:target_namespace: arctic-latest.arctic<folder>.store<folder>._version_store_utils<file>.checksum<func>
INFO:root:****************************************
INFO:root:--------data 118--------

data 118:   0%|          | 0/512 [00:00<?, ?it/s]
data 118:   2%|▏         | 10/512 [00:45<38:18,  4.58s/it]
data 118:   4%|▍         | 20/512 [01:38<40:44,  4.97s/it]
data 118:   6%|▌         | 30/512 [02:32<41:31,  5.17s/it]
data 118:   6%|▌         | 30/512 [03:21<54:03,  6.73s/it]
INFO:root:函数头: 
    def __str__(self):

INFO:root:目标函数体: 
        return "VersionedItem(symbol=%s,library=%s,data=%s,version=%s,metadata=%s,host=%s)" % \
            (self.symbol, self.library, type(self.data), self.version, self.metadata, self.host)

INFO:root:生成结果: 
        return f"VersionedItem(symbol={self.symbol}, library={self.library}, data={self.data}, version={self.version}, metadata={self.metadata}, host={self.host})"




INFO:root:----------------------------------------
INFO:root:max length: 8578
INFO:root:max position: 12105
INFO:root:target_namespace: arctic-latest.arctic<folder>.store<folder>.versioned_item<file>.VersionedItem<class>.__str__<func>
INFO:root:****************************************

data 118:   0%|          | 0/512 [00:00<?, ?it/s]
data 118:   2%|▏         | 10/512 [00:46<39:04,  4.67s/it]
data 118:   4%|▍         | 20/512 [01:34<38:41,  4.72s/it]
data 118:   6%|▌         | 30/512 [02:26<39:56,  4.97s/it]
data 118:   6%|▌         | 30/512 [03:14<52:11,  6.50s/it]
INFO:root:函数头: 
    def __str__(self):

INFO:root:目标函数体: 
        return "VersionedItem(symbol=%s,library=%s,data=%s,version=%s,metadata=%s,host=%s)" % \
            (self.symbol, self.library, type(self.data), self.version, self.metadata, self.host)

INFO:root:生成结果: 
        return f"VersionedItem(symbol={self.symbol}, library={self.library}, data={self.data}, version={self.version}, metadata={self.metadata}, host={self.host})"


INFO:root:----------------------------------------
INFO:root:max length: 8189
INFO:root:max position: 12080
INFO:root:target_namespace: arctic-latest.arctic<folder>.store<folder>.versioned_item<file>.VersionedItem<class>.__str__<func>
INFO:root:****************************************

data 118:   0%|          | 0/512 [00:00<?, ?it/s]
data 118:   2%|▏         | 10/512 [00:48<40:11,  4.80s/it]
data 118:   4%|▍         | 20/512 [01:37<40:18,  4.92s/it]
data 118:   6%|▌         | 30/512 [02:33<41:40,  5.19s/it]
data 118:   6%|▌         | 30/512 [03:25<55:00,  6.85s/it]
INFO:root:函数头: 
    def __str__(self):

INFO:root:目标函数体: 
        return "VersionedItem(symbol=%s,library=%s,data=%s,version=%s,metadata=%s,host=%s)" % \
            (self.symbol, self.library, type(self.data), self.version, self.metadata, self.host)

INFO:root:生成结果: 
        return f"VersionedItem(symbol={self.symbol}, library={self.library}, data={self.data}, version={self.version}, metadata={self.metadata}, host={self.host})"




INFO:root:----------------------------------------
INFO:root:max length: 9026
INFO:root:max position: 13928
INFO:root:target_namespace: arctic-latest.arctic<folder>.store<folder>.versioned_item<file>.VersionedItem<class>.__str__<func>
INFO:root:****************************************

data 118:   0%|          | 0/512 [00:00<?, ?it/s]
data 118:   2%|▏         | 10/512 [00:49<41:26,  4.95s/it]
data 118:   4%|▍         | 20/512 [01:40<41:31,  5.06s/it]
data 118:   6%|▌         | 30/512 [02:33<41:24,  5.15s/it]
data 118:   6%|▌         | 30/512 [03:18<53:09,  6.62s/it]
INFO:root:函数头: 
    def __str__(self):

INFO:root:目标函数体: 
        return "VersionedItem(symbol=%s,library=%s,data=%s,version=%s,metadata=%s,host=%s)" % \
            (self.symbol, self.library, type(self.data), self.version, self.metadata, self.host)

INFO:root:生成结果: 
        return f"VersionedItem(symbol={self.symbol}, library={self.library}, data={self.data}, version={self.version}, metadata={self.metadata}, host={self.host})"


INFO:root:----------------------------------------
INFO:root:max length: 8298
INFO:root:max position: 12420
INFO:root:target_namespace: arctic-latest.arctic<folder>.store<folder>.versioned_item<file>.VersionedItem<class>.__str__<func>
INFO:root:****************************************

data 118:   0%|          | 0/512 [00:00<?, ?it/s]
data 118:   2%|▏         | 10/512 [00:44<37:05,  4.43s/it]
data 118:   4%|▍         | 20/512 [01:31<37:33,  4.58s/it]
data 118:   6%|▌         | 30/512 [02:21<38:28,  4.79s/it]
data 118:   6%|▌         | 30/512 [03:06<49:49,  6.20s/it]
INFO:root:函数头: 
    def __str__(self):

INFO:root:目标函数体: 
        return "VersionedItem(symbol=%s,library=%s,data=%s,version=%s,metadata=%s,host=%s)" % \
            (self.symbol, self.library, type(self.data), self.version, self.metadata, self.host)

INFO:root:生成结果: 
        return f"VersionedItem(symbol={self.symbol}, library={self.library}, data={self.data}, version={self.version}, metadata={self.metadata}, host={self.host})"


INFO:root:----------------------------------------
INFO:root:max length: 7396
INFO:root:max position: 11778
INFO:root:target_namespace: arctic-latest.arctic<folder>.store<folder>.versioned_item<file>.VersionedItem<class>.__str__<func>
INFO:root:****************************************
INFO:root:--------data 119--------

data 119:   0%|          | 0/512 [00:00<?, ?it/s]
data 119:   2%|▏         | 10/512 [01:07<56:43,  6.78s/it]
data 119:   4%|▍         | 20/512 [02:15<55:34,  6.78s/it]
data 119:   6%|▌         | 30/512 [03:24<54:50,  6.83s/it]
data 119:   8%|▊         | 40/512 [04:28<52:17,  6.65s/it]
data 119:  10%|▉         | 50/512 [05:36<51:48,  6.73s/it]
data 119:  12%|█▏        | 60/512 [06:37<49:05,  6.52s/it]
data 119:  14%|█▎        | 70/512 [07:36<46:22,  6.30s/it]
data 119:  16%|█▌        | 80/512 [08:39<45:17,  6.29s/it]
data 119:  18%|█▊        | 90/512 [09:49<45:55,  6.53s/it]
data 119:  20%|█▉        | 100/512 [11:01<46:08,  6.72s/it]
data 119:  21%|██▏       | 110/512 [12:10<45:33,  6.80s/it]
data 119:  23%|██▎       | 120/512 [13:16<43:53,  6.72s/it]
data 119:  25%|██▌       | 130/512 [14:22<42:40,  6.70s/it]
data 119:  27%|██▋       | 140/512 [15:28<41:17,  6.66s/it]
data 119:  29%|██▉       | 150/512 [16:26<38:40,  6.41s/it]
data 119:  31%|███▏      | 160/512 [17:27<37:01,  6.31s/it]
data 119:  33%|███▎      | 170/512 [18:29<35:42,  6.26s/it]
data 119:  35%|███▌      | 180/512 [19:33<34:57,  6.32s/it]
data 119:  37%|███▋      | 190/512 [20:29<32:46,  6.11s/it]
data 119:  37%|███▋      | 190/512 [20:41<35:04,  6.54s/it]
INFO:root:函数头: 
    def _dtype(self, string, metadata=None):

INFO:root:目标函数体: 
        if metadata is None:
            metadata = {}
        if string.startswith('['):
            return np.dtype(eval(string), metadata=metadata)
        return np.dtype(string, metadata=metadata)

INFO:root:生成结果: 
        # Remove leading "[" and trailing "]" from the string
        string = string[1:-1]
        # Split the string by "," to get individual fields
        fields = string.split(',')
        # Initialize an empty list to store field names and types
        field_names = []
        field_types = []
        # Iterate over each field
        for field in fields:
            # Split the field by ":" to get field name and type
            field_name, field_type = field.split(':')
            # Add field name and type to the lists
            field_names.append(field_name.strip())
            field_types.append(field_type.strip())
        # Create a numpy dtype object using field names and types
        dtype = np.dtype([(name, dtype) for name, dtype in zip(field_names, field_types)])
        # If metadata is provided, add it to the dtype object
        if metadata:
            dtype.metadata = metadata
        return dtype


INFO:root:----------------------------------------
INFO:root:max length: 11004
INFO:root:max position: 16798
INFO:root:target_namespace: arctic-latest.arctic<folder>.store<folder>._ndarray_store<file>.NdarrayStore<class>._dtype<func>
INFO:root:****************************************

data 119:   0%|          | 0/512 [00:00<?, ?it/s]
data 119:   2%|▏         | 10/512 [00:58<49:02,  5.86s/it]
data 119:   4%|▍         | 20/512 [02:03<50:55,  6.21s/it]
data 119:   4%|▍         | 20/512 [02:30<1:01:53,  7.55s/it]
INFO:root:函数头: 
    def _dtype(self, string, metadata=None):

INFO:root:目标函数体: 
        if metadata is None:
            metadata = {}
        if string.startswith('['):
            return np.dtype(eval(string), metadata=metadata)
        return np.dtype(string, metadata=metadata)

INFO:root:生成结果: 
        if metadata is None:
            metadata = {}
        return np.dtype(string, metadata=metadata)

INFO:root:----------------------------------------
INFO:root:max length: 10811
INFO:root:max position: 17702
INFO:root:target_namespace: arctic-latest.arctic<folder>.store<folder>._ndarray_store<file>.NdarrayStore<class>._dtype<func>
INFO:root:****************************************

data 119:   0%|          | 0/512 [00:00<?, ?it/s]
data 119:   2%|▏         | 10/512 [00:56<47:14,  5.65s/it]
data 119:   4%|▍         | 20/512 [01:59<49:14,  6.00s/it]
data 119:   6%|▌         | 30/512 [03:03<49:42,  6.19s/it]
data 119:   8%|▊         | 40/512 [04:09<50:14,  6.39s/it]
data 119:  10%|▉         | 50/512 [05:10<48:18,  6.27s/it]
data 119:  12%|█▏        | 60/512 [06:13<47:08,  6.26s/it]
data 119:  14%|█▎        | 70/512 [07:13<45:29,  6.18s/it]
data 119:  16%|█▌        | 80/512 [08:13<44:12,  6.14s/it]
data 119:  18%|█▊        | 90/512 [09:18<43:56,  6.25s/it]
data 119:  18%|█▊        | 90/512 [10:11<47:45,  6.79s/it]
INFO:root:函数头: 
    def _dtype(self, string, metadata=None):

INFO:root:目标函数体: 
        if metadata is None:
            metadata = {}
        if string.startswith('['):
            return np.dtype(eval(string), metadata=metadata)
        return np.dtype(string, metadata=metadata)

INFO:root:生成结果: 
        import numpy as np
        import bson
        import bson.json_util
        import json

        # Parse the string into a dictionary using bson json_util.loads
        json_data = bson.json_util.loads(string)

        # Convert the dictionary into a numpy dtype object using np.dtype
        dtype = np.dtype(json_data)

        # If metadata is provided, update the dtype object with the metadata
        if metadata:
            dtype.metadata.update(metadata)

        return dtype

INFO:root:----------------------------------------
INFO:root:max length: 10349
INFO:root:max position: 15624
INFO:root:target_namespace: arctic-latest.arctic<folder>.store<folder>._ndarray_store<file>.NdarrayStore<class>._dtype<func>
INFO:root:****************************************

data 119:   0%|          | 0/512 [00:00<?, ?it/s]
data 119:   2%|▏         | 10/512 [01:02<52:42,  6.30s/it]
data 119:   4%|▍         | 20/512 [02:03<50:34,  6.17s/it]
data 119:   6%|▌         | 30/512 [03:10<51:19,  6.39s/it]
data 119:   8%|▊         | 40/512 [04:10<49:10,  6.25s/it]
data 119:  10%|▉         | 50/512 [05:13<48:05,  6.25s/it]
data 119:  12%|█▏        | 60/512 [06:16<47:20,  6.28s/it]
data 119:  14%|█▎        | 70/512 [07:17<45:42,  6.21s/it]
data 119:  14%|█▎        | 70/512 [08:14<52:04,  7.07s/it]
INFO:root:函数头: 
    def _dtype(self, string, metadata=None):

INFO:root:目标函数体: 
        if metadata is None:
            metadata = {}
        if string.startswith('['):
            return np.dtype(eval(string), metadata=metadata)
        return np.dtype(string, metadata=metadata)

INFO:root:生成结果: 
        # Importing necessary modules
        import numpy as np

        # If metadata is None, set it to an empty dictionary
        metadata = metadata if metadata else {}

        # Convert string to numpy dtype
        dtype = np.dtype(string)

        # Add metadata to the dtype object
        dtype.metadata = metadata

        # Return the dtype object
        return dtype


INFO:root:----------------------------------------
INFO:root:max length: 9212
INFO:root:max position: 15703
INFO:root:target_namespace: arctic-latest.arctic<folder>.store<folder>._ndarray_store<file>.NdarrayStore<class>._dtype<func>
INFO:root:****************************************

data 119:   0%|          | 0/512 [00:00<?, ?it/s]
data 119:   2%|▏         | 10/512 [00:55<46:08,  5.51s/it]
data 119:   4%|▍         | 20/512 [01:57<48:49,  5.95s/it]
data 119:   6%|▌         | 30/512 [03:04<50:32,  6.29s/it]
data 119:   8%|▊         | 40/512 [04:00<47:20,  6.02s/it]
data 119:  10%|▉         | 50/512 [05:03<46:58,  6.10s/it]
data 119:  12%|█▏        | 60/512 [06:05<46:14,  6.14s/it]
data 119:  14%|█▎        | 70/512 [07:08<45:40,  6.20s/it]
data 119:  16%|█▌        | 80/512 [08:16<46:03,  6.40s/it]
data 119:  18%|█▊        | 90/512 [09:24<45:56,  6.53s/it]
data 119:  20%|█▉        | 100/512 [10:34<45:43,  6.66s/it]
data 119:  21%|██▏       | 110/512 [11:41<44:42,  6.67s/it]
data 119:  23%|██▎       | 120/512 [12:41<42:17,  6.47s/it]
data 119:  25%|██▌       | 130/512 [13:39<39:50,  6.26s/it]
data 119:  25%|██▌       | 130/512 [13:45<40:25,  6.35s/it]
INFO:root:函数头: 
    def _dtype(self, string, metadata=None):

INFO:root:目标函数体: 
        if metadata is None:
            metadata = {}
        if string.startswith('['):
            return np.dtype(eval(string), metadata=metadata)
        return np.dtype(string, metadata=metadata)

INFO:root:生成结果: 
        import numpy as np
        import collections
        import pandas as pd

        # Parse the string to create the dtype object
        dtype_parts = string.split(',')
        dtype_dict = {}
        for part in dtype_parts:
            if '=' in part:
                key, value = part.split('=')
                dtype_dict[key.strip()] = value.strip()
            else:
                dtype_dict[part.strip()] = None

        # Convert the dictionary to a numpy dtype object
        dtype_obj = np.dtype(dtype_dict)

        # Add metadata if provided
        if metadata:
            dtype_obj.metadata = metadata

        return dtype_obj

INFO:root:----------------------------------------
INFO:root:max length: 10033
INFO:root:max position: 15575
INFO:root:target_namespace: arctic-latest.arctic<folder>.store<folder>._ndarray_store<file>.NdarrayStore<class>._dtype<func>
INFO:root:****************************************
INFO:root:--------data 120--------

data 120:   0%|          | 0/512 [00:00<?, ?it/s]
data 120:   0%|          | 0/512 [00:52<?, ?it/s]
INFO:root:函数头: 
def _promote_struct_dtypes(dtype1, dtype2):

INFO:root:目标函数体: 
    if not set(dtype1.names).issuperset(set(dtype2.names)):
        raise Exception("Removing columns from dtype not handled")

    def _promote(type1, type2):
        # Omit body code
    return np.dtype([(n, _promote(dtype1.fields[n][0], dtype2.fields.get(n, (None,))[0])) for n in dtype1.names])

INFO:root:生成结果: 
    # Implement the promotion logic here


INFO:root:----------------------------------------
INFO:root:max length: 6641
INFO:root:max position: 12382
INFO:root:target_namespace: arctic-latest.arctic<folder>.store<folder>._ndarray_store<file>._promote_struct_dtypes<func>
INFO:root:****************************************

data 120:   0%|          | 0/512 [00:00<?, ?it/s]
data 120:   2%|▏         | 10/512 [00:44<37:23,  4.47s/it]
data 120:   4%|▍         | 20/512 [01:38<41:09,  5.02s/it]
data 120:   6%|▌         | 30/512 [02:29<40:30,  5.04s/it]
data 120:   8%|▊         | 40/512 [03:20<39:48,  5.06s/it]
data 120:  10%|▉         | 50/512 [04:14<39:56,  5.19s/it]
data 120:  12%|█▏        | 60/512 [05:02<38:02,  5.05s/it]
data 120:  12%|█▏        | 60/512 [05:54<44:28,  5.90s/it]
INFO:root:函数头: 
def _promote_struct_dtypes(dtype1, dtype2):

INFO:root:目标函数体: 
    if not set(dtype1.names).issuperset(set(dtype2.names)):
        raise Exception("Removing columns from dtype not handled")

    def _promote(type1, type2):
        # Omit body code
    return np.dtype([(n, _promote(dtype1.fields[n][0], dtype2.fields.get(n, (None,))[0])) for n in dtype1.names])

INFO:root:生成结果: 
    promoted_dtype = dtype1
    for field_name in dtype2.names:
        if field_name not in promoted_dtype.names:
            promoted_dtype = np.dtype(promoted_dtype.names + (field_name,))
        promoted_dtype.fields[field_name] = max(promoted_dtype.fields[field_name], dtype2.fields[field_name])
    return promoted_dtype


INFO:root:----------------------------------------
INFO:root:max length: 8965
INFO:root:max position: 13353
INFO:root:target_namespace: arctic-latest.arctic<folder>.store<folder>._ndarray_store<file>._promote_struct_dtypes<func>
INFO:root:****************************************

data 120:   0%|          | 0/512 [00:00<?, ?it/s]
data 120:   2%|▏         | 10/512 [00:44<37:36,  4.49s/it]
data 120:   4%|▍         | 20/512 [01:35<39:30,  4.82s/it]
data 120:   6%|▌         | 30/512 [02:24<39:13,  4.88s/it]
data 120:   8%|▊         | 40/512 [03:16<39:12,  4.98s/it]
data 120:  10%|▉         | 50/512 [04:07<38:48,  5.04s/it]
data 120:  12%|█▏        | 60/512 [04:53<36:48,  4.89s/it]
data 120:  14%|█▎        | 70/512 [05:45<36:40,  4.98s/it]
data 120:  16%|█▌        | 80/512 [06:35<35:57,  5.00s/it]
data 120:  18%|█▊        | 90/512 [07:30<36:13,  5.15s/it]
data 120:  20%|█▉        | 100/512 [08:19<34:53,  5.08s/it]
data 120:  20%|█▉        | 100/512 [08:40<35:45,  5.21s/it]
INFO:root:函数头: 
def _promote_struct_dtypes(dtype1, dtype2):

INFO:root:目标函数体: 
    if not set(dtype1.names).issuperset(set(dtype2.names)):
        raise Exception("Removing columns from dtype not handled")

    def _promote(type1, type2):
        # Omit body code
    return np.dtype([(n, _promote(dtype1.fields[n][0], dtype2.fields.get(n, (None,))[0])) for n in dtype1.names])

INFO:root:生成结果: 
    if not isinstance(dtype1, np.dtype) or not isinstance(dtype2, np.dtype):
        raise TypeError("Both dtype1 and dtype2 must be numpy dtype objects.")
    if not dtype1.names or not dtype2.names:
        raise ValueError("Both dtype1 and dtype2 must be structured numpy dtype objects.")
    promoted_dtype = np.dtype([(name, np.promize_dtype(dtype1[name])) for name in dtype2.names])
    promoted_dtype.names = dtype2.names
    return promoted_dtype



INFO:root:----------------------------------------
INFO:root:max length: 8352
INFO:root:max position: 15084
INFO:root:target_namespace: arctic-latest.arctic<folder>.store<folder>._ndarray_store<file>._promote_struct_dtypes<func>
INFO:root:****************************************

data 120:   0%|          | 0/512 [00:00<?, ?it/s]
data 120:   2%|▏         | 10/512 [00:48<40:35,  4.85s/it]
data 120:   4%|▍         | 20/512 [01:41<41:44,  5.09s/it]
data 120:   6%|▌         | 30/512 [02:35<42:10,  5.25s/it]
data 120:   8%|▊         | 40/512 [03:28<41:21,  5.26s/it]
data 120:  10%|▉         | 50/512 [04:18<39:43,  5.16s/it]
data 120:  12%|█▏        | 60/512 [05:10<39:11,  5.20s/it]
data 120:  14%|█▎        | 70/512 [06:08<39:35,  5.38s/it]
data 120:  14%|█▎        | 70/512 [06:26<40:41,  5.52s/it]
INFO:root:函数头: 
def _promote_struct_dtypes(dtype1, dtype2):

INFO:root:目标函数体: 
    if not set(dtype1.names).issuperset(set(dtype2.names)):
        raise Exception("Removing columns from dtype not handled")

    def _promote(type1, type2):
        # Omit body code
    return np.dtype([(n, _promote(dtype1.fields[n][0], dtype2.fields.get(n, (None,))[0])) for n in dtype1.names])

INFO:root:生成结果: 
    # Implement the function body based on the provided code prefix and other resources in the current project, without generating any additional content! The current function is located in file arctic/store/_ndarray_store.py, prohibit cyclic calling the current function! You can use resources in the current project, and you MUST write import statements FIRST to call the corresponding resource.


INFO:root:----------------------------------------
INFO:root:max length: 8047
INFO:root:max position: 14451
INFO:root:target_namespace: arctic-latest.arctic<folder>.store<folder>._ndarray_store<file>._promote_struct_dtypes<func>
INFO:root:****************************************

data 120:   0%|          | 0/512 [00:00<?, ?it/s]
data 120:   2%|▏         | 10/512 [00:47<39:51,  4.76s/it]
data 120:   4%|▍         | 20/512 [01:40<41:45,  5.09s/it]
data 120:   6%|▌         | 30/512 [02:40<44:13,  5.51s/it]
data 120:   8%|▊         | 40/512 [03:35<43:07,  5.48s/it]
data 120:  10%|▉         | 50/512 [04:26<41:10,  5.35s/it]
data 120:  12%|█▏        | 60/512 [05:21<40:46,  5.41s/it]
data 120:  14%|█▎        | 70/512 [06:16<39:54,  5.42s/it]
data 120:  14%|█▎        | 70/512 [06:33<41:27,  5.63s/it]
INFO:root:函数头: 
def _promote_struct_dtypes(dtype1, dtype2):

INFO:root:目标函数体: 
    if not set(dtype1.names).issuperset(set(dtype2.names)):
        raise Exception("Removing columns from dtype not handled")

    def _promote(type1, type2):
        # Omit body code
    return np.dtype([(n, _promote(dtype1.fields[n][0], dtype2.fields.get(n, (None,))[0])) for n in dtype1.names])

INFO:root:生成结果: 
    # Implement the function body based on the provided code prefix and other resources in the current project, without generating any additional content! The current function is located in file arctic/store/_ndarray_store.py, prohibit cyclic calling the current function! You can use resources in the current project, and you MUST write import statements FIRST to call the corresponding resource.


INFO:root:----------------------------------------
INFO:root:max length: 8270
INFO:root:max position: 15052
INFO:root:target_namespace: arctic-latest.arctic<folder>.store<folder>._ndarray_store<file>._promote_struct_dtypes<func>
INFO:root:****************************************
INFO:root:--------data 121--------

data 121:   0%|          | 0/512 [00:00<?, ?it/s]
data 121:   0%|          | 0/512 [00:28<?, ?it/s]
INFO:root:函数头: 
    def exclude(self, data, range_obj):

INFO:root:目标函数体: 
        
        if isinstance(data, DataFrame):
            return DataFrame()
        else:
            return Series()

INFO:root:生成结果: 
        return pd.DataFrame()


INFO:root:----------------------------------------
INFO:root:max length: 6168
INFO:root:max position: 9887
INFO:root:target_namespace: arctic-latest.arctic<folder>.chunkstore<folder>.passthrough_chunker<file>.PassthroughChunker<class>.exclude<func>
INFO:root:****************************************

data 121:   0%|          | 0/512 [00:00<?, ?it/s]
data 121:   0%|          | 0/512 [00:23<?, ?it/s]
INFO:root:函数头: 
    def exclude(self, data, range_obj):

INFO:root:目标函数体: 
        
        if isinstance(data, DataFrame):
            return DataFrame()
        else:
            return Series()

INFO:root:生成结果: 
        return pd.DataFrame()


INFO:root:----------------------------------------
INFO:root:max length: 5335
INFO:root:max position: 6820
INFO:root:target_namespace: arctic-latest.arctic<folder>.chunkstore<folder>.passthrough_chunker<file>.PassthroughChunker<class>.exclude<func>
INFO:root:****************************************

data 121:   0%|          | 0/512 [00:00<?, ?it/s]
data 121:   0%|          | 0/512 [00:32<?, ?it/s]
INFO:root:函数头: 
    def exclude(self, data, range_obj):

INFO:root:目标函数体: 
        
        if isinstance(data, DataFrame):
            return DataFrame()
        else:
            return Series()

INFO:root:生成结果: 
        return DataFrame(columns=data.columns)


INFO:root:----------------------------------------
INFO:root:max length: 7279
INFO:root:max position: 9880
INFO:root:target_namespace: arctic-latest.arctic<folder>.chunkstore<folder>.passthrough_chunker<file>.PassthroughChunker<class>.exclude<func>
INFO:root:****************************************

data 121:   0%|          | 0/512 [00:00<?, ?it/s]
data 121:   0%|          | 0/512 [00:32<?, ?it/s]
INFO:root:函数头: 
    def exclude(self, data, range_obj):

INFO:root:目标函数体: 
        
        if isinstance(data, DataFrame):
            return DataFrame()
        else:
            return Series()

INFO:root:生成结果: 
        return DataFrame(columns=data.columns)


INFO:root:----------------------------------------
INFO:root:max length: 6964
INFO:root:max position: 9303
INFO:root:target_namespace: arctic-latest.arctic<folder>.chunkstore<folder>.passthrough_chunker<file>.PassthroughChunker<class>.exclude<func>
INFO:root:****************************************

data 121:   0%|          | 0/512 [00:00<?, ?it/s]
data 121:   0%|          | 0/512 [00:24<?, ?it/s]
INFO:root:函数头: 
    def exclude(self, data, range_obj):

INFO:root:目标函数体: 
        
        if isinstance(data, DataFrame):
            return DataFrame()
        else:
            return Series()

INFO:root:生成结果: 
        return pd.DataFrame()


INFO:root:----------------------------------------
INFO:root:max length: 5516
INFO:root:max position: 8732
INFO:root:target_namespace: arctic-latest.arctic<folder>.chunkstore<folder>.passthrough_chunker<file>.PassthroughChunker<class>.exclude<func>
INFO:root:****************************************
INFO:root:--------data 122--------

data 122:   0%|          | 0/512 [00:00<?, ?it/s]
data 122:   2%|▏         | 10/512 [00:41<34:22,  4.11s/it]
data 122:   4%|▍         | 20/512 [01:18<31:59,  3.90s/it]
data 122:   6%|▌         | 30/512 [01:56<30:57,  3.85s/it]
data 122:   8%|▊         | 40/512 [02:35<30:22,  3.86s/it]
data 122:  10%|▉         | 50/512 [03:22<32:02,  4.16s/it]
data 122:  12%|█▏        | 60/512 [04:07<32:09,  4.27s/it]
data 122:  14%|█▎        | 70/512 [04:50<31:36,  4.29s/it]
data 122:  16%|█▌        | 80/512 [05:35<31:19,  4.35s/it]
data 122:  18%|█▊        | 90/512 [06:20<30:56,  4.40s/it]
data 122:  20%|█▉        | 100/512 [07:09<31:13,  4.55s/it]
data 122:  21%|██▏       | 110/512 [07:50<29:42,  4.43s/it]
data 122:  23%|██▎       | 120/512 [08:33<28:40,  4.39s/it]
data 122:  25%|██▌       | 130/512 [09:20<28:32,  4.48s/it]
data 122:  27%|██▋       | 140/512 [10:08<28:26,  4.59s/it]
data 122:  29%|██▉       | 150/512 [10:46<26:08,  4.33s/it]
data 122:  29%|██▉       | 150/512 [10:59<26:31,  4.40s/it]
INFO:root:函数头: 
    def to_chunks(self, df, chunk_size='D', func=None, **kwargs):

INFO:root:目标函数体: 
        
        if 'date' in df.index.names:
            dates = df.index.get_level_values('date')
            if not df.index.is_monotonic_increasing:
                df = df.sort_index()
        elif 'date' in df.columns:
            dates = pd.DatetimeIndex(df.date)
            if not dates.is_monotonic_increasing:
                # providing support for pandas 0.16.2 to 0.20.x
                # neither sort method exists in both
                try:
                    df = df.sort_values('date')
                except AttributeError:
                    df = df.sort(columns='date')
                dates = pd.DatetimeIndex(df.date)
        else:
            raise Exception("Data must be datetime indexed or have a column named 'date'")

        period_obj = dates.to_period(chunk_size)
        period_obj_reduced = period_obj.drop_duplicates()
        count = 0
        for _, g in df.groupby(period_obj._data):
            start = period_obj_reduced[count].start_time.to_pydatetime(warn=False)
            end = period_obj_reduced[count].end_time.to_pydatetime(warn=False)
            count += 1
            if func:
                yield start, end, chunk_size, func(g)
            else:
                yield start, end, chunk_size, g

INFO:root:生成结果: 
        if func is None:
            func = lambda x: x

        # Convert the dataframe/series to a pandas dataframe if it's not already
        df = pd.DataFrame(df)

        # Get the start and end dates from the dataframe/series
        start_date = df.index.min()
        end_date = df.index.max()

        # Generate chunks based on the given chunk size
        for start, end in pd.date_range(start=start_date, end=end_date, freq=chunk_size):
            # Get the current chunk
            chunk = df[(df.index >= start) & (df.index <= end)]

            # Apply the function to the current chunk
            result = func(chunk)

            yield start, end, chunk_size, result



INFO:root:----------------------------------------
INFO:root:max length: 9303
INFO:root:max position: 11544
INFO:root:target_namespace: arctic-latest.arctic<folder>.chunkstore<folder>.date_chunker<file>.DateChunker<class>.to_chunks<func>
INFO:root:****************************************

data 122:   0%|          | 0/512 [00:00<?, ?it/s]
data 122:   2%|▏         | 10/512 [00:32<27:00,  3.23s/it]
data 122:   4%|▍         | 20/512 [01:02<25:28,  3.11s/it]
data 122:   6%|▌         | 30/512 [01:34<25:15,  3.15s/it]
data 122:   8%|▊         | 40/512 [02:13<27:06,  3.45s/it]
data 122:  10%|▉         | 50/512 [02:58<29:21,  3.81s/it]
data 122:  12%|█▏        | 60/512 [03:43<30:35,  4.06s/it]
data 122:  14%|█▎        | 70/512 [04:21<29:20,  3.98s/it]
data 122:  16%|█▌        | 80/512 [05:04<29:14,  4.06s/it]
data 122:  16%|█▌        | 80/512 [05:21<28:57,  4.02s/it]
INFO:root:函数头: 
    def to_chunks(self, df, chunk_size='D', func=None, **kwargs):

INFO:root:目标函数体: 
        
        if 'date' in df.index.names:
            dates = df.index.get_level_values('date')
            if not df.index.is_monotonic_increasing:
                df = df.sort_index()
        elif 'date' in df.columns:
            dates = pd.DatetimeIndex(df.date)
            if not dates.is_monotonic_increasing:
                # providing support for pandas 0.16.2 to 0.20.x
                # neither sort method exists in both
                try:
                    df = df.sort_values('date')
                except AttributeError:
                    df = df.sort(columns='date')
                dates = pd.DatetimeIndex(df.date)
        else:
            raise Exception("Data must be datetime indexed or have a column named 'date'")

        period_obj = dates.to_period(chunk_size)
        period_obj_reduced = period_obj.drop_duplicates()
        count = 0
        for _, g in df.groupby(period_obj._data):
            start = period_obj_reduced[count].start_time.to_pydatetime(warn=False)
            end = period_obj_reduced[count].end_time.to_pydatetime(warn=False)
            count += 1
            if func:
                yield start, end, chunk_size, func(g)
            else:
                yield start, end, chunk_size, g

INFO:root:生成结果: 
        start_date = df.index.min()
        end_date = df.index.max()
        date_range = DateRange(start_date, end_date)
        date_range = date_range.adjusted_to_frequency(chunk_size)
        start_date = date_range.start
        end_date = date_range.end

        for start, end in date_range.get_chunks():
            yield start, end, chunk_size, df[start:end]


INFO:root:----------------------------------------
INFO:root:max length: 8136
INFO:root:max position: 10584
INFO:root:target_namespace: arctic-latest.arctic<folder>.chunkstore<folder>.date_chunker<file>.DateChunker<class>.to_chunks<func>
INFO:root:****************************************

data 122:   0%|          | 0/512 [00:00<?, ?it/s]
data 122:   2%|▏         | 10/512 [00:34<29:09,  3.49s/it]
data 122:   4%|▍         | 20/512 [01:12<30:02,  3.66s/it]
data 122:   6%|▌         | 30/512 [01:49<29:23,  3.66s/it]
data 122:   8%|▊         | 40/512 [02:27<29:14,  3.72s/it]
data 122:  10%|▉         | 50/512 [03:13<31:07,  4.04s/it]
data 122:  12%|█▏        | 60/512 [04:00<32:03,  4.26s/it]
data 122:  14%|█▎        | 70/512 [04:45<32:01,  4.35s/it]
data 122:  14%|█▎        | 70/512 [05:18<33:31,  4.55s/it]
INFO:root:函数头: 
    def to_chunks(self, df, chunk_size='D', func=None, **kwargs):

INFO:root:目标函数体: 
        
        if 'date' in df.index.names:
            dates = df.index.get_level_values('date')
            if not df.index.is_monotonic_increasing:
                df = df.sort_index()
        elif 'date' in df.columns:
            dates = pd.DatetimeIndex(df.date)
            if not dates.is_monotonic_increasing:
                # providing support for pandas 0.16.2 to 0.20.x
                # neither sort method exists in both
                try:
                    df = df.sort_values('date')
                except AttributeError:
                    df = df.sort(columns='date')
                dates = pd.DatetimeIndex(df.date)
        else:
            raise Exception("Data must be datetime indexed or have a column named 'date'")

        period_obj = dates.to_period(chunk_size)
        period_obj_reduced = period_obj.drop_duplicates()
        count = 0
        for _, g in df.groupby(period_obj._data):
            start = period_obj_reduced[count].start_time.to_pydatetime(warn=False)
            end = period_obj_reduced[count].end_time.to_pydatetime(warn=False)
            count += 1
            if func:
                yield start, end, chunk_size, func(g)
            else:
                yield start, end, chunk_size, g

INFO:root:生成结果: 
        # Implement the function body based on the provided code prefix and other resources in the current project, without generating any additional content! The current function is located in file arctic/chunkstore/date_chunker.py, prohibit cyclic calling the current function! You can use resources in the current project, and you MUST write import statements FIRST to call the corresponding resource.
        pass


INFO:root:----------------------------------------
INFO:root:max length: 7314
INFO:root:max position: 10787
INFO:root:target_namespace: arctic-latest.arctic<folder>.chunkstore<folder>.date_chunker<file>.DateChunker<class>.to_chunks<func>
INFO:root:****************************************

data 122:   0%|          | 0/512 [00:00<?, ?it/s]
data 122:   2%|▏         | 10/512 [00:33<27:51,  3.33s/it]
data 122:   4%|▍         | 20/512 [01:05<26:42,  3.26s/it]
data 122:   6%|▌         | 30/512 [01:37<25:50,  3.22s/it]
data 122:   8%|▊         | 40/512 [02:19<28:35,  3.63s/it]
data 122:  10%|▉         | 50/512 [03:06<30:48,  4.00s/it]
data 122:  12%|█▏        | 60/512 [03:54<32:15,  4.28s/it]
data 122:  14%|█▎        | 70/512 [04:38<31:42,  4.30s/it]
data 122:  16%|█▌        | 80/512 [05:23<31:33,  4.38s/it]
data 122:  18%|█▊        | 90/512 [06:11<31:42,  4.51s/it]
data 122:  20%|█▉        | 100/512 [06:55<30:43,  4.47s/it]
data 122:  21%|██▏       | 110/512 [07:29<27:52,  4.16s/it]
data 122:  21%|██▏       | 110/512 [07:56<29:02,  4.33s/it]
INFO:root:函数头: 
    def to_chunks(self, df, chunk_size='D', func=None, **kwargs):

INFO:root:目标函数体: 
        
        if 'date' in df.index.names:
            dates = df.index.get_level_values('date')
            if not df.index.is_monotonic_increasing:
                df = df.sort_index()
        elif 'date' in df.columns:
            dates = pd.DatetimeIndex(df.date)
            if not dates.is_monotonic_increasing:
                # providing support for pandas 0.16.2 to 0.20.x
                # neither sort method exists in both
                try:
                    df = df.sort_values('date')
                except AttributeError:
                    df = df.sort(columns='date')
                dates = pd.DatetimeIndex(df.date)
        else:
            raise Exception("Data must be datetime indexed or have a column named 'date'")

        period_obj = dates.to_period(chunk_size)
        period_obj_reduced = period_obj.drop_duplicates()
        count = 0
        for _, g in df.groupby(period_obj._data):
            start = period_obj_reduced[count].start_time.to_pydatetime(warn=False)
            end = period_obj_reduced[count].end_time.to_pydatetime(warn=False)
            count += 1
            if func:
                yield start, end, chunk_size, func(g)
            else:
                yield start, end, chunk_size, g

INFO:root:生成结果: 
        start_date = df.index.min()
        end_date = df.index.max()
        date_range = DateRange(start_date=start_date, end_date=end_date)
        date_range = date_range.expand_to_frequency(chunk_size)
        date_range = date_range.expand_to_frequency('D')
        date_range = date_range.expand_to_frequency('M')
        date_range = date_range.expand_to_frequency('Y')
        date_range = date_range.expand_to_frequency('W')

        for start, end in date_range:
            yield start, end, chunk_size, df.loc[start:end]


INFO:root:----------------------------------------
INFO:root:max length: 8176
INFO:root:max position: 11441
INFO:root:target_namespace: arctic-latest.arctic<folder>.chunkstore<folder>.date_chunker<file>.DateChunker<class>.to_chunks<func>
INFO:root:****************************************

data 122:   0%|          | 0/512 [00:00<?, ?it/s]
data 122:   2%|▏         | 10/512 [00:34<28:42,  3.43s/it]
data 122:   4%|▍         | 20/512 [01:11<29:38,  3.61s/it]
data 122:   6%|▌         | 30/512 [01:49<29:47,  3.71s/it]
data 122:   8%|▊         | 40/512 [02:28<29:32,  3.76s/it]
data 122:  10%|▉         | 50/512 [03:13<30:55,  4.02s/it]
data 122:  12%|█▏        | 60/512 [04:01<32:20,  4.29s/it]
data 122:  14%|█▎        | 70/512 [04:44<31:39,  4.30s/it]
data 122:  14%|█▎        | 70/512 [05:18<33:33,  4.56s/it]
INFO:root:函数头: 
    def to_chunks(self, df, chunk_size='D', func=None, **kwargs):

INFO:root:目标函数体: 
        
        if 'date' in df.index.names:
            dates = df.index.get_level_values('date')
            if not df.index.is_monotonic_increasing:
                df = df.sort_index()
        elif 'date' in df.columns:
            dates = pd.DatetimeIndex(df.date)
            if not dates.is_monotonic_increasing:
                # providing support for pandas 0.16.2 to 0.20.x
                # neither sort method exists in both
                try:
                    df = df.sort_values('date')
                except AttributeError:
                    df = df.sort(columns='date')
                dates = pd.DatetimeIndex(df.date)
        else:
            raise Exception("Data must be datetime indexed or have a column named 'date'")

        period_obj = dates.to_period(chunk_size)
        period_obj_reduced = period_obj.drop_duplicates()
        count = 0
        for _, g in df.groupby(period_obj._data):
            start = period_obj_reduced[count].start_time.to_pydatetime(warn=False)
            end = period_obj_reduced[count].end_time.to_pydatetime(warn=False)
            count += 1
            if func:
                yield start, end, chunk_size, func(g)
            else:
                yield start, end, chunk_size, g

INFO:root:生成结果: 
        # Implement the function body based on the provided code prefix and other resources in the current project, without generating any additional content! The current function is located in file arctic/ch chunkstore/date_chunker.py, prohibit cyclic calling the current function! You can use resources in the current project, and you MUST write import statements FIRST to call the corresponding resource.
        pass


INFO:root:----------------------------------------
INFO:root:max length: 7784
INFO:root:max position: 11025
INFO:root:target_namespace: arctic-latest.arctic<folder>.chunkstore<folder>.date_chunker<file>.DateChunker<class>.to_chunks<func>
INFO:root:****************************************
INFO:root:--------data 123--------

data 123:   0%|          | 0/512 [00:00<?, ?it/s]
data 123:   2%|▏         | 10/512 [00:43<36:43,  4.39s/it]
data 123:   4%|▍         | 20/512 [01:28<36:17,  4.43s/it]
data 123:   6%|▌         | 30/512 [02:08<34:00,  4.23s/it]
data 123:   8%|▊         | 40/512 [02:55<34:43,  4.41s/it]
data 123:  10%|▉         | 50/512 [03:35<32:44,  4.25s/it]
data 123:  12%|█▏        | 60/512 [04:17<32:08,  4.27s/it]
data 123:  14%|█▎        | 70/512 [05:03<32:07,  4.36s/it]
data 123:  16%|█▌        | 80/512 [05:47<31:25,  4.37s/it]
data 123:  18%|█▊        | 90/512 [06:34<31:24,  4.46s/it]
data 123:  20%|█▉        | 100/512 [07:22<31:31,  4.59s/it]
data 123:  21%|██▏       | 110/512 [08:09<30:51,  4.61s/it]
data 123:  23%|██▎       | 120/512 [08:52<29:30,  4.52s/it]
data 123:  25%|██▌       | 130/512 [09:36<28:34,  4.49s/it]
data 123:  27%|██▋       | 140/512 [10:26<28:47,  4.64s/it]
data 123:  29%|██▉       | 150/512 [11:16<28:34,  4.73s/it]
data 123:  29%|██▉       | 150/512 [11:54<28:44,  4.76s/it]
INFO:root:函数头: 
    def exclude(self, data, range_obj):

INFO:root:目标函数体: 
        
        if isinstance(range_obj, (pd.DatetimeIndex, tuple)):
            range_obj = DateRange(range_obj[0], range_obj[-1])
        if 'date' in data.index.names:
            return data[(data.index.get_level_values('date') < range_obj.start) | (data.index.get_level_values('date') > range_obj.end)]
        elif 'date' in data.columns:
            return data[(data.date < range_obj.start) | (data.date > range_obj.end)]
        else:
            return data

INFO:root:生成结果: 
        if isinstance(range_obj, (pd.DatetimeIndex, tuple)):
            range_obj = DateRange(range_obj[0], range_obj[-1])

        range_obj = to_pandas_closed_closed(range_obj, add_tz=False)
        start = range_obj.start
        end = range_obj.end

        if 'date' in data.index.names:
            return data[(data.index < start) | (data.index > end)]
        elif 'date' in data.columns:
            if start and end:
                return data[(data.date < start) | (data.date > end)]
            elif start:
                return data[data.date < start]
            elif end:
                return data[data.date > end]
            else:
                return data
        else:
            return data



INFO:root:----------------------------------------
INFO:root:max length: 9493
INFO:root:max position: 12393
INFO:root:target_namespace: arctic-latest.arctic<folder>.chunkstore<folder>.date_chunker<file>.DateChunker<class>.exclude<func>
INFO:root:****************************************

data 123:   0%|          | 0/512 [00:00<?, ?it/s]
data 123:   2%|▏         | 10/512 [00:41<35:03,  4.19s/it]
data 123:   4%|▍         | 20/512 [01:24<34:51,  4.25s/it]
data 123:   6%|▌         | 30/512 [02:05<33:18,  4.15s/it]
data 123:   8%|▊         | 40/512 [02:50<33:47,  4.30s/it]
data 123:  10%|▉         | 50/512 [03:31<32:28,  4.22s/it]
data 123:  12%|█▏        | 60/512 [04:12<31:38,  4.20s/it]
data 123:  14%|█▎        | 70/512 [04:59<32:04,  4.35s/it]
data 123:  16%|█▌        | 80/512 [05:42<31:12,  4.34s/it]
data 123:  18%|█▊        | 90/512 [06:29<31:16,  4.45s/it]
data 123:  20%|█▉        | 100/512 [07:17<31:14,  4.55s/it]
data 123:  21%|██▏       | 110/512 [08:03<30:41,  4.58s/it]
data 123:  23%|██▎       | 120/512 [08:48<29:45,  4.56s/it]
data 123:  25%|██▌       | 130/512 [09:38<29:55,  4.70s/it]
data 123:  27%|██▋       | 140/512 [10:28<29:33,  4.77s/it]
data 123:  29%|██▉       | 150/512 [11:17<29:07,  4.83s/it]
data 123:  29%|██▉       | 150/512 [11:54<28:44,  4.76s/it]
INFO:root:函数头: 
    def exclude(self, data, range_obj):

INFO:root:目标函数体: 
        
        if isinstance(range_obj, (pd.DatetimeIndex, tuple)):
            range_obj = DateRange(range_obj[0], range_obj[-1])
        if 'date' in data.index.names:
            return data[(data.index.get_level_values('date') < range_obj.start) | (data.index.get_level_values('date') > range_obj.end)]
        elif 'date' in data.columns:
            return data[(data.date < range_obj.start) | (data.date > range_obj.end)]
        else:
            return data

INFO:root:生成结果: 
        if isinstance(range_obj, (pd.DatetimeIndex, tuple)):
            range_obj = DateRange(range_obj[0], range_obj[-1])

        range_obj = to_pandas_closed_closed(range_obj, add_tz=False)
        start = range_obj.start
        end = range_obj.end

        if 'date' in data.index.names:
            return data[(data.index < start) | (data.index > end)]
        elif 'date' in data.columns:
            if start and end:
                return data[(data.date < start) | (data.date > end)]
            elif start:
                return data[data.date < start]
            elif end:
                return data[data.date > end]
            else:
                return data
        else:
            return data


INFO:root:----------------------------------------
INFO:root:max length: 9752
INFO:root:max position: 12426
INFO:root:target_namespace: arctic-latest.arctic<folder>.chunkstore<folder>.date_chunker<file>.DateChunker<class>.exclude<func>
INFO:root:****************************************

data 123:   0%|          | 0/512 [00:00<?, ?it/s]
data 123:   2%|▏         | 10/512 [00:40<33:35,  4.01s/it]
data 123:   4%|▍         | 20/512 [01:21<33:37,  4.10s/it]
data 123:   6%|▌         | 30/512 [02:01<32:28,  4.04s/it]
data 123:   8%|▊         | 40/512 [02:47<33:31,  4.26s/it]
data 123:  10%|▉         | 50/512 [03:28<32:27,  4.22s/it]
data 123:  12%|█▏        | 60/512 [04:10<31:39,  4.20s/it]
data 123:  14%|█▎        | 70/512 [04:55<31:37,  4.29s/it]
data 123:  16%|█▌        | 80/512 [05:40<31:24,  4.36s/it]
data 123:  18%|█▊        | 90/512 [06:25<30:54,  4.40s/it]
data 123:  20%|█▉        | 100/512 [07:13<31:05,  4.53s/it]
data 123:  21%|██▏       | 110/512 [08:00<30:47,  4.60s/it]
data 123:  23%|██▎       | 120/512 [08:44<29:36,  4.53s/it]
data 123:  25%|██▌       | 130/512 [09:32<29:24,  4.62s/it]
data 123:  27%|██▋       | 140/512 [10:22<29:15,  4.72s/it]
data 123:  29%|██▉       | 150/512 [11:11<28:48,  4.78s/it]
data 123:  29%|██▉       | 150/512 [11:47<28:27,  4.72s/it]
INFO:root:函数头: 
    def exclude(self, data, range_obj):

INFO:root:目标函数体: 
        
        if isinstance(range_obj, (pd.DatetimeIndex, tuple)):
            range_obj = DateRange(range_obj[0], range_obj[-1])
        if 'date' in data.index.names:
            return data[(data.index.get_level_values('date') < range_obj.start) | (data.index.get_level_values('date') > range_obj.end)]
        elif 'date' in data.columns:
            return data[(data.date < range_obj.start) | (data.date > range_obj.end)]
        else:
            return data

INFO:root:生成结果: 
        if isinstance(range_obj, (pd.DatetimeIndex, tuple)):
            range_obj = DateRange(range_obj[0], range_obj[-1])

        range_obj = to_pandas_closed_closed(range_obj, add_tz=False)
        start = range_obj.start
        end = range_obj.end

        if 'date' in data.index.names:
            return data[(data.index < start) | (data.index > end)]
        elif 'date' in data.columns:
            if start and end:
                return data[(data.date < start) | (data.date > end)]
            elif start:
                return data[data.date < start]
            elif end:
                return data[data.date > end]
            else:
                return data
        else:
            return data


INFO:root:----------------------------------------
INFO:root:max length: 10728
INFO:root:max position: 12455
INFO:root:target_namespace: arctic-latest.arctic<folder>.chunkstore<folder>.date_chunker<file>.DateChunker<class>.exclude<func>
INFO:root:****************************************

data 123:   0%|          | 0/512 [00:00<?, ?it/s]
data 123:   2%|▏         | 10/512 [00:40<33:38,  4.02s/it]
data 123:   4%|▍         | 20/512 [01:23<34:25,  4.20s/it]
data 123:   6%|▌         | 30/512 [02:04<33:27,  4.16s/it]
data 123:   8%|▊         | 40/512 [02:50<34:04,  4.33s/it]
data 123:  10%|▉         | 50/512 [03:31<32:34,  4.23s/it]
data 123:  12%|█▏        | 60/512 [04:13<31:58,  4.24s/it]
data 123:  14%|█▎        | 70/512 [05:00<32:24,  4.40s/it]
data 123:  16%|█▌        | 80/512 [05:45<31:50,  4.42s/it]
data 123:  18%|█▊        | 90/512 [06:30<31:09,  4.43s/it]
data 123:  20%|█▉        | 100/512 [07:20<31:39,  4.61s/it]
data 123:  21%|██▏       | 110/512 [08:05<30:39,  4.58s/it]
data 123:  23%|██▎       | 120/512 [08:50<29:47,  4.56s/it]
data 123:  25%|██▌       | 130/512 [09:35<28:58,  4.55s/it]
data 123:  27%|██▋       | 140/512 [10:23<28:40,  4.62s/it]
data 123:  29%|██▉       | 150/512 [11:11<28:10,  4.67s/it]
data 123:  29%|██▉       | 150/512 [11:57<28:50,  4.78s/it]
INFO:root:函数头: 
    def exclude(self, data, range_obj):

INFO:root:目标函数体: 
        
        if isinstance(range_obj, (pd.DatetimeIndex, tuple)):
            range_obj = DateRange(range_obj[0], range_obj[-1])
        if 'date' in data.index.names:
            return data[(data.index.get_level_values('date') < range_obj.start) | (data.index.get_level_values('date') > range_obj.end)]
        elif 'date' in data.columns:
            return data[(data.date < range_obj.start) | (data.date > range_obj.end)]
        else:
            return data

INFO:root:生成结果: 
        if isinstance(range_obj, (pd.DatetimeIndex, tuple)):
            range_obj = DateRange(range_obj[0], range_obj[-1])

        range_obj = to_pandas_closed_closed(range_obj, add_tz=False)
        start = range_obj.start
        end = range_obj.end

        if 'date' in data.index.names:
            return data[(data.index < start) | (data.index > end)]
        elif 'date' in data.columns:
            if start and end:
                return data[(data.date < start) | (data.date > end)]
            elif start:
                return data[(data.date < start)]
            elif end:
                return data[(data.date > end)]
            else:
                return data
        else:
            return data


INFO:root:----------------------------------------
INFO:root:max length: 9451
INFO:root:max position: 12538
INFO:root:target_namespace: arctic-latest.arctic<folder>.chunkstore<folder>.date_chunker<file>.DateChunker<class>.exclude<func>
INFO:root:****************************************

data 123:   0%|          | 0/512 [00:00<?, ?it/s]
data 123:   2%|▏         | 10/512 [00:40<33:41,  4.03s/it]
data 123:   4%|▍         | 20/512 [01:23<34:26,  4.20s/it]
data 123:   6%|▌         | 30/512 [02:03<33:10,  4.13s/it]
data 123:   8%|▊         | 40/512 [02:48<33:27,  4.25s/it]
data 123:  10%|▉         | 50/512 [03:28<32:05,  4.17s/it]
data 123:  12%|█▏        | 60/512 [04:11<31:50,  4.23s/it]
data 123:  14%|█▎        | 70/512 [04:57<32:01,  4.35s/it]
data 123:  16%|█▌        | 80/512 [05:43<31:41,  4.40s/it]
data 123:  18%|█▊        | 90/512 [06:29<31:30,  4.48s/it]
data 123:  20%|█▉        | 100/512 [07:16<31:17,  4.56s/it]
data 123:  21%|██▏       | 110/512 [08:05<31:07,  4.65s/it]
data 123:  23%|██▎       | 120/512 [08:49<29:51,  4.57s/it]
data 123:  25%|██▌       | 130/512 [09:36<29:20,  4.61s/it]
data 123:  27%|██▋       | 140/512 [10:26<29:22,  4.74s/it]
data 123:  29%|██▉       | 150/512 [11:13<28:33,  4.73s/it]
data 123:  29%|██▉       | 150/512 [12:00<28:59,  4.81s/it]
INFO:root:函数头: 
    def exclude(self, data, range_obj):

INFO:root:目标函数体: 
        
        if isinstance(range_obj, (pd.DatetimeIndex, tuple)):
            range_obj = DateRange(range_obj[0], range_obj[-1])
        if 'date' in data.index.names:
            return data[(data.index.get_level_values('date') < range_obj.start) | (data.index.get_level_values('date') > range_obj.end)]
        elif 'date' in data.columns:
            return data[(data.date < range_obj.start) | (data.date > range_obj.end)]
        else:
            return data

INFO:root:生成结果: 
        if isinstance(range_obj, (pd.DatetimeIndex, tuple)):
            range_obj = DateRange(range_obj[0], range_obj[-1])

        range_obj = to_pandas_closed_closed(range_obj, add_tz=False)
        start = range_obj.start
        end = range_obj.end

        if 'date' in data.index.names:
            return data[(data.index < start) | (data.index > end)]
        elif 'date' in data.columns:
            if start and end:
                return data[(data.date < start) | (data.date > end)]
            elif start:
                return data[(data.date < start)]
            elif end:
                return data[(data.date > end)]
            else:
                return data
        else:
            return data


INFO:root:----------------------------------------
INFO:root:max length: 9934
INFO:root:max position: 12538
INFO:root:target_namespace: arctic-latest.arctic<folder>.chunkstore<folder>.date_chunker<file>.DateChunker<class>.exclude<func>
INFO:root:****************************************
INFO:root:--------data 124--------

data 124:   0%|          | 0/512 [00:00<?, ?it/s]
data 124:   2%|▏         | 10/512 [00:51<42:49,  5.12s/it]
data 124:   4%|▍         | 20/512 [01:49<45:24,  5.54s/it]
data 124:   6%|▌         | 30/512 [02:47<45:32,  5.67s/it]
data 124:   8%|▊         | 40/512 [03:43<44:22,  5.64s/it]
data 124:  10%|▉         | 50/512 [04:40<43:36,  5.66s/it]
data 124:  12%|█▏        | 60/512 [05:34<41:58,  5.57s/it]
data 124:  14%|█▎        | 70/512 [06:31<41:18,  5.61s/it]
data 124:  16%|█▌        | 80/512 [07:27<40:25,  5.62s/it]
data 124:  18%|█▊        | 90/512 [08:23<39:21,  5.60s/it]
data 124:  20%|█▉        | 100/512 [09:19<38:31,  5.61s/it]
data 124:  20%|█▉        | 100/512 [10:04<41:30,  6.05s/it]
INFO:root:函数头: 
def format_proxy(proxy_config, auth=True):

INFO:root:目标函数体: 
    
    if not proxy_config.get("hostname"):
        return None

    scheme = proxy_config.get("scheme") or "http"
    username = proxy_config.get("username")
    password = proxy_config.get("password")
    hostname = proxy_config["hostname"]
    port = proxy_config.get("port")
    if not port or port < 0:
        port = 80

    if username and password and auth:
        return f"{scheme}://{username}:{password}@{hostname}:{port}"
    else:
        return f"{scheme}://{hostname}:{port}"

INFO:root:生成结果: 
    scheme = proxy_config.get("scheme")
    host = proxy_config.get("host")
    port = proxy_config.get("port")
    user = proxy_config.get("user")
    password = proxy_config.get("password")

    if scheme is None or host is None or port is None:
        return None

    proxy_string = f"{scheme}://{host}:{port}"

    if auth and user is not None and password is not None:
        proxy_string += f"@{user}:{password}"

    return proxy_string


INFO:root:----------------------------------------
INFO:root:max length: 8449
INFO:root:max position: 9094
INFO:root:target_namespace: Mopidy.mopidy<folder>.httpclient<file>.format_proxy<func>
INFO:root:****************************************

data 124:   0%|          | 0/512 [00:00<?, ?it/s]
data 124:   2%|▏         | 10/512 [00:49<41:39,  4.98s/it]
data 124:   4%|▍         | 20/512 [01:46<44:14,  5.40s/it]
data 124:   6%|▌         | 30/512 [02:44<44:48,  5.58s/it]
data 124:   8%|▊         | 40/512 [03:42<44:24,  5.64s/it]
data 124:  10%|▉         | 50/512 [04:40<44:02,  5.72s/it]
data 124:  12%|█▏        | 60/512 [05:34<42:20,  5.62s/it]
data 124:  14%|█▎        | 70/512 [06:32<41:50,  5.68s/it]
data 124:  16%|█▌        | 80/512 [07:27<40:18,  5.60s/it]
data 124:  18%|█▊        | 90/512 [08:22<39:08,  5.56s/it]
data 124:  20%|█▉        | 100/512 [09:17<38:05,  5.55s/it]
data 124:  20%|█▉        | 100/512 [10:03<41:25,  6.03s/it]
INFO:root:函数头: 
def format_proxy(proxy_config, auth=True):

INFO:root:目标函数体: 
    
    if not proxy_config.get("hostname"):
        return None

    scheme = proxy_config.get("scheme") or "http"
    username = proxy_config.get("username")
    password = proxy_config.get("password")
    hostname = proxy_config["hostname"]
    port = proxy_config.get("port")
    if not port or port < 0:
        port = 80

    if username and password and auth:
        return f"{scheme}://{username}:{password}@{hostname}:{port}"
    else:
        return f"{scheme}://{hostname}:{port}"

INFO:root:生成结果: 
    scheme = proxy_config.get("scheme")
    host = proxy_config.get("host")
    port = proxy_config.get("port")
    user = proxy_config.get("user")
    password = proxy_config.get("password")

    if scheme is None or host is None or port is None:
        return None

    proxy_string = f"{scheme}://{host}:{port}"

    if auth and user is not None and password is not None:
        proxy_string += f"@{user}:{password}"

    return proxy_string




INFO:root:----------------------------------------
INFO:root:max length: 8311
INFO:root:max position: 8882
INFO:root:target_namespace: Mopidy.mopidy<folder>.httpclient<file>.format_proxy<func>
INFO:root:****************************************

data 124:   0%|          | 0/512 [00:00<?, ?it/s]
data 124:   2%|▏         | 10/512 [00:51<43:10,  5.16s/it]
data 124:   4%|▍         | 20/512 [01:49<45:35,  5.56s/it]
data 124:   6%|▌         | 30/512 [02:46<45:06,  5.62s/it]
data 124:   8%|▊         | 40/512 [03:45<44:55,  5.71s/it]
data 124:  10%|▉         | 50/512 [04:42<44:02,  5.72s/it]
data 124:  12%|█▏        | 60/512 [05:39<43:03,  5.72s/it]
data 124:  14%|█▎        | 70/512 [06:36<42:04,  5.71s/it]
data 124:  16%|█▌        | 80/512 [07:33<41:02,  5.70s/it]
data 124:  18%|█▊        | 90/512 [08:28<39:34,  5.63s/it]
data 124:  20%|█▉        | 100/512 [09:24<38:37,  5.62s/it]
data 124:  20%|█▉        | 100/512 [10:11<41:57,  6.11s/it]
INFO:root:函数头: 
def format_proxy(proxy_config, auth=True):

INFO:root:目标函数体: 
    
    if not proxy_config.get("hostname"):
        return None

    scheme = proxy_config.get("scheme") or "http"
    username = proxy_config.get("username")
    password = proxy_config.get("password")
    hostname = proxy_config["hostname"]
    port = proxy_config.get("port")
    if not port or port < 0:
        port = 80

    if username and password and auth:
        return f"{scheme}://{username}:{password}@{hostname}:{port}"
    else:
        return f"{scheme}://{hostname}:{port}"

INFO:root:生成结果: 
    scheme = proxy_config.get("scheme")
    host = proxy_config.get("host")
    port = proxy_config.get("port")
    user = proxy_config.get("user")
    password = proxy_config.get("password")

    if scheme is None or host is None or port is None:
        return None

    proxy_string = f"{scheme}://{host}:{port}"

    if auth and user is not None and password is not None:
        proxy_string += f"@{user}:{password}"

    return proxy_string


INFO:root:----------------------------------------
INFO:root:max length: 8519
INFO:root:max position: 8922
INFO:root:target_namespace: Mopidy.mopidy<folder>.httpclient<file>.format_proxy<func>
INFO:root:****************************************

data 124:   0%|          | 0/512 [00:00<?, ?it/s]
data 124:   2%|▏         | 10/512 [00:51<42:44,  5.11s/it]
data 124:   4%|▍         | 20/512 [01:47<44:14,  5.40s/it]
data 124:   6%|▌         | 30/512 [02:45<45:07,  5.62s/it]
data 124:   8%|▊         | 40/512 [03:42<44:12,  5.62s/it]
data 124:  10%|▉         | 50/512 [04:39<43:37,  5.67s/it]
data 124:  12%|█▏        | 60/512 [05:38<43:14,  5.74s/it]
data 124:  14%|█▎        | 70/512 [06:35<42:09,  5.72s/it]
data 124:  16%|█▌        | 80/512 [07:31<41:00,  5.69s/it]
data 124:  18%|█▊        | 90/512 [08:27<39:47,  5.66s/it]
data 124:  20%|█▉        | 100/512 [09:22<38:36,  5.62s/it]
data 124:  21%|██▏       | 110/512 [10:16<37:04,  5.53s/it]
data 124:  23%|██▎       | 120/512 [11:10<35:53,  5.49s/it]
data 124:  23%|██▎       | 120/512 [11:53<38:51,  5.95s/it]
INFO:root:函数头: 
def format_proxy(proxy_config, auth=True):

INFO:root:目标函数体: 
    
    if not proxy_config.get("hostname"):
        return None

    scheme = proxy_config.get("scheme") or "http"
    username = proxy_config.get("username")
    password = proxy_config.get("password")
    hostname = proxy_config["hostname"]
    port = proxy_config.get("port")
    if not port or port < 0:
        port = 80

    if username and password and auth:
        return f"{scheme}://{username}:{password}@{hostname}:{port}"
    else:
        return f"{scheme}://{hostname}:{port}"

INFO:root:生成结果: 
    scheme = proxy_config.get("scheme", "http")
    host = proxy_config.get("host")
    port = proxy_config.get("port")
    user = proxy_config.get("user")
    password = proxy_config.get("password")
    if auth and user and password:
        return f"{scheme}://{user}:{password}@{host}:{port}"
    elif auth and user:
        return f"{scheme}://{user}@{host}:{port}"
    elif auth and password:
        return f"{scheme}://{password}@{host}:{port}"
    else:
        return f"{scheme}://{host}:{port}"


INFO:root:----------------------------------------
INFO:root:max length: 8410
INFO:root:max position: 8986
INFO:root:target_namespace: Mopidy.mopidy<folder>.httpclient<file>.format_proxy<func>
INFO:root:****************************************

data 124:   0%|          | 0/512 [00:00<?, ?it/s]
data 124:   2%|▏         | 10/512 [00:52<43:30,  5.20s/it]
data 124:   4%|▍         | 20/512 [01:49<45:26,  5.54s/it]
data 124:   6%|▌         | 30/512 [02:48<45:45,  5.70s/it]
data 124:   8%|▊         | 40/512 [03:45<44:48,  5.70s/it]
data 124:  10%|▉         | 50/512 [04:44<44:17,  5.75s/it]
data 124:  12%|█▏        | 60/512 [05:41<43:22,  5.76s/it]
data 124:  14%|█▎        | 70/512 [06:36<41:48,  5.68s/it]
data 124:  16%|█▌        | 80/512 [07:33<40:52,  5.68s/it]
data 124:  18%|█▊        | 90/512 [08:29<39:38,  5.64s/it]
data 124:  20%|█▉        | 100/512 [09:25<38:43,  5.64s/it]
data 124:  20%|█▉        | 100/512 [09:31<39:14,  5.71s/it]
INFO:root:函数头: 
def format_proxy(proxy_config, auth=True):

INFO:root:目标函数体: 
    
    if not proxy_config.get("hostname"):
        return None

    scheme = proxy_config.get("scheme") or "http"
    username = proxy_config.get("username")
    password = proxy_config.get("password")
    hostname = proxy_config["hostname"]
    port = proxy_config.get("port")
    if not port or port < 0:
        port = 80

    if username and password and auth:
        return f"{scheme}://{username}:{password}@{hostname}:{port}"
    else:
        return f"{scheme}://{hostname}:{port}"

INFO:root:生成结果: 
    scheme = proxy_config.get("scheme", "http")
    host = proxy_config.get("host")
    port = proxy_config.get("port")
    if not host or not port:
        return None
    proxy_string = f"{scheme}://{host}:{port}"
    if auth:
        username = proxy_config.get("username")
        password = proxy_config.get("password")
        if username and password:
            proxy_string += f"@{username}:{password}"
    return proxy_string


INFO:root:----------------------------------------
INFO:root:max length: 8666
INFO:root:max position: 9044
INFO:root:target_namespace: Mopidy.mopidy<folder>.httpclient<file>.format_proxy<func>
INFO:root:****************************************
INFO:root:--------data 125--------

data 125:   0%|          | 0/512 [00:00<?, ?it/s]
data 125:   2%|▏         | 10/512 [00:38<32:21,  3.87s/it]
data 125:   4%|▍         | 20/512 [01:18<32:03,  3.91s/it]
data 125:   6%|▌         | 30/512 [02:04<34:03,  4.24s/it]
data 125:   8%|▊         | 40/512 [02:40<31:20,  3.98s/it]
data 125:  10%|▉         | 50/512 [03:18<30:13,  3.92s/it]
data 125:  12%|█▏        | 60/512 [04:06<31:49,  4.23s/it]
data 125:  14%|█▎        | 70/512 [04:52<32:07,  4.36s/it]
data 125:  16%|█▌        | 80/512 [05:35<31:13,  4.34s/it]
data 125:  18%|█▊        | 90/512 [06:16<29:53,  4.25s/it]
data 125:  20%|█▉        | 100/512 [06:56<28:36,  4.17s/it]
data 125:  20%|█▉        | 100/512 [07:33<31:08,  4.54s/it]
INFO:root:函数头: 
    def filter(self, data, range_obj):

INFO:root:目标函数体: 
        
        if isinstance(range_obj, (pd.DatetimeIndex, tuple)):
            range_obj = DateRange(range_obj[0], range_obj[-1])

        range_obj = to_pandas_closed_closed(range_obj, add_tz=False)
        start = range_obj.start
        end = range_obj.end

        if 'date' in data.index.names:
            return data[start:end]
        elif 'date' in data.columns:
            if start and end:
                return data[(data.date >= start) & (data.date <= end)]
            elif start:
                return data[(data.date >= start)]
            elif end:
                return data[(data.date <= end)]
            else:
                return data
        else:
            return data

INFO:root:生成结果: 
        if isinstance(range_obj, (pd.DatetimeIndex, tuple)):
            range_obj = DateRange(range_obj[0], range_obj[-1])
        if range_obj.start and range_obj.end:
            return data[(data['date'] >= range_obj.start) & (data['date'] <= range_obj.end)]
        elif range_obj.start:
            return data[data['date'] >= range_obj.start]
        elif range_obj.end:
            return data[data['date'] <= range_obj.end]
        else:
            return data



INFO:root:----------------------------------------
INFO:root:max length: 8464
INFO:root:max position: 11438
INFO:root:target_namespace: arctic-latest.arctic<folder>.chunkstore<folder>.date_chunker<file>.DateChunker<class>.filter<func>
INFO:root:****************************************

data 125:   0%|          | 0/512 [00:00<?, ?it/s]
data 125:   2%|▏         | 10/512 [00:31<26:34,  3.18s/it]
data 125:   4%|▍         | 20/512 [01:06<27:24,  3.34s/it]
data 125:   6%|▌         | 30/512 [01:49<30:22,  3.78s/it]
data 125:   8%|▊         | 40/512 [02:26<29:23,  3.74s/it]
data 125:  10%|▉         | 50/512 [03:04<29:00,  3.77s/it]
data 125:  12%|█▏        | 60/512 [03:50<30:36,  4.06s/it]
data 125:  14%|█▎        | 70/512 [04:34<30:38,  4.16s/it]
data 125:  16%|█▌        | 80/512 [05:17<30:25,  4.23s/it]
data 125:  18%|█▊        | 90/512 [05:58<29:17,  4.16s/it]
data 125:  20%|█▉        | 100/512 [06:37<28:00,  4.08s/it]
data 125:  20%|█▉        | 100/512 [07:14<29:49,  4.34s/it]
INFO:root:函数头: 
    def filter(self, data, range_obj):

INFO:root:目标函数体: 
        
        if isinstance(range_obj, (pd.DatetimeIndex, tuple)):
            range_obj = DateRange(range_obj[0], range_obj[-1])

        range_obj = to_pandas_closed_closed(range_obj, add_tz=False)
        start = range_obj.start
        end = range_obj.end

        if 'date' in data.index.names:
            return data[start:end]
        elif 'date' in data.columns:
            if start and end:
                return data[(data.date >= start) & (data.date <= end)]
            elif start:
                return data[(data.date >= start)]
            elif end:
                return data[(data.date <= end)]
            else:
                return data
        else:
            return data

INFO:root:生成结果: 
        if isinstance(range_obj, (pd.DatetimeIndex, tuple)):
            range_obj = DateRange(range_obj[0], range_obj[-1])
        if range_obj.start and range_obj.end:
            return data[(data['date'] >= range_obj.start) & (data['date'] <= range_obj.end)]
        elif range_obj.start:
            return data[data['date'] >= range_obj.start]
        elif range_obj.end:
            return data[data['date'] <= range_obj.end]
        else:
            return data


INFO:root:----------------------------------------
INFO:root:max length: 8116
INFO:root:max position: 11950
INFO:root:target_namespace: arctic-latest.arctic<folder>.chunkstore<folder>.date_chunker<file>.DateChunker<class>.filter<func>
INFO:root:****************************************

data 125:   0%|          | 0/512 [00:00<?, ?it/s]
data 125:   2%|▏         | 10/512 [00:31<26:39,  3.19s/it]
data 125:   4%|▍         | 20/512 [01:06<27:38,  3.37s/it]
data 125:   6%|▌         | 30/512 [01:51<31:01,  3.86s/it]
data 125:   8%|▊         | 40/512 [02:25<29:04,  3.70s/it]
data 125:  10%|▉         | 50/512 [03:04<28:56,  3.76s/it]
data 125:  12%|█▏        | 60/512 [03:51<30:44,  4.08s/it]
data 125:  14%|█▎        | 70/512 [04:39<31:47,  4.32s/it]
data 125:  16%|█▌        | 80/512 [05:23<31:21,  4.36s/it]
data 125:  18%|█▊        | 90/512 [06:03<29:51,  4.25s/it]
data 125:  20%|█▉        | 100/512 [06:42<28:16,  4.12s/it]
data 125:  20%|█▉        | 100/512 [07:18<30:05,  4.38s/it]
INFO:root:函数头: 
    def filter(self, data, range_obj):

INFO:root:目标函数体: 
        
        if isinstance(range_obj, (pd.DatetimeIndex, tuple)):
            range_obj = DateRange(range_obj[0], range_obj[-1])

        range_obj = to_pandas_closed_closed(range_obj, add_tz=False)
        start = range_obj.start
        end = range_obj.end

        if 'date' in data.index.names:
            return data[start:end]
        elif 'date' in data.columns:
            if start and end:
                return data[(data.date >= start) & (data.date <= end)]
            elif start:
                return data[(data.date >= start)]
            elif end:
                return data[(data.date <= end)]
            else:
                return data
        else:
            return data

INFO:root:生成结果: 
        if isinstance(range_obj, (pd.DatetimeIndex, tuple)):
            range_obj = DateRange(range_obj[0], range_obj[-1])
        if range_obj.start and range_obj.end:
            return data[(data['date'] >= range_obj.start) & (data['date'] <= range_obj.end)]
        elif range_obj.start:
            return data[data['date'] >= range_obj.start]
        elif range_obj.end:
            return data[data['date'] <= range_obj.end]
        else:
            return data



INFO:root:----------------------------------------
INFO:root:max length: 8085
INFO:root:max position: 10990
INFO:root:target_namespace: arctic-latest.arctic<folder>.chunkstore<folder>.date_chunker<file>.DateChunker<class>.filter<func>
INFO:root:****************************************

data 125:   0%|          | 0/512 [00:00<?, ?it/s]
data 125:   2%|▏         | 10/512 [00:30<25:48,  3.09s/it]
data 125:   4%|▍         | 20/512 [01:05<27:05,  3.30s/it]
data 125:   6%|▌         | 30/512 [01:48<30:24,  3.78s/it]
data 125:   8%|▊         | 40/512 [02:24<28:58,  3.68s/it]
data 125:  10%|▉         | 50/512 [03:03<29:03,  3.77s/it]
data 125:  12%|█▏        | 60/512 [03:51<31:08,  4.13s/it]
data 125:  14%|█▎        | 70/512 [04:39<31:59,  4.34s/it]
data 125:  16%|█▌        | 80/512 [05:23<31:23,  4.36s/it]
data 125:  18%|█▊        | 90/512 [06:03<29:47,  4.23s/it]
data 125:  20%|█▉        | 100/512 [06:43<28:32,  4.16s/it]
data 125:  20%|█▉        | 100/512 [07:19<30:10,  4.39s/it]
INFO:root:函数头: 
    def filter(self, data, range_obj):

INFO:root:目标函数体: 
        
        if isinstance(range_obj, (pd.DatetimeIndex, tuple)):
            range_obj = DateRange(range_obj[0], range_obj[-1])

        range_obj = to_pandas_closed_closed(range_obj, add_tz=False)
        start = range_obj.start
        end = range_obj.end

        if 'date' in data.index.names:
            return data[start:end]
        elif 'date' in data.columns:
            if start and end:
                return data[(data.date >= start) & (data.date <= end)]
            elif start:
                return data[(data.date >= start)]
            elif end:
                return data[(data.date <= end)]
            else:
                return data
        else:
            return data

INFO:root:生成结果: 
        if isinstance(range_obj, (pd.DatetimeIndex, tuple)):
            range_obj = DateRange(range_obj[0], range_obj[-1])
        if range_obj.start and range_obj.end:
            return data[(data['date'] >= range_obj.start) & (data['date'] <= range_obj.end)]
        elif range_obj.start:
            return data[data['date'] >= range_obj.start]
        elif range_obj.end:
            return data[data['date'] <= range_obj.end]
        else:
            return data


INFO:root:----------------------------------------
INFO:root:max length: 8518
INFO:root:max position: 11191
INFO:root:target_namespace: arctic-latest.arctic<folder>.chunkstore<folder>.date_chunker<file>.DateChunker<class>.filter<func>
INFO:root:****************************************

data 125:   0%|          | 0/512 [00:00<?, ?it/s]
data 125:   2%|▏         | 10/512 [00:30<25:45,  3.08s/it]
data 125:   4%|▍         | 20/512 [01:04<26:53,  3.28s/it]
data 125:   6%|▌         | 30/512 [01:49<30:49,  3.84s/it]
data 125:   8%|▊         | 40/512 [02:24<29:03,  3.69s/it]
data 125:  10%|▉         | 50/512 [03:06<29:41,  3.86s/it]
data 125:  12%|█▏        | 60/512 [03:53<31:16,  4.15s/it]
data 125:  14%|█▎        | 70/512 [04:39<31:36,  4.29s/it]
data 125:  16%|█▌        | 80/512 [05:21<30:42,  4.27s/it]
data 125:  18%|█▊        | 90/512 [06:01<29:32,  4.20s/it]
data 125:  20%|█▉        | 100/512 [06:40<28:05,  4.09s/it]
data 125:  20%|█▉        | 100/512 [07:17<30:04,  4.38s/it]
INFO:root:函数头: 
    def filter(self, data, range_obj):

INFO:root:目标函数体: 
        
        if isinstance(range_obj, (pd.DatetimeIndex, tuple)):
            range_obj = DateRange(range_obj[0], range_obj[-1])

        range_obj = to_pandas_closed_closed(range_obj, add_tz=False)
        start = range_obj.start
        end = range_obj.end

        if 'date' in data.index.names:
            return data[start:end]
        elif 'date' in data.columns:
            if start and end:
                return data[(data.date >= start) & (data.date <= end)]
            elif start:
                return data[(data.date >= start)]
            elif end:
                return data[(data.date <= end)]
            else:
                return data
        else:
            return data

INFO:root:生成结果: 
        if isinstance(range_obj, (pd.DatetimeIndex, tuple)):
            range_obj = DateRange(range_obj[0], range_obj[-1])
        if range_obj.start and range_obj.end:
            return data[(data['date'] >= range_obj.start) & (data['date'] <= range_obj.end)]
        elif range_obj.start:
            return data[data['date'] >= range_obj.start]
        elif range_obj.end:
            return data[data['date'] <= range_obj.end]
        else:
            return data


INFO:root:----------------------------------------
INFO:root:max length: 8192
INFO:root:max position: 11160
INFO:root:target_namespace: arctic-latest.arctic<folder>.chunkstore<folder>.date_chunker<file>.DateChunker<class>.filter<func>
INFO:root:****************************************
INFO:root:--------data 126--------

data 126:   0%|          | 0/512 [00:00<?, ?it/s]
data 126:   2%|▏         | 10/512 [00:52<43:37,  5.21s/it]
data 126:   2%|▏         | 10/512 [01:43<1:26:22, 10.32s/it]
INFO:root:函数头: 
def validate_required(value, required):

INFO:root:目标函数体: 
    
    if required and not value:
        raise ValueError("must be set.")

INFO:root:生成结果: 
    if required and value is None:
        raise ValueError("Required value is missing")


INFO:root:----------------------------------------
INFO:root:max length: 8138
INFO:root:max position: 8872
INFO:root:target_namespace: Mopidy.mopidy<folder>.config<folder>.validators<file>.validate_required<func>
INFO:root:****************************************

data 126:   0%|          | 0/512 [00:00<?, ?it/s]
data 126:   2%|▏         | 10/512 [00:52<43:32,  5.21s/it]
data 126:   2%|▏         | 10/512 [01:37<1:21:42,  9.77s/it]
INFO:root:函数头: 
def validate_required(value, required):

INFO:root:目标函数体: 
    
    if required and not value:
        raise ValueError("must be set.")

INFO:root:生成结果: 
    if required and value is None:
        raise ValueError("Value is required")


INFO:root:----------------------------------------
INFO:root:max length: 8097
INFO:root:max position: 8588
INFO:root:target_namespace: Mopidy.mopidy<folder>.config<folder>.validators<file>.validate_required<func>
INFO:root:****************************************

data 126:   0%|          | 0/512 [00:00<?, ?it/s]
data 126:   2%|▏         | 10/512 [00:51<42:54,  5.13s/it]
data 126:   2%|▏         | 10/512 [01:36<1:21:00,  9.68s/it]
INFO:root:函数头: 
def validate_required(value, required):

INFO:root:目标函数体: 
    
    if required and not value:
        raise ValueError("must be set.")

INFO:root:生成结果: 
    if required and value is None:
        raise ValueError("Value is required")


INFO:root:----------------------------------------
INFO:root:max length: 8332
INFO:root:max position: 8640
INFO:root:target_namespace: Mopidy.mopidy<folder>.config<folder>.validators<file>.validate_required<func>
INFO:root:****************************************

data 126:   0%|          | 0/512 [00:00<?, ?it/s]
data 126:   2%|▏         | 10/512 [00:52<43:40,  5.22s/it]
data 126:   2%|▏         | 10/512 [01:48<1:30:53, 10.86s/it]
INFO:root:函数头: 
def validate_required(value, required):

INFO:root:目标函数体: 
    
    if required and not value:
        raise ValueError("must be set.")

INFO:root:生成结果: 
    if required and value is None:
        raise ValueError("Required value is not set")


INFO:root:----------------------------------------
INFO:root:max length: 7941
INFO:root:max position: 8606
INFO:root:target_namespace: Mopidy.mopidy<folder>.config<folder>.validators<file>.validate_required<func>
INFO:root:****************************************

data 126:   0%|          | 0/512 [00:00<?, ?it/s]
data 126:   2%|▏         | 10/512 [00:51<43:25,  5.19s/it]
data 126:   2%|▏         | 10/512 [01:42<1:25:36, 10.23s/it]
INFO:root:函数头: 
def validate_required(value, required):

INFO:root:目标函数体: 
    
    if required and not value:
        raise ValueError("must be set.")

INFO:root:生成结果: 
    if required and value is None:
        raise ValueError("Configuration value is required")


INFO:root:----------------------------------------
INFO:root:max length: 8176
INFO:root:max position: 8579
INFO:root:target_namespace: Mopidy.mopidy<folder>.config<folder>.validators<file>.validate_required<func>
INFO:root:****************************************
INFO:root:--------data 127--------

data 127:   0%|          | 0/512 [00:00<?, ?it/s]
data 127:   2%|▏         | 10/512 [00:52<44:12,  5.28s/it]
data 127:   4%|▍         | 20/512 [01:48<44:54,  5.48s/it]
data 127:   6%|▌         | 30/512 [02:44<44:18,  5.52s/it]
data 127:   6%|▌         | 30/512 [03:01<48:35,  6.05s/it]
INFO:root:函数头: 
def validate_choice(value, choices):

INFO:root:目标函数体: 
    
    if choices is not None and value not in choices:
        names = ", ".join(repr(c) for c in choices)
        raise ValueError(f"must be one of {names}, not {value}.")

INFO:root:生成结果: 
    if value not in choices:
        raise ValueError(
            f"must be one of {', '.join(choices)}, not {value}."
        )


INFO:root:----------------------------------------
INFO:root:max length: 8247
INFO:root:max position: 9018
INFO:root:target_namespace: Mopidy.mopidy<folder>.config<folder>.validators<file>.validate_choice<func>
INFO:root:****************************************

data 127:   0%|          | 0/512 [00:00<?, ?it/s]
data 127:   2%|▏         | 10/512 [00:52<44:13,  5.29s/it]
data 127:   4%|▍         | 20/512 [01:49<44:59,  5.49s/it]
data 127:   6%|▌         | 30/512 [02:44<44:06,  5.49s/it]
data 127:   6%|▌         | 30/512 [02:55<46:57,  5.84s/it]
INFO:root:函数头: 
def validate_choice(value, choices):

INFO:root:目标函数体: 
    
    if choices is not None and value not in choices:
        names = ", ".join(repr(c) for c in choices)
        raise ValueError(f"must be one of {names}, not {value}.")

INFO:root:生成结果: 
    if value not in choices:
        raise ValueError(
            f"must be one of {', '.join(choices)}, not {value}"
        )


INFO:root:----------------------------------------
INFO:root:max length: 8228
INFO:root:max position: 8864
INFO:root:target_namespace: Mopidy.mopidy<folder>.config<folder>.validators<file>.validate_choice<func>
INFO:root:****************************************

data 127:   0%|          | 0/512 [00:00<?, ?it/s]
data 127:   2%|▏         | 10/512 [00:52<43:47,  5.23s/it]
data 127:   4%|▍         | 20/512 [01:47<44:26,  5.42s/it]
data 127:   6%|▌         | 30/512 [02:42<43:33,  5.42s/it]
data 127:   6%|▌         | 30/512 [02:59<48:08,  5.99s/it]
INFO:root:函数头: 
def validate_choice(value, choices):

INFO:root:目标函数体: 
    
    if choices is not None and value not in choices:
        names = ", ".join(repr(c) for c in choices)
        raise ValueError(f"must be one of {names}, not {value}.")

INFO:root:生成结果: 
    if value not in choices:
        raise ValueError(
            f"must be one of {', '.join(choices)}, not {value}."
        )


INFO:root:----------------------------------------
INFO:root:max length: 8185
INFO:root:max position: 8871
INFO:root:target_namespace: Mopidy.mopidy<folder>.config<folder>.validators<file>.validate_choice<func>
INFO:root:****************************************

data 127:   0%|          | 0/512 [00:00<?, ?it/s]
data 127:   2%|▏         | 10/512 [00:52<43:38,  5.22s/it]
data 127:   4%|▍         | 20/512 [01:46<44:03,  5.37s/it]
data 127:   6%|▌         | 30/512 [02:42<43:48,  5.45s/it]
data 127:   6%|▌         | 30/512 [02:53<46:23,  5.78s/it]
INFO:root:函数头: 
def validate_choice(value, choices):

INFO:root:目标函数体: 
    
    if choices is not None and value not in choices:
        names = ", ".join(repr(c) for c in choices)
        raise ValueError(f"must be one of {names}, not {value}.")

INFO:root:生成结果: 
    if value not in choices:
        raise ValueError(
            f"must be one of {', '.join(choices)}, not {value}"
        )


INFO:root:----------------------------------------
INFO:root:max length: 8079
INFO:root:max position: 8694
INFO:root:target_namespace: Mopidy.mopidy<folder>.config<folder>.validators<file>.validate_choice<func>
INFO:root:****************************************

data 127:   0%|          | 0/512 [00:00<?, ?it/s]
data 127:   2%|▏         | 10/512 [00:52<44:18,  5.30s/it]
data 127:   4%|▍         | 20/512 [01:49<45:20,  5.53s/it]
data 127:   4%|▍         | 20/512 [02:39<1:05:31,  7.99s/it]
INFO:root:函数头: 
def validate_choice(value, choices):

INFO:root:目标函数体: 
    
    if choices is not None and value not in choices:
        names = ", ".join(repr(c) for c in choices)
        raise ValueError(f"must be one of {names}, not {value}.")

INFO:root:生成结果: 
    if value not in choices:
        raise ValueError(f"must be one of { ', '.join(choices)}, not {value}.")


INFO:root:----------------------------------------
INFO:root:max length: 8176
INFO:root:max position: 8856
INFO:root:target_namespace: Mopidy.mopidy<folder>.config<folder>.validators<file>.validate_choice<func>
INFO:root:****************************************
INFO:root:已生成127条结果
INFO:root:--------data 128--------

data 128:   0%|          | 0/512 [00:00<?, ?it/s]
data 128:   2%|▏         | 10/512 [00:53<45:01,  5.38s/it]
data 128:   4%|▍         | 20/512 [01:45<43:04,  5.25s/it]
data 128:   4%|▍         | 20/512 [02:22<58:13,  7.10s/it]
INFO:root:函数头: 
def validate_minimum(value, minimum):

INFO:root:目标函数体: 
    
    if minimum is not None and value < minimum:
        raise ValueError(f"{value!r} must be larger than {minimum!r}.")

INFO:root:生成结果: 
    if value < minimum:
        raise ValueError(f"{value!r} must be larger than {minimum!r}.")


INFO:root:----------------------------------------
INFO:root:max length: 8509
INFO:root:max position: 9170
INFO:root:target_namespace: Mopidy.mopidy<folder>.config<folder>.validators<file>.validate_minimum<func>
INFO:root:****************************************

data 128:   0%|          | 0/512 [00:00<?, ?it/s]
data 128:   2%|▏         | 10/512 [00:53<44:29,  5.32s/it]
data 128:   4%|▍         | 20/512 [01:45<42:59,  5.24s/it]
data 128:   4%|▍         | 20/512 [02:22<58:20,  7.12s/it]
INFO:root:函数头: 
def validate_minimum(value, minimum):

INFO:root:目标函数体: 
    
    if minimum is not None and value < minimum:
        raise ValueError(f"{value!r} must be larger than {minimum!r}.")

INFO:root:生成结果: 
    if value < minimum:
        raise ValueError(f"{value!r} must be larger than {minimum!r}.")


INFO:root:----------------------------------------
INFO:root:max length: 8321
INFO:root:max position: 9168
INFO:root:target_namespace: Mopidy.mopidy<folder>.config<folder>.validators<file>.validate_minimum<func>
INFO:root:****************************************

data 128:   0%|          | 0/512 [00:00<?, ?it/s]
data 128:   2%|▏         | 10/512 [00:52<43:42,  5.22s/it]
data 128:   4%|▍         | 20/512 [01:43<42:27,  5.18s/it]
data 128:   4%|▍         | 20/512 [02:20<57:33,  7.02s/it]
INFO:root:函数头: 
def validate_minimum(value, minimum):

INFO:root:目标函数体: 
    
    if minimum is not None and value < minimum:
        raise ValueError(f"{value!r} must be larger than {minimum!r}.")

INFO:root:生成结果: 
    if value < minimum:
        raise ValueError(f"{value!r} must be larger than {minimum!r}.")


INFO:root:----------------------------------------
INFO:root:max length: 8148
INFO:root:max position: 9404
INFO:root:target_namespace: Mopidy.mopidy<folder>.config<folder>.validators<file>.validate_minimum<func>
INFO:root:****************************************

data 128:   0%|          | 0/512 [00:00<?, ?it/s]
data 128:   2%|▏         | 10/512 [00:52<43:36,  5.21s/it]
data 128:   4%|▍         | 20/512 [01:43<42:18,  5.16s/it]
data 128:   4%|▍         | 20/512 [02:19<57:04,  6.96s/it]
INFO:root:函数头: 
def validate_minimum(value, minimum):

INFO:root:目标函数体: 
    
    if minimum is not None and value < minimum:
        raise ValueError(f"{value!r} must be larger than {minimum!r}.")

INFO:root:生成结果: 
    if value < minimum:
        raise ValueError(f"{value!r} must be larger than {minimum!r}.")


INFO:root:----------------------------------------
INFO:root:max length: 8480
INFO:root:max position: 8946
INFO:root:target_namespace: Mopidy.mopidy<folder>.config<folder>.validators<file>.validate_minimum<func>
INFO:root:****************************************

data 128:   0%|          | 0/512 [00:00<?, ?it/s]
data 128:   2%|▏         | 10/512 [00:52<44:20,  5.30s/it]
data 128:   4%|▍         | 20/512 [01:45<43:20,  5.29s/it]
data 128:   4%|▍         | 20/512 [02:22<58:27,  7.13s/it]
INFO:root:函数头: 
def validate_minimum(value, minimum):

INFO:root:目标函数体: 
    
    if minimum is not None and value < minimum:
        raise ValueError(f"{value!r} must be larger than {minimum!r}.")

INFO:root:生成结果: 
    if value < minimum:
        raise ValueError(f"{value!r} must be larger than {minimum!r}.")


INFO:root:----------------------------------------
INFO:root:max length: 8087
INFO:root:max position: 8931
INFO:root:target_namespace: Mopidy.mopidy<folder>.config<folder>.validators<file>.validate_minimum<func>
INFO:root:****************************************
INFO:root:--------data 129--------

data 129:   0%|          | 0/512 [00:00<?, ?it/s]
data 129:   2%|▏         | 10/512 [00:50<42:08,  5.04s/it]
data 129:   4%|▍         | 20/512 [01:45<43:38,  5.32s/it]
data 129:   6%|▌         | 30/512 [02:38<42:35,  5.30s/it]
data 129:   6%|▌         | 30/512 [02:48<45:13,  5.63s/it]
INFO:root:函数头: 
def validate_maximum(value, maximum):

INFO:root:目标函数体: 
    
    if maximum is not None and value > maximum:
        raise ValueError(f"{value!r} must be smaller than {maximum!r}.")

INFO:root:生成结果: 
    if maximum is not None and value > maximum:
        raise ValueError(f"{value!r} must be smaller than {maximum!r}.")


INFO:root:----------------------------------------
INFO:root:max length: 8691
INFO:root:max position: 9204
INFO:root:target_namespace: Mopidy.mopidy<folder>.config<folder>.validators<file>.validate_maximum<func>
INFO:root:****************************************

data 129:   0%|          | 0/512 [00:00<?, ?it/s]
data 129:   2%|▏         | 10/512 [00:49<41:30,  4.96s/it]
data 129:   4%|▍         | 20/512 [01:44<43:11,  5.27s/it]
data 129:   6%|▌         | 30/512 [02:37<42:22,  5.27s/it]
data 129:   6%|▌         | 30/512 [02:48<45:01,  5.61s/it]
INFO:root:函数头: 
def validate_maximum(value, maximum):

INFO:root:目标函数体: 
    
    if maximum is not None and value > maximum:
        raise ValueError(f"{value!r} must be smaller than {maximum!r}.")

INFO:root:生成结果: 
    if maximum is not None and value > maximum:
        raise ValueError(f"{value!r} must be smaller than {maximum!r}.")


INFO:root:----------------------------------------
INFO:root:max length: 8822
INFO:root:max position: 9199
INFO:root:target_namespace: Mopidy.mopidy<folder>.config<folder>.validators<file>.validate_maximum<func>
INFO:root:****************************************

data 129:   0%|          | 0/512 [00:00<?, ?it/s]
data 129:   2%|▏         | 10/512 [00:49<41:05,  4.91s/it]
data 129:   4%|▍         | 20/512 [01:44<43:04,  5.25s/it]
data 129:   6%|▌         | 30/512 [02:37<42:30,  5.29s/it]
data 129:   6%|▌         | 30/512 [02:47<44:55,  5.59s/it]
INFO:root:函数头: 
def validate_maximum(value, maximum):

INFO:root:目标函数体: 
    
    if maximum is not None and value > maximum:
        raise ValueError(f"{value!r} must be smaller than {maximum!r}.")

INFO:root:生成结果: 
    if maximum is not None and value > maximum:
        raise ValueError(f"{value!r} must be smaller than {maximum!r}.")


INFO:root:----------------------------------------
INFO:root:max length: 8595
INFO:root:max position: 8980
INFO:root:target_namespace: Mopidy.mopidy<folder>.config<folder>.validators<file>.validate_maximum<func>
INFO:root:****************************************

data 129:   0%|          | 0/512 [00:00<?, ?it/s]
data 129:   2%|▏         | 10/512 [00:48<40:22,  4.83s/it]
data 129:   4%|▍         | 20/512 [01:42<42:20,  5.16s/it]
data 129:   6%|▌         | 30/512 [02:35<42:14,  5.26s/it]
data 129:   6%|▌         | 30/512 [02:47<44:43,  5.57s/it]
INFO:root:函数头: 
def validate_maximum(value, maximum):

INFO:root:目标函数体: 
    
    if maximum is not None and value > maximum:
        raise ValueError(f"{value!r} must be smaller than {maximum!r}.")

INFO:root:生成结果: 
    if maximum is not None and value > maximum:
        raise ValueError(f"{value!r} must be smaller than {maximum!r}.")


INFO:root:----------------------------------------
INFO:root:max length: 8749
INFO:root:max position: 9043
INFO:root:target_namespace: Mopidy.mopidy<folder>.config<folder>.validators<file>.validate_maximum<func>
INFO:root:****************************************

data 129:   0%|          | 0/512 [00:00<?, ?it/s]
data 129:   2%|▏         | 10/512 [00:49<41:35,  4.97s/it]
data 129:   4%|▍         | 20/512 [01:45<43:38,  5.32s/it]
data 129:   6%|▌         | 30/512 [02:40<43:18,  5.39s/it]
data 129:   6%|▌         | 30/512 [02:50<45:33,  5.67s/it]
INFO:root:函数头: 
def validate_maximum(value, maximum):

INFO:root:目标函数体: 
    
    if maximum is not None and value > maximum:
        raise ValueError(f"{value!r} must be smaller than {maximum!r}.")

INFO:root:生成结果: 
    if maximum is not None and value > maximum:
        raise ValueError(f"{value!r} must be smaller than {maximum!r}.")


INFO:root:----------------------------------------
INFO:root:max length: 8487
INFO:root:max position: 8953
INFO:root:target_namespace: Mopidy.mopidy<folder>.config<folder>.validators<file>.validate_maximum<func>
INFO:root:****************************************
INFO:root:--------data 130--------

data 130:   0%|          | 0/512 [00:00<?, ?it/s]
data 130:   2%|▏         | 10/512 [00:49<41:23,  4.95s/it]
data 130:   4%|▍         | 20/512 [01:46<44:24,  5.42s/it]
data 130:   6%|▌         | 30/512 [02:40<43:22,  5.40s/it]
data 130:   8%|▊         | 40/512 [03:34<42:24,  5.39s/it]
data 130:  10%|▉         | 50/512 [04:28<41:33,  5.40s/it]
data 130:  12%|█▏        | 60/512 [05:22<40:46,  5.41s/it]
data 130:  14%|█▎        | 70/512 [06:18<40:07,  5.45s/it]
data 130:  14%|█▎        | 70/512 [06:39<42:03,  5.71s/it]
INFO:root:函数头: 
def _did_you_mean(name, choices):

INFO:root:目标函数体: 
    
    if not choices:
        return None

    name = name.lower()
    candidates = [(_levenshtein(name, c), c) for c in choices]
    candidates.sort()

    if candidates[0][0] <= 3:
        return candidates[0][1]
    return None

INFO:root:生成结果: 
    import Levenshtein

    if not choices:
        return None

    distances = [(choice, Levenshtein.distance(name.lower(), choice.lower())) for choice in choices]
    distances.sort(key=lambda x: x[1])

    for choice, distance in distances:
        if distance <= 3:
            return choice

    return None




INFO:root:----------------------------------------
INFO:root:max length: 8736
INFO:root:max position: 9501
INFO:root:target_namespace: Mopidy.mopidy<folder>.config<folder>.schemas<file>._did_you_mean<func>
INFO:root:****************************************

data 130:   0%|          | 0/512 [00:00<?, ?it/s]
data 130:   2%|▏         | 10/512 [00:51<42:49,  5.12s/it]
data 130:   4%|▍         | 20/512 [01:48<44:51,  5.47s/it]
data 130:   6%|▌         | 30/512 [02:42<43:38,  5.43s/it]
data 130:   8%|▊         | 40/512 [03:37<43:06,  5.48s/it]
data 130:  10%|▉         | 50/512 [04:33<42:25,  5.51s/it]
data 130:  12%|█▏        | 60/512 [05:26<40:56,  5.43s/it]
data 130:  14%|█▎        | 70/512 [06:20<40:04,  5.44s/it]
data 130:  14%|█▎        | 70/512 [06:47<42:51,  5.82s/it]
INFO:root:函数头: 
def _did_you_mean(name, choices):

INFO:root:目标函数体: 
    
    if not choices:
        return None

    name = name.lower()
    candidates = [(_levenshtein(name, c), c) for c in choices]
    candidates.sort()

    if candidates[0][0] <= 3:
        return candidates[0][1]
    return None

INFO:root:生成结果: 
    import Levenshtein

    if not choices:
        return None

    distances = [(choice, Levenshtein.distance(name.lower(), choice.lower())) for choice in choices]
    distances.sort(key=lambda x: x[1])

    if distances[0][1] > 3:
        return None

    return distances[0][0]




INFO:root:----------------------------------------
INFO:root:max length: 8725
INFO:root:max position: 9115
INFO:root:target_namespace: Mopidy.mopidy<folder>.config<folder>.schemas<file>._did_you_mean<func>
INFO:root:****************************************

data 130:   0%|          | 0/512 [00:00<?, ?it/s]
data 130:   2%|▏         | 10/512 [00:54<45:42,  5.46s/it]
data 130:   4%|▍         | 20/512 [01:52<46:15,  5.64s/it]
data 130:   6%|▌         | 30/512 [02:48<45:11,  5.63s/it]
data 130:   8%|▊         | 40/512 [08:01<2:04:09, 15.78s/it]
data 130:  10%|▉         | 50/512 [08:55<1:32:42, 12.04s/it]
data 130:  12%|█▏        | 60/512 [09:49<1:13:33,  9.77s/it]
data 130:  14%|█▎        | 70/512 [10:43<1:01:27,  8.34s/it]
data 130:  16%|█▌        | 80/512 [11:38<53:34,  7.44s/it]  
data 130:  18%|█▊        | 90/512 [12:35<48:27,  6.89s/it]
data 130:  20%|█▉        | 100/512 [13:28<44:02,  6.41s/it]
data 130:  21%|██▏       | 110/512 [14:21<40:39,  6.07s/it]
data 130:  23%|██▎       | 120/512 [15:14<37:59,  5.82s/it]
data 130:  25%|██▌       | 130/512 [16:06<35:52,  5.63s/it]
data 130:  27%|██▋       | 140/512 [16:57<33:59,  5.48s/it]
data 130:  29%|██▉       | 150/512 [17:50<32:38,  5.41s/it]
data 130:  31%|███▏      | 160/512 [18:42<31:31,  5.37s/it]
data 130:  33%|███▎      | 170/512 [19:36<30:31,  5.36s/it]
data 130:  35%|███▌      | 180/512 [20:29<29:33,  5.34s/it]
data 130:  37%|███▋      | 190/512 [21:21<28:33,  5.32s/it]
data 130:  39%|███▉      | 200/512 [22:16<27:52,  5.36s/it]
data 130:  41%|████      | 210/512 [23:09<26:54,  5.34s/it]
data 130:  43%|████▎     | 220/512 [24:04<26:17,  5.40s/it]
data 130:  45%|████▍     | 230/512 [24:57<25:14,  5.37s/it]
data 130:  47%|████▋     | 240/512 [25:53<24:34,  5.42s/it]
data 130:  49%|████▉     | 250/512 [26:48<23:49,  5.46s/it]
data 130:  51%|█████     | 260/512 [27:43<22:55,  5.46s/it]
data 130:  53%|█████▎    | 270/512 [28:40<22:17,  5.53s/it]
data 130:  53%|█████▎    | 270/512 [29:14<26:12,  6.50s/it]
INFO:root:函数头: 
def _did_you_mean(name, choices):

INFO:root:目标函数体: 
    
    if not choices:
        return None

    name = name.lower()
    candidates = [(_levenshtein(name, c), c) for c in choices]
    candidates.sort()

    if candidates[0][0] <= 3:
        return candidates[0][1]
    return None

INFO:root:生成结果: 
    if not choices:
        return None

    def levenshtein_distance(a, b):
        """Calculate the Levenshtein distance between two strings."""
        if len(a) > len(b):
            a, b = b, a

        # Initialize the distance matrix
        distances = range(len(a) + 1)
        for i in range(1, len(b) + 1):
            previous_diagonal = distances[0]
            distances[0] = i
            for j in range(1, len(a) + 1):
                previous_diagonal, distances[j] = (
                    distances[j],
                    min(
                        distances[j] + 1,
                        distances[j - 1] + 1,
                        previous_diagonal + (a[j - 1] != b[i - 1]),
                    ),
                )

        return distances[len(a)]

    # Calculate Levenshtein distances and sort choices by distance
    distances = [(name, levenshtein_distance(name, choice)) for choice in choices]
    sorted_choices = sorted(distances, key=lambda x: x[1])

    # Return the most likely setting if the distance is less than or equal to 3
    for name, distance in sorted_choices:
        if distance <= 3:
            return name

    return None


INFO:root:----------------------------------------
INFO:root:max length: 9011
INFO:root:max position: 9404
INFO:root:target_namespace: Mopidy.mopidy<folder>.config<folder>.schemas<file>._did_you_mean<func>
INFO:root:****************************************

data 130:   0%|          | 0/512 [00:00<?, ?it/s]
data 130:   2%|▏         | 10/512 [00:48<40:36,  4.85s/it]
data 130:   4%|▍         | 20/512 [01:46<44:32,  5.43s/it]
data 130:   6%|▌         | 30/512 [02:41<43:41,  5.44s/it]
data 130:   8%|▊         | 40/512 [03:35<42:34,  5.41s/it]
data 130:  10%|▉         | 50/512 [04:30<41:56,  5.45s/it]
data 130:  12%|█▏        | 60/512 [05:26<41:31,  5.51s/it]
data 130:  14%|█▎        | 70/512 [06:20<40:25,  5.49s/it]
data 130:  14%|█▎        | 70/512 [06:42<42:23,  5.76s/it]
INFO:root:函数头: 
def _did_you_mean(name, choices):

INFO:root:目标函数体: 
    
    if not choices:
        return None

    name = name.lower()
    candidates = [(_levenshtein(name, c), c) for c in choices]
    candidates.sort()

    if candidates[0][0] <= 3:
        return candidates[0][1]
    return None

INFO:root:生成结果: 
    import Levenshtein
    if not choices:
        return None

    distances = [(choice, Levenshtein.distance(name.lower(), choice.lower())) for choice in choices]
    distances.sort(key=lambda x: x[1])

    for choice, distance in distances:
        if distance <= 3:
            return choice

    return None


INFO:root:----------------------------------------
INFO:root:max length: 8646
INFO:root:max position: 9035
INFO:root:target_namespace: Mopidy.mopidy<folder>.config<folder>.schemas<file>._did_you_mean<func>
INFO:root:****************************************

data 130:   0%|          | 0/512 [00:00<?, ?it/s]
data 130:   2%|▏         | 10/512 [00:54<45:23,  5.43s/it]
data 130:   4%|▍         | 20/512 [01:51<46:05,  5.62s/it]
data 130:   6%|▌         | 30/512 [02:48<45:21,  5.65s/it]
data 130:   8%|▊         | 40/512 [03:41<43:17,  5.50s/it]
data 130:  10%|▉         | 50/512 [04:37<42:32,  5.52s/it]
data 130:  12%|█▏        | 60/512 [05:32<41:32,  5.52s/it]
data 130:  14%|█▎        | 70/512 [19:44<3:52:39, 31.58s/it]
data 130:  16%|█▌        | 80/512 [23:53<3:32:09, 29.47s/it]
data 130:  18%|█▊        | 90/512 [24:49<2:34:36, 21.98s/it]
data 130:  20%|█▉        | 100/512 [25:42<1:55:45, 16.86s/it]
data 130:  21%|██▏       | 110/512 [26:38<1:29:45, 13.40s/it]
data 130:  23%|██▎       | 120/512 [27:32<1:11:34, 10.95s/it]
data 130:  25%|██▌       | 130/512 [28:27<59:17,  9.31s/it]  
data 130:  27%|██▋       | 140/512 [29:21<50:23,  8.13s/it]
data 130:  29%|██▉       | 150/512 [30:14<43:54,  7.28s/it]
data 130:  31%|███▏      | 160/512 [31:07<39:15,  6.69s/it]
data 130:  33%|███▎      | 170/512 [32:01<35:56,  6.31s/it]
data 130:  35%|███▌      | 180/512 [32:58<33:46,  6.10s/it]
data 130:  37%|███▋      | 190/512 [33:52<31:41,  5.91s/it]
data 130:  39%|███▉      | 200/512 [34:47<30:07,  5.79s/it]
data 130:  41%|████      | 210/512 [35:44<28:58,  5.76s/it]
data 130:  43%|████▎     | 220/512 [36:41<27:53,  5.73s/it]
data 130:  45%|████▍     | 230/512 [37:37<26:44,  5.69s/it]
data 130:  47%|████▋     | 240/512 [38:34<25:48,  5.69s/it]
data 130:  49%|████▉     | 250/512 [39:32<25:03,  5.74s/it]
data 130:  49%|████▉     | 250/512 [40:14<42:10,  9.66s/it]
INFO:root:函数头: 
def _did_you_mean(name, choices):

INFO:root:目标函数体: 
    
    if not choices:
        return None

    name = name.lower()
    candidates = [(_levenshtein(name, c), c) for c in choices]
    candidates.sort()

    if candidates[0][0] <= 3:
        return candidates[0][1]
    return None

INFO:root:生成结果: 
    if not choices:
        return None

    def levenshtein_distance(a, b):
        if len(a) > len(b):
            a, b = b, a

        # Initialize the distance array
        distance = range(len(a) + 1)
        for i in range(1, len(b) + 1):
            previous_diagonal = distance[0]
            distance[0] = i
            for j in range(1, len(a) + 1):
                previous_current = distance[j]
                if b[i - 1] == a[j - 1]:
                    distance[j] = previous_diagonal
                else:
                    distance[j] = min(distance[j], distance[j - 1], previous_diagonal) + 1
                previous_diagonal = previous_current

        return distance[len(a)]

    # Calculate Levenshtein distances and sort choices based on them
    distances = [(levenshtein_distance(name, choice), choice) for choice in choices]
    distances.sort()

    # Return the most likely setting if the distance is less than or equal to 3
    for distance, choice in distances:
        if distance <= 3:
            return choice

    return None


INFO:root:----------------------------------------
INFO:root:max length: 8858
INFO:root:max position: 9532
INFO:root:target_namespace: Mopidy.mopidy<folder>.config<folder>.schemas<file>._did_you_mean<func>
INFO:root:****************************************
INFO:root:--------data 131--------

data 131:   0%|          | 0/512 [00:00<?, ?it/s]
data 131:   2%|▏         | 10/512 [00:56<47:28,  5.67s/it]
data 131:   4%|▍         | 20/512 [01:52<46:01,  5.61s/it]
data 131:   6%|▌         | 30/512 [02:47<44:48,  5.58s/it]
data 131:   8%|▊         | 40/512 [03:43<43:52,  5.58s/it]
data 131:  10%|▉         | 50/512 [06:40<1:16:40,  9.96s/it]
data 131:  10%|▉         | 50/512 [07:27<1:08:52,  8.95s/it]
INFO:root:函数头: 
def encode(value):

INFO:root:目标函数体: 
    if isinstance(value, bytes):
        value = value.decode(errors="surrogateescape")

    for char in ("\\", "\n", "\t"):
        value = value.replace(
            char, char.encode(encoding="unicode-escape").decode()
        )

    return value

INFO:root:生成结果: 
    if isinstance(value, bytes):
        value = value.decode(errors="surrogateescape")
    for char in ("\\", "\n", "\t"):
        value = value.replace(
            char.encode(encoding="unicode-escape").decode(), char
        )
    return value




INFO:root:----------------------------------------
INFO:root:max length: 8419
INFO:root:max position: 9042
INFO:root:target_namespace: Mopidy.mopidy<folder>.config<folder>.types<file>.encode<func>
INFO:root:****************************************

data 131:   0%|          | 0/512 [00:00<?, ?it/s]
data 131:   2%|▏         | 10/512 [00:56<47:30,  5.68s/it]
data 131:   4%|▍         | 20/512 [01:54<47:08,  5.75s/it]
data 131:   6%|▌         | 30/512 [02:48<44:58,  5.60s/it]
data 131:   8%|▊         | 40/512 [03:46<44:25,  5.65s/it]
data 131:  10%|▉         | 50/512 [04:42<43:26,  5.64s/it]
data 131:  10%|▉         | 50/512 [05:26<50:18,  6.53s/it]
INFO:root:函数头: 
def encode(value):

INFO:root:目标函数体: 
    if isinstance(value, bytes):
        value = value.decode(errors="surrogateescape")

    for char in ("\\", "\n", "\t"):
        value = value.replace(
            char, char.encode(encoding="unicode-escape").decode()
        )

    return value

INFO:root:生成结果: 
    if isinstance(value, bytes):
        value = value.decode(errors="surrogateescape")

    for char in ("\\", "\n", "\t"):
        value = value.replace(
            char.encode(encoding="unicode-escape").decode(), char
        )

    return value


INFO:root:----------------------------------------
INFO:root:max length: 8443
INFO:root:max position: 8829
INFO:root:target_namespace: Mopidy.mopidy<folder>.config<folder>.types<file>.encode<func>
INFO:root:****************************************

data 131:   0%|          | 0/512 [00:00<?, ?it/s]
data 131:   2%|▏         | 10/512 [00:51<43:10,  5.16s/it]
data 131:   4%|▍         | 20/512 [01:49<45:21,  5.53s/it]
data 131:   6%|▌         | 30/512 [02:46<44:51,  5.58s/it]
data 131:   8%|▊         | 40/512 [03:42<44:09,  5.61s/it]
data 131:  10%|▉         | 50/512 [04:35<42:17,  5.49s/it]
data 131:  10%|▉         | 50/512 [05:20<49:18,  6.40s/it]
INFO:root:函数头: 
def encode(value):

INFO:root:目标函数体: 
    if isinstance(value, bytes):
        value = value.decode(errors="surrogateescape")

    for char in ("\\", "\n", "\t"):
        value = value.replace(
            char, char.encode(encoding="unicode-escape").decode()
        )

    return value

INFO:root:生成结果: 
    if isinstance(value, bytes):
        value = value.decode(errors="surrogateescape")
    for char in ("\\", "\n", "\t"):
        value = value.replace(
            char.encode(encoding="unicode-escape").decode(), char
        )
    return value


INFO:root:----------------------------------------
INFO:root:max length: 8481
INFO:root:max position: 9249
INFO:root:target_namespace: Mopidy.mopidy<folder>.config<folder>.types<file>.encode<func>
INFO:root:****************************************

data 131:   0%|          | 0/512 [00:00<?, ?it/s]
data 131:   2%|▏         | 10/512 [00:53<44:47,  5.35s/it]
data 131:   4%|▍         | 20/512 [01:50<45:25,  5.54s/it]
data 131:   6%|▌         | 30/512 [02:44<43:57,  5.47s/it]
data 131:   8%|▊         | 40/512 [03:40<43:34,  5.54s/it]
data 131:  10%|▉         | 50/512 [04:33<42:05,  5.47s/it]
data 131:  10%|▉         | 50/512 [05:20<49:25,  6.42s/it]
INFO:root:函数头: 
def encode(value):

INFO:root:目标函数体: 
    if isinstance(value, bytes):
        value = value.decode(errors="surrogateescape")

    for char in ("\\", "\n", "\t"):
        value = value.replace(
            char, char.encode(encoding="unicode-escape").decode()
        )

    return value

INFO:root:生成结果: 
    if isinstance(value, bytes):
        value = value.decode(errors="surrogateescape")

    for char in ("\\", "\n", "\t"):
        value = value.replace(
            char.encode(encoding="unicode-escape").decode(), char
        )

    return value


INFO:root:----------------------------------------
INFO:root:max length: 8494
INFO:root:max position: 9104
INFO:root:target_namespace: Mopidy.mopidy<folder>.config<folder>.types<file>.encode<func>
INFO:root:****************************************

data 131:   0%|          | 0/512 [00:00<?, ?it/s]
data 131:   2%|▏         | 10/512 [00:53<45:00,  5.38s/it]
data 131:   4%|▍         | 20/512 [03:51<1:44:01, 12.69s/it]
data 131:   6%|▌         | 30/512 [04:46<1:15:27,  9.39s/it]
data 131:   8%|▊         | 40/512 [07:41<1:39:00, 12.59s/it]
data 131:  10%|▉         | 50/512 [08:35<1:16:56,  9.99s/it]
data 131:  10%|▉         | 50/512 [09:21<1:26:23, 11.22s/it]
INFO:root:函数头: 
def encode(value):

INFO:root:目标函数体: 
    if isinstance(value, bytes):
        value = value.decode(errors="surrogateescape")

    for char in ("\\", "\n", "\t"):
        value = value.replace(
            char, char.encode(encoding="unicode-escape").decode()
        )

    return value

INFO:root:生成结果: 
    if isinstance(value, bytes):
        value = value.decode(errors="surrogateescape")
    for char in ("\\", "\n", "\t"):
        value = value.replace(
            char.encode(encoding="unicode-escape").decode(), char
        )
    return value




INFO:root:----------------------------------------
INFO:root:max length: 8597
INFO:root:max position: 9071
INFO:root:target_namespace: Mopidy.mopidy<folder>.config<folder>.types<file>.encode<func>
INFO:root:****************************************
INFO:root:--------data 132--------

data 132:   0%|          | 0/512 [00:00<?, ?it/s]
data 132:   2%|▏         | 10/512 [00:56<47:07,  5.63s/it]
data 132:   4%|▍         | 20/512 [01:53<46:40,  5.69s/it]
data 132:   6%|▌         | 30/512 [02:52<46:22,  5.77s/it]
data 132:   8%|▊         | 40/512 [03:51<45:51,  5.83s/it]
data 132:  10%|▉         | 50/512 [04:49<44:56,  5.84s/it]
data 132:  10%|▉         | 50/512 [05:08<47:32,  6.17s/it]
INFO:root:函数头: 
def decode(value):

INFO:root:目标函数体: 
    if isinstance(value, bytes):
        value = value.decode(errors="surrogateescape")

    for char in ("\\", "\n", "\t"):
        value = value.replace(
            char.encode(encoding="unicode-escape").decode(), char
        )

    return value

INFO:root:生成结果: 
    if isinstance(value, bytes):
        value = value.decode("utf-8", "surrogateescape")
    if isinstance(value, str):
        value = value.replace("\\", "").replace("\n", "").replace("\t", "")
    return value


INFO:root:----------------------------------------
INFO:root:max length: 8493
INFO:root:max position: 9128
INFO:root:target_namespace: Mopidy.mopidy<folder>.config<folder>.types<file>.decode<func>
INFO:root:****************************************

data 132:   0%|          | 0/512 [00:00<?, ?it/s]
data 132:   2%|▏         | 10/512 [02:55<2:26:44, 17.54s/it]
data 132:   4%|▍         | 20/512 [03:53<1:27:06, 10.62s/it]
data 132:   6%|▌         | 30/512 [04:50<1:07:21,  8.38s/it]
data 132:   8%|▊         | 40/512 [05:49<58:07,  7.39s/it]  
data 132:  10%|▉         | 50/512 [06:48<52:47,  6.86s/it]
data 132:  10%|▉         | 50/512 [07:41<1:11:01,  9.22s/it]
INFO:root:函数头: 
def decode(value):

INFO:root:目标函数体: 
    if isinstance(value, bytes):
        value = value.decode(errors="surrogateescape")

    for char in ("\\", "\n", "\t"):
        value = value.replace(
            char.encode(encoding="unicode-escape").decode(), char
        )

    return value

INFO:root:生成结果: 
    if isinstance(value, bytes):
        value = value.decode("utf-8", "surrogateescape")
    if isinstance(value, str):
        value = value.replace("\\n", "\n").replace("\\t", "\t").replace("\\\\", "\\")
    return value


INFO:root:----------------------------------------
INFO:root:max length: 8332
INFO:root:max position: 9195
INFO:root:target_namespace: Mopidy.mopidy<folder>.config<folder>.types<file>.decode<func>
INFO:root:****************************************

data 132:   0%|          | 0/512 [00:00<?, ?it/s]
data 132:   2%|▏         | 10/512 [00:51<43:19,  5.18s/it]
data 132:   4%|▍         | 20/512 [01:47<44:28,  5.42s/it]
data 132:   6%|▌         | 30/512 [02:44<44:33,  5.55s/it]
data 132:   8%|▊         | 40/512 [05:44<1:22:10, 10.45s/it]
data 132:   8%|▊         | 40/512 [06:19<1:14:33,  9.48s/it]
INFO:root:函数头: 
def decode(value):

INFO:root:目标函数体: 
    if isinstance(value, bytes):
        value = value.decode(errors="surrogateescape")

    for char in ("\\", "\n", "\t"):
        value = value.replace(
            char.encode(encoding="unicode-escape").decode(), char
        )

    return value

INFO:root:生成结果: 
    if isinstance(value, bytes):
        value = value.decode("utf-8", "surrogateescape")
    value = value.replace("\\", "").replace("\n", "").replace("\t", "")
    return value


INFO:root:----------------------------------------
INFO:root:max length: 8406
INFO:root:max position: 9021
INFO:root:target_namespace: Mopidy.mopidy<folder>.config<folder>.types<file>.decode<func>
INFO:root:****************************************

data 132:   0%|          | 0/512 [00:00<?, ?it/s]
data 132:   2%|▏         | 10/512 [00:53<44:21,  5.30s/it]
data 132:   4%|▍         | 20/512 [01:50<45:28,  5.55s/it]
data 132:   6%|▌         | 30/512 [02:46<44:48,  5.58s/it]
data 132:   8%|▊         | 40/512 [03:44<44:35,  5.67s/it]
data 132:  10%|▉         | 50/512 [04:41<43:40,  5.67s/it]
data 132:  10%|▉         | 50/512 [04:59<46:06,  5.99s/it]
INFO:root:函数头: 
def decode(value):

INFO:root:目标函数体: 
    if isinstance(value, bytes):
        value = value.decode(errors="surrogateescape")

    for char in ("\\", "\n", "\t"):
        value = value.replace(
            char.encode(encoding="unicode-escape").decode(), char
        )

    return value

INFO:root:生成结果: 
    if isinstance(value, bytes):
        value = value.decode("utf-8", "surrogateescape")
    value = value.replace("\\n", "\n").replace("\\t", "\t").replace("\\r", "\r")
    return value


INFO:root:----------------------------------------
INFO:root:max length: 8494
INFO:root:max position: 9205
INFO:root:target_namespace: Mopidy.mopidy<folder>.config<folder>.types<file>.decode<func>
INFO:root:****************************************

data 132:   0%|          | 0/512 [00:00<?, ?it/s]
data 132:   2%|▏         | 10/512 [00:52<43:50,  5.24s/it]
data 132:   4%|▍         | 20/512 [01:50<45:50,  5.59s/it]
data 132:   6%|▌         | 30/512 [02:43<43:55,  5.47s/it]
data 132:   8%|▊         | 40/512 [03:39<43:22,  5.51s/it]
data 132:  10%|▉         | 50/512 [04:35<42:40,  5.54s/it]
data 132:  10%|▉         | 50/512 [04:54<45:19,  5.89s/it]
INFO:root:函数头: 
def decode(value):

INFO:root:目标函数体: 
    if isinstance(value, bytes):
        value = value.decode(errors="surrogateescape")

    for char in ("\\", "\n", "\t"):
        value = value.replace(
            char.encode(encoding="unicode-escape").decode(), char
        )

    return value

INFO:root:生成结果: 
    if isinstance(value, bytes):
        value = value.decode("utf-8", errors="surrogateescape")
    value = value.replace("\\n", "\n").replace("\\t", "\t").replace("\\\\", "\\")
    return value


INFO:root:----------------------------------------
INFO:root:max length: 8477
INFO:root:max position: 9250
INFO:root:target_namespace: Mopidy.mopidy<folder>.config<folder>.types<file>.decode<func>
INFO:root:****************************************
INFO:root:--------data 133--------

data 133:   0%|          | 0/512 [00:00<?, ?it/s]
data 133:   2%|▏         | 10/512 [00:53<44:30,  5.32s/it]
data 133:   4%|▍         | 20/512 [01:48<44:32,  5.43s/it]
data 133:   4%|▍         | 20/512 [02:32<1:02:24,  7.61s/it]
INFO:root:函数头: 
    def serialize(self, value, display=False):

INFO:root:目标函数体: 
        
        if value is None:
            return ""
        return str(value)

INFO:root:生成结果: 
        if value is None:
            return ""
        if isinstance(value, str):
            return encode(value)
        return str(value)




INFO:root:----------------------------------------
INFO:root:max length: 8214
INFO:root:max position: 9145
INFO:root:target_namespace: Mopidy.mopidy<folder>.config<folder>.types<file>.ConfigValue<class>.serialize<func>
INFO:root:****************************************

data 133:   0%|          | 0/512 [00:00<?, ?it/s]
data 133:   2%|▏         | 10/512 [00:51<42:55,  5.13s/it]
data 133:   2%|▏         | 10/512 [01:25<1:11:37,  8.56s/it]
INFO:root:函数头: 
    def serialize(self, value, display=False):

INFO:root:目标函数体: 
        
        if value is None:
            return ""
        return str(value)

INFO:root:生成结果: 
        if value is None:
            return ""
        return encode(value)




INFO:root:----------------------------------------
INFO:root:max length: 8186
INFO:root:max position: 8963
INFO:root:target_namespace: Mopidy.mopidy<folder>.config<folder>.types<file>.ConfigValue<class>.serialize<func>
INFO:root:****************************************

data 133:   0%|          | 0/512 [00:00<?, ?it/s]
data 133:   2%|▏         | 10/512 [00:52<43:31,  5.20s/it]
data 133:   4%|▍         | 20/512 [01:47<44:11,  5.39s/it]
data 133:   6%|▌         | 30/512 [02:38<42:13,  5.26s/it]
data 133:   6%|▌         | 30/512 [03:04<49:27,  6.16s/it]
INFO:root:函数头: 
    def serialize(self, value, display=False):

INFO:root:目标函数体: 
        
        if value is None:
            return ""
        return str(value)

INFO:root:生成结果: 
        if value is None:
            return ""
        if display:
            return str(value)
        return str(value).encode(encoding="unicode-escape").decode()


INFO:root:----------------------------------------
INFO:root:max length: 8662
INFO:root:max position: 9035
INFO:root:target_namespace: Mopidy.mopidy<folder>.config<folder>.types<file>.ConfigValue<class>.serialize<func>
INFO:root:****************************************

data 133:   0%|          | 0/512 [00:00<?, ?it/s]
data 133:   2%|▏         | 10/512 [00:49<41:03,  4.91s/it]
data 133:   4%|▍         | 20/512 [01:44<43:24,  5.29s/it]
data 133:   6%|▌         | 30/512 [02:36<42:13,  5.26s/it]
data 133:   6%|▌         | 30/512 [03:04<49:26,  6.15s/it]
INFO:root:函数头: 
    def serialize(self, value, display=False):

INFO:root:目标函数体: 
        
        if value is None:
            return ""
        return str(value)

INFO:root:生成结果: 
        if value is None:
            return ""
        if display:
            return str(value)
        return str(value).encode(encoding="unicode-escape").decode()


INFO:root:----------------------------------------
INFO:root:max length: 8293
INFO:root:max position: 9042
INFO:root:target_namespace: Mopidy.mopidy<folder>.config<folder>.types<file>.ConfigValue<class>.serialize<func>
INFO:root:****************************************

data 133:   0%|          | 0/512 [00:00<?, ?it/s]
data 133:   2%|▏         | 10/512 [00:48<40:43,  4.87s/it]
data 133:   4%|▍         | 20/512 [01:43<42:44,  5.21s/it]
data 133:   6%|▌         | 30/512 [02:35<41:59,  5.23s/it]
data 133:   8%|▊         | 40/512 [03:30<41:51,  5.32s/it]
data 133:  10%|▉         | 50/512 [04:26<41:49,  5.43s/it]
data 133:  12%|█▏        | 60/512 [05:19<40:38,  5.39s/it]
data 133:  12%|█▏        | 60/512 [05:35<42:09,  5.60s/it]
INFO:root:函数头: 
    def serialize(self, value, display=False):

INFO:root:目标函数体: 
        
        if value is None:
            return ""
        return str(value)

INFO:root:生成结果: 
        if value is None:
            return ""
        if isinstance(value, bool):
            return str(value).lower()
        if isinstance(value, int):
            return str(value)
        if isinstance(value, str):
            return encode(value)
        raise TypeError(f"Unsupported type: {type(value)}")


INFO:root:----------------------------------------
INFO:root:max length: 8903
INFO:root:max position: 9705
INFO:root:target_namespace: Mopidy.mopidy<folder>.config<folder>.types<file>.ConfigValue<class>.serialize<func>
INFO:root:****************************************
INFO:root:--------data 134--------

data 134:   0%|          | 0/512 [00:00<?, ?it/s]
data 134:   2%|▏         | 10/512 [00:58<48:33,  5.80s/it]
data 134:   4%|▍         | 20/512 [02:00<49:48,  6.07s/it]
data 134:   6%|▌         | 30/512 [03:07<51:08,  6.37s/it]
data 134:   8%|▊         | 40/512 [04:20<52:49,  6.72s/it]
data 134:   8%|▊         | 40/512 [04:34<53:58,  6.86s/it]
INFO:root:函数头: 
    def serialize(self, value, display=False):

INFO:root:目标函数体: 
        if value is True:
            return "true"
        elif value in (False, None):
            return "false"
        else:
            raise ValueError(f"{value!r} is not a boolean")

INFO:root:生成结果: 
        if value is True:
            return "true"
        elif value is False or value is None:
            return "false"
        raise ValueError(f"{value!r} is not a boolean")


INFO:root:----------------------------------------
INFO:root:max length: 9206
INFO:root:max position: 10545
INFO:root:target_namespace: Mopidy.mopidy<folder>.config<folder>.types<file>.Boolean<class>.serialize<func>
INFO:root:****************************************

data 134:   0%|          | 0/512 [00:00<?, ?it/s]
data 134:   2%|▏         | 10/512 [08:57<7:29:49, 53.76s/it]
data 134:   4%|▍         | 20/512 [10:01<3:32:30, 25.92s/it]
data 134:   6%|▌         | 30/512 [12:04<2:38:15, 19.70s/it]
data 134:   8%|▊         | 40/512 [13:12<1:54:41, 14.58s/it]
data 134:   8%|▊         | 40/512 [13:25<2:38:27, 20.14s/it]
INFO:root:函数头: 
    def serialize(self, value, display=False):

INFO:root:目标函数体: 
        if value is True:
            return "true"
        elif value in (False, None):
            return "false"
        else:
            raise ValueError(f"{value!r} is not a boolean")

INFO:root:生成结果: 
        if value is True:
            return "true"
        elif value is False or value is None:
            return "false"
        raise ValueError(f"{value!r} is not a boolean")



INFO:root:----------------------------------------
INFO:root:max length: 8752
INFO:root:max position: 10436
INFO:root:target_namespace: Mopidy.mopidy<folder>.config<folder>.types<file>.Boolean<class>.serialize<func>
INFO:root:****************************************

data 134:   0%|          | 0/512 [00:00<?, ?it/s]
data 134:   2%|▏         | 10/512 [01:55<1:36:57, 11.59s/it]
data 134:   4%|▍         | 20/512 [02:59<1:09:37,  8.49s/it]
data 134:   6%|▌         | 30/512 [04:03<1:00:32,  7.54s/it]
data 134:   8%|▊         | 40/512 [05:05<55:23,  7.04s/it]  
data 134:   8%|▊         | 40/512 [05:18<1:02:42,  7.97s/it]
INFO:root:函数头: 
    def serialize(self, value, display=False):

INFO:root:目标函数体: 
        if value is True:
            return "true"
        elif value in (False, None):
            return "false"
        else:
            raise ValueError(f"{value!r} is not a boolean")

INFO:root:生成结果: 
        if value is True:
            return "true"
        elif value is False or value is None:
            return "false"
        raise ValueError(f"{value!r} is not a boolean")


INFO:root:----------------------------------------
INFO:root:max length: 8667
INFO:root:max position: 10329
INFO:root:target_namespace: Mopidy.mopidy<folder>.config<folder>.types<file>.Boolean<class>.serialize<func>
INFO:root:****************************************

data 134:   0%|          | 0/512 [00:00<?, ?it/s]
data 134:   2%|▏         | 10/512 [00:55<46:17,  5.53s/it]
data 134:   4%|▍         | 20/512 [01:57<48:48,  5.95s/it]
data 134:   6%|▌         | 30/512 [03:00<49:08,  6.12s/it]
data 134:   8%|▊         | 40/512 [04:07<49:42,  6.32s/it]
data 134:   8%|▊         | 40/512 [04:39<55:01,  7.00s/it]
INFO:root:函数头: 
    def serialize(self, value, display=False):

INFO:root:目标函数体: 
        if value is True:
            return "true"
        elif value in (False, None):
            return "false"
        else:
            raise ValueError(f"{value!r} is not a boolean")

INFO:root:生成结果: 
        if value is True:
            return "true"
        elif value is False or value is None:
            return "false"
        else:
            raise ValueError(f"{value!r} is not a boolean")



INFO:root:----------------------------------------
INFO:root:max length: 8574
INFO:root:max position: 10979
INFO:root:target_namespace: Mopidy.mopidy<folder>.config<folder>.types<file>.Boolean<class>.serialize<func>
INFO:root:****************************************

data 134:   0%|          | 0/512 [00:00<?, ?it/s]
data 134:   2%|▏         | 10/512 [00:55<46:45,  5.59s/it]
data 134:   4%|▍         | 20/512 [01:58<49:01,  5.98s/it]
data 134:   6%|▌         | 30/512 [02:59<48:40,  6.06s/it]
data 134:   8%|▊         | 40/512 [04:06<49:34,  6.30s/it]
data 134:   8%|▊         | 40/512 [04:21<51:28,  6.54s/it]
INFO:root:函数头: 
    def serialize(self, value, display=False):

INFO:root:目标函数体: 
        if value is True:
            return "true"
        elif value in (False, None):
            return "false"
        else:
            raise ValueError(f"{value!r} is not a boolean")

INFO:root:生成结果: 
        if value is True:
            return "true"
        elif value is False or value is None:
            return "false"
        raise ValueError(f"{value!r} is not a boolean")




INFO:root:----------------------------------------
INFO:root:max length: 8994
INFO:root:max position: 10673
INFO:root:target_namespace: Mopidy.mopidy<folder>.config<folder>.types<file>.Boolean<class>.serialize<func>
INFO:root:****************************************
INFO:root:--------data 135--------

data 135:   0%|          | 0/512 [00:00<?, ?it/s]
data 135:   2%|▏         | 10/512 [00:45<37:52,  4.53s/it]
data 135:   4%|▍         | 20/512 [01:29<36:30,  4.45s/it]
data 135:   6%|▌         | 30/512 [02:14<36:01,  4.48s/it]
data 135:   8%|▊         | 40/512 [04:56<1:11:49,  9.13s/it]
data 135:  10%|▉         | 50/512 [05:43<57:46,  7.50s/it]  
data 135:  12%|█▏        | 60/512 [06:24<47:47,  6.34s/it]
data 135:  14%|█▎        | 70/512 [07:10<42:42,  5.80s/it]
data 135:  16%|█▌        | 80/512 [07:53<38:12,  5.31s/it]
data 135:  18%|█▊        | 90/512 [11:37<1:14:55, 10.65s/it]
data 135:  20%|█▉        | 100/512 [12:24<1:00:37,  8.83s/it]
data 135:  21%|██▏       | 110/512 [13:10<50:29,  7.54s/it]  
data 135:  23%|██▎       | 120/512 [13:57<43:30,  6.66s/it]
data 135:  23%|██▎       | 120/512 [17:42<57:51,  8.86s/it]
INFO:root:函数头: 
def df2mat(data, return_labels=False):

INFO:root:目标函数体: 
    

    df_str = data.select_dtypes(include=['object'])
    df_num = data.select_dtypes(exclude=['object'])

    for colname in df_str.columns:
        df_num = df_num.join(pd.get_dummies(data[colname], prefix=colname))

    plot_data = df_num.values

    labels=list(df_num.columns.values)

    if return_labels:
        return plot_data,labels
    else:
        return plot_data

INFO:root:生成结果: 
    # Check if the input data is a DataFrame
    if not isinstance(data, pd.DataFrame):
        raise TypeError("Input data must be a Pandas DataFrame")

    # Check if there are any text columns in the DataFrame
    if not any(data.columns.str.contains('text')):
        raise ValueError("DataFrame must contain text columns")

    # Convert text columns to binary vectors using get_dummies
    binary_data = pd.get_dummies(data)

    # Check if return_labels is True and return the labels
    if return_labels:
        return binary_data.columns.values, binary_data.values
    else:
        return binary_data.values


INFO:root:----------------------------------------
INFO:root:max length: 6751
INFO:root:max position: 10360
INFO:root:target_namespace: hypertools.hypertools<folder>.tools<folder>.df2mat<file>.df2mat<func>
INFO:root:****************************************

data 135:   0%|          | 0/512 [00:00<?, ?it/s]
data 135:   2%|▏         | 10/512 [01:39<1:23:10,  9.94s/it]
data 135:   4%|▍         | 20/512 [02:22<54:28,  6.64s/it]  
data 135:   6%|▌         | 30/512 [03:07<45:19,  5.64s/it]
data 135:   8%|▊         | 40/512 [04:01<43:35,  5.54s/it]
data 135:  10%|▉         | 50/512 [07:47<1:30:05, 11.70s/it]
data 135:  12%|█▏        | 60/512 [11:33<1:56:03, 15.40s/it]
data 135:  14%|█▎        | 70/512 [12:19<1:27:26, 11.87s/it]
data 135:  16%|█▌        | 80/512 [13:05<1:08:56,  9.58s/it]
data 135:  18%|█▊        | 90/512 [13:52<56:37,  8.05s/it]  
data 135:  20%|█▉        | 100/512 [14:39<48:07,  7.01s/it]
data 135:  21%|██▏       | 110/512 [15:23<41:29,  6.19s/it]
data 135:  23%|██▎       | 120/512 [16:10<37:39,  5.76s/it]
data 135:  25%|██▌       | 130/512 [17:00<35:08,  5.52s/it]
data 135:  27%|██▋       | 140/512 [17:46<32:32,  5.25s/it]
data 135:  29%|██▉       | 150/512 [18:31<30:20,  5.03s/it]
data 135:  31%|███▏      | 160/512 [19:17<28:36,  4.88s/it]
data 135:  33%|███▎      | 170/512 [20:04<27:36,  4.84s/it]
data 135:  35%|███▌      | 180/512 [20:50<26:18,  4.75s/it]
data 135:  37%|███▋      | 190/512 [21:34<25:03,  4.67s/it]
data 135:  39%|███▉      | 200/512 [22:20<24:04,  4.63s/it]
data 135:  41%|████      | 210/512 [23:08<23:34,  4.68s/it]
data 135:  43%|████▎     | 220/512 [23:54<22:40,  4.66s/it]
data 135:  45%|████▍     | 230/512 [24:41<21:54,  4.66s/it]
data 135:  45%|████▍     | 230/512 [24:46<30:22,  6.46s/it]
INFO:root:函数头: 
def df2mat(data, return_labels=False):

INFO:root:目标函数体: 
    

    df_str = data.select_dtypes(include=['object'])
    df_num = data.select_dtypes(exclude=['object'])

    for colname in df_str.columns:
        df_num = df_num.join(pd.get_dummies(data[colname], prefix=colname))

    plot_data = df_num.values

    labels=list(df_num.columns.values)

    if return_labels:
        return plot_data,labels
    else:
        return plot_data

INFO:root:生成结果: 
    # Check if the input data is a DataFrame
    if not isinstance(data, pd.DataFrame):
        raise ValueError("Input data must be a Pandas DataFrame")

    # Check if the DataFrame has Multi-level indices
    if data.index.nlevels > 1:
        raise ValueError("DataFrame must be single-level")

    # Get column names
    column_names = data.columns

    # Get column types
    column_types = data.dtypes

    # Check if all columns are text columns
    text_columns = [col for col in column_names if column_types[col] == object]

    # Transform text columns into binary vectors using get_dummies
    binary_data = pd.get_dummies(data[text_columns])

    # Concatenate binary data with numeric columns
    final_data = pd.concat([binary_data, data.drop(text_columns)], axis=1)

    # Convert to numpy array
    final_data_np = final_data.values

    # Return numpy array and column labels if return_labels is True
    if return_labels:
        return final_data_np, list(final_data.columns)
    else:
        return final_data_np




INFO:root:----------------------------------------
INFO:root:max length: 7385
INFO:root:max position: 10420
INFO:root:target_namespace: hypertools.hypertools<folder>.tools<folder>.df2mat<file>.df2mat<func>
INFO:root:****************************************

data 135:   0%|          | 0/512 [00:00<?, ?it/s]
data 135:   2%|▏         | 10/512 [00:39<32:59,  3.94s/it]
data 135:   4%|▍         | 20/512 [01:24<34:55,  4.26s/it]
data 135:   6%|▌         | 30/512 [02:09<35:10,  4.38s/it]
data 135:   8%|▊         | 40/512 [02:55<35:11,  4.47s/it]
data 135:  10%|▉         | 50/512 [03:42<34:55,  4.53s/it]
data 135:  12%|█▏        | 60/512 [04:25<33:37,  4.46s/it]
data 135:  14%|█▎        | 70/512 [05:12<33:25,  4.54s/it]
data 135:  16%|█▌        | 80/512 [06:00<33:24,  4.64s/it]
data 135:  18%|█▊        | 90/512 [06:46<32:31,  4.62s/it]
data 135:  20%|█▉        | 100/512 [07:31<31:23,  4.57s/it]
data 135:  21%|██▏       | 110/512 [08:14<30:02,  4.48s/it]
data 135:  23%|██▎       | 120/512 [09:01<29:46,  4.56s/it]
data 135:  25%|██▌       | 130/512 [09:49<29:30,  4.63s/it]
data 135:  25%|██▌       | 130/512 [10:04<29:36,  4.65s/it]
INFO:root:函数头: 
def df2mat(data, return_labels=False):

INFO:root:目标函数体: 
    

    df_str = data.select_dtypes(include=['object'])
    df_num = data.select_dtypes(exclude=['object'])

    for colname in df_str.columns:
        df_num = df_num.join(pd.get_dummies(data[colname], prefix=colname))

    plot_data = df_num.values

    labels=list(df_num.columns.values)

    if return_labels:
        return plot_data,labels
    else:
        return plot_data

INFO:root:生成结果: 
    # Check if the input is a DataFrame
    if not isinstance(data, pd.DataFrame):
        raise TypeError("Input must be a Pandas DataFrame")
    
    # Check if there are any text columns
    if data.select_dtypes(include=['object']).shape[1] == 0:
        raise ValueError("DataFrame contains no text columns")
    
    # Convert text columns to binary vectors using get_dummies
    data_bin = pd.get_dummies(data)
    
    # Return the binary DataFrame or the numpy array
    if return_labels:
        return data_bin.values, list(data_bin.columns)
    else:
        return data_bin.values




INFO:root:----------------------------------------
INFO:root:max length: 6477
INFO:root:max position: 10536
INFO:root:target_namespace: hypertools.hypertools<folder>.tools<folder>.df2mat<file>.df2mat<func>
INFO:root:****************************************

data 135:   0%|          | 0/512 [00:00<?, ?it/s]
data 135:   2%|▏         | 10/512 [00:39<33:15,  3.98s/it]
data 135:   4%|▍         | 20/512 [01:24<35:04,  4.28s/it]
data 135:   6%|▌         | 30/512 [02:10<35:18,  4.40s/it]
data 135:   8%|▊         | 40/512 [02:56<35:16,  4.48s/it]
data 135:  10%|▉         | 50/512 [03:41<34:44,  4.51s/it]
data 135:  12%|█▏        | 60/512 [04:30<34:58,  4.64s/it]
data 135:  14%|█▎        | 70/512 [05:17<34:21,  4.66s/it]
data 135:  16%|█▌        | 80/512 [06:01<32:47,  4.56s/it]
data 135:  18%|█▊        | 90/512 [06:47<32:13,  4.58s/it]
data 135:  20%|█▉        | 100/512 [07:31<31:05,  4.53s/it]
data 135:  21%|██▏       | 110/512 [08:16<30:16,  4.52s/it]
data 135:  23%|██▎       | 120/512 [09:00<29:17,  4.48s/it]
data 135:  25%|██▌       | 130/512 [09:47<28:55,  4.54s/it]
data 135:  27%|██▋       | 140/512 [10:32<28:12,  4.55s/it]
data 135:  29%|██▉       | 150/512 [11:18<27:30,  4.56s/it]
data 135:  31%|███▏      | 160/512 [12:06<27:02,  4.61s/it]
data 135:  33%|███▎      | 170/512 [12:50<25:56,  4.55s/it]
data 135:  33%|███▎      | 170/512 [13:27<27:05,  4.75s/it]
INFO:root:函数头: 
def df2mat(data, return_labels=False):

INFO:root:目标函数体: 
    

    df_str = data.select_dtypes(include=['object'])
    df_num = data.select_dtypes(exclude=['object'])

    for colname in df_str.columns:
        df_num = df_num.join(pd.get_dummies(data[colname], prefix=colname))

    plot_data = df_num.values

    labels=list(df_num.columns.values)

    if return_labels:
        return plot_data,labels
    else:
        return plot_data

INFO:root:生成结果: 
    # Check if the input data is a DataFrame
    if not isinstance(data, pd.DataFrame):
        raise ValueError("Input data must be a Pandas DataFrame.")
    
    # Get column names
    column_names = data.columns
    
    # Get column types
    column_types = data.dtypes
    
    # Check if all columns are text (i.e., object type)
    if not all(column_types == object):
        raise ValueError("All columns must be of type 'object'.")
    
    # Convert text columns to binary vectors using get_dummies
    binary_data = pd.get_dummies(data)
    
    # Convert binary DataFrame to numpy array
    binary_array = binary_data.values
    
    # Return binary array and column names if return_labels is True
    if return_labels:
        return binary_array, column_names
    else:
        return binary_array


INFO:root:----------------------------------------
INFO:root:max length: 7285
INFO:root:max position: 10364
INFO:root:target_namespace: hypertools.hypertools<folder>.tools<folder>.df2mat<file>.df2mat<func>
INFO:root:****************************************

data 135:   0%|          | 0/512 [00:00<?, ?it/s]
data 135:   2%|▏         | 10/512 [00:39<33:11,  3.97s/it]
data 135:   4%|▍         | 20/512 [01:22<34:00,  4.15s/it]
data 135:   6%|▌         | 30/512 [02:08<34:51,  4.34s/it]
data 135:   8%|▊         | 40/512 [02:50<33:47,  4.30s/it]
data 135:  10%|▉         | 50/512 [03:36<33:56,  4.41s/it]
data 135:  12%|█▏        | 60/512 [04:23<33:51,  4.49s/it]
data 135:  14%|█▎        | 70/512 [05:07<32:55,  4.47s/it]
data 135:  16%|█▌        | 80/512 [05:53<32:25,  4.50s/it]
data 135:  18%|█▊        | 90/512 [06:39<31:56,  4.54s/it]
data 135:  20%|█▉        | 100/512 [07:25<31:19,  4.56s/it]
data 135:  21%|██▏       | 110/512 [08:10<30:27,  4.54s/it]
data 135:  23%|██▎       | 120/512 [08:58<30:09,  4.62s/it]
data 135:  23%|██▎       | 120/512 [09:11<29:59,  4.59s/it]
INFO:root:函数头: 
def df2mat(data, return_labels=False):

INFO:root:目标函数体: 
    

    df_str = data.select_dtypes(include=['object'])
    df_num = data.select_dtypes(exclude=['object'])

    for colname in df_str.columns:
        df_num = df_num.join(pd.get_dummies(data[colname], prefix=colname))

    plot_data = df_num.values

    labels=list(df_num.columns.values)

    if return_labels:
        return plot_data,labels
    else:
        return plot_data

INFO:root:生成结果: 
    # Check if the input is a DataFrame
    if not isinstance(data, pd.DataFrame):
        raise ValueError("Input must be a Pandas DataFrame")

    # Get the column names
    column_names = data.columns.tolist()

    # Convert text columns to binary vectors using get_dummies
    binary_data = pd.get_dummies(data)

    # Convert binary data to numpy array
    binary_array = binary_data.values

    # Return binary array and column names if return_labels is True
    if return_labels:
        return binary_array, column_names
    else:
        return binary_array



INFO:root:----------------------------------------
INFO:root:max length: 6081
INFO:root:max position: 10684
INFO:root:target_namespace: hypertools.hypertools<folder>.tools<folder>.df2mat<file>.df2mat<func>
INFO:root:****************************************
INFO:root:--------data 136--------

data 136:   0%|          | 0/512 [00:00<?, ?it/s]
data 136:   2%|▏         | 10/512 [00:45<37:53,  4.53s/it]
data 136:   4%|▍         | 20/512 [01:33<38:33,  4.70s/it]
data 136:   4%|▍         | 20/512 [01:52<46:03,  5.62s/it]
INFO:root:函数头: 
def center(x):

INFO:root:目标函数体: 
    assert type(x) is list, "Input data to center must be list"
    x_stacked = np.vstack(x)
    return [i - np.mean(x_stacked, 0) for i in x]

INFO:root:生成结果: 
    assert type(x) == list
    return [i - np.mean(x) for i in x]




INFO:root:----------------------------------------
INFO:root:max length: 7131
INFO:root:max position: 9816
INFO:root:target_namespace: hypertools.hypertools<folder>._shared<folder>.helpers<file>.center<func>
INFO:root:****************************************

data 136:   0%|          | 0/512 [00:00<?, ?it/s]
data 136:   2%|▏         | 10/512 [00:43<36:41,  4.39s/it]
data 136:   4%|▍         | 20/512 [01:30<37:21,  4.56s/it]
data 136:   4%|▍         | 20/512 [02:16<55:59,  6.83s/it]
INFO:root:函数头: 
def center(x):

INFO:root:目标函数体: 
    assert type(x) is list, "Input data to center must be list"
    x_stacked = np.vstack(x)
    return [i - np.mean(x_stacked, 0) for i in x]

INFO:root:生成结果: 
    assert isinstance(x, list), "Input must be a list"
    return [i - np.mean(x) for i in x]




INFO:root:----------------------------------------
INFO:root:max length: 7117
INFO:root:max position: 9850
INFO:root:target_namespace: hypertools.hypertools<folder>._shared<folder>.helpers<file>.center<func>
INFO:root:****************************************

data 136:   0%|          | 0/512 [00:00<?, ?it/s]
data 136:   2%|▏         | 10/512 [00:42<35:12,  4.21s/it]
data 136:   4%|▍         | 20/512 [01:28<36:25,  4.44s/it]
data 136:   4%|▍         | 20/512 [02:13<54:51,  6.69s/it]
INFO:root:函数头: 
def center(x):

INFO:root:目标函数体: 
    assert type(x) is list, "Input data to center must be list"
    x_stacked = np.vstack(x)
    return [i - np.mean(x_stacked, 0) for i in x]

INFO:root:生成结果: 
    assert isinstance(x, list), "Input must be a list"
    return [i - np.mean(x) for i in x]




INFO:root:----------------------------------------
INFO:root:max length: 7074
INFO:root:max position: 9999
INFO:root:target_namespace: hypertools.hypertools<folder>._shared<folder>.helpers<file>.center<func>
INFO:root:****************************************

data 136:   0%|          | 0/512 [00:00<?, ?it/s]
data 136:   2%|▏         | 10/512 [00:40<33:30,  4.00s/it]
data 136:   4%|▍         | 20/512 [01:25<35:12,  4.29s/it]
data 136:   6%|▌         | 30/512 [02:11<35:52,  4.47s/it]
data 136:   6%|▌         | 30/512 [02:15<36:23,  4.53s/it]
INFO:root:函数头: 
def center(x):

INFO:root:目标函数体: 
    assert type(x) is list, "Input data to center must be list"
    x_stacked = np.vstack(x)
    return [i - np.mean(x_stacked, 0) for i in x]

INFO:root:生成结果: 
    assert isinstance(x, list), "Input must be a list."
    x = np.array(x)
    return x - np.mean(x)




INFO:root:----------------------------------------
INFO:root:max length: 7025
INFO:root:max position: 10097
INFO:root:target_namespace: hypertools.hypertools<folder>._shared<folder>.helpers<file>.center<func>
INFO:root:****************************************

data 136:   0%|          | 0/512 [00:00<?, ?it/s]
data 136:   2%|▏         | 10/512 [00:40<34:15,  4.09s/it]
data 136:   4%|▍         | 20/512 [01:26<35:55,  4.38s/it]
data 136:   6%|▌         | 30/512 [02:13<36:10,  4.50s/it]
data 136:   8%|▊         | 40/512 [02:57<35:06,  4.46s/it]
data 136:   8%|▊         | 40/512 [03:01<35:39,  4.53s/it]
INFO:root:函数头: 
def center(x):

INFO:root:目标函数体: 
    assert type(x) is list, "Input data to center must be list"
    x_stacked = np.vstack(x)
    return [i - np.mean(x_stacked, 0) for i in x]

INFO:root:生成结果: 
    assert isinstance(x, list), "Input must be a list"
    x = np.array(x)
    x_centered = x - np.mean(x)
    return x_centered.tolist()




INFO:root:----------------------------------------
INFO:root:max length: 6801
INFO:root:max position: 9979
INFO:root:target_namespace: hypertools.hypertools<folder>._shared<folder>.helpers<file>.center<func>
INFO:root:****************************************
INFO:root:--------data 137--------

data 137:   0%|          | 0/512 [00:00<?, ?it/s]
data 137:   2%|▏         | 10/512 [00:48<40:55,  4.89s/it]
data 137:   4%|▍         | 20/512 [01:36<39:16,  4.79s/it]
data 137:   6%|▌         | 30/512 [02:25<38:57,  4.85s/it]
data 137:   8%|▊         | 40/512 [03:12<37:43,  4.79s/it]
data 137:  10%|▉         | 50/512 [04:01<37:22,  4.85s/it]
data 137:  12%|█▏        | 60/512 [04:52<37:02,  4.92s/it]
data 137:  14%|█▎        | 70/512 [05:39<35:46,  4.86s/it]
data 137:  16%|█▌        | 80/512 [06:28<35:05,  4.87s/it]
data 137:  18%|█▊        | 90/512 [07:17<34:18,  4.88s/it]
data 137:  18%|█▊        | 90/512 [07:52<36:55,  5.25s/it]
INFO:root:函数头: 
def group_by_category(vals):

INFO:root:目标函数体: 
    if any(isinstance(el, list) for el in vals):
        vals = list(itertools.chain(*vals))
    val_set = list(sorted(set(vals), key=list(vals).index))
    return [val_set.index(val) for val in vals]

INFO:root:生成结果: 
    # Check if the input values contain any list
    if any(isinstance(i, list) for i in vals):
        # Flatten the list if it contains any list
        vals = [item for sublist in vals for item in sublist]
    
    # Create a sorted set of unique values
    unique_vals = sorted(set(vals))
    
    # Return the index of each value in the sorted set
    return [unique_vals.index(i) for i in vals]




INFO:root:----------------------------------------
INFO:root:max length: 7798
INFO:root:max position: 10816
INFO:root:target_namespace: hypertools.hypertools<folder>._shared<folder>.helpers<file>.group_by_category<func>
INFO:root:****************************************

data 137:   0%|          | 0/512 [00:00<?, ?it/s]
data 137:   2%|▏         | 10/512 [00:42<35:13,  4.21s/it]
data 137:   4%|▍         | 20/512 [01:33<38:48,  4.73s/it]
data 137:   6%|▌         | 30/512 [02:21<38:23,  4.78s/it]
data 137:   8%|▊         | 40/512 [03:11<38:14,  4.86s/it]
data 137:   8%|▊         | 40/512 [04:01<47:31,  6.04s/it]
INFO:root:函数头: 
def group_by_category(vals):

INFO:root:目标函数体: 
    if any(isinstance(el, list) for el in vals):
        vals = list(itertools.chain(*vals))
    val_set = list(sorted(set(vals), key=list(vals).index))
    return [val_set.index(val) for val in vals]

INFO:root:生成结果: 
    if any(isinstance(i, list) for i in vals):
        vals = [item for sublist in vals for item in sublist]
    unique_vals = sorted(set(vals))
    return [unique_vals.index(i) for i in vals]




INFO:root:----------------------------------------
INFO:root:max length: 7990
INFO:root:max position: 10641
INFO:root:target_namespace: hypertools.hypertools<folder>._shared<folder>.helpers<file>.group_by_category<func>
INFO:root:****************************************

data 137:   0%|          | 0/512 [00:00<?, ?it/s]
data 137:   2%|▏         | 10/512 [00:44<37:09,  4.44s/it]
data 137:   4%|▍         | 20/512 [01:34<39:20,  4.80s/it]
data 137:   6%|▌         | 30/512 [02:24<39:08,  4.87s/it]
data 137:   8%|▊         | 40/512 [03:13<38:15,  4.86s/it]
data 137:   8%|▊         | 40/512 [04:03<47:48,  6.08s/it]
INFO:root:函数头: 
def group_by_category(vals):

INFO:root:目标函数体: 
    if any(isinstance(el, list) for el in vals):
        vals = list(itertools.chain(*vals))
    val_set = list(sorted(set(vals), key=list(vals).index))
    return [val_set.index(val) for val in vals]

INFO:root:生成结果: 
    if any(isinstance(i, list) for i in vals):
        vals = [item for sublist in vals for item in sublist]
    unique_vals = sorted(set(vals))
    return [unique_vals.index(i) for i in vals]




INFO:root:----------------------------------------
INFO:root:max length: 7348
INFO:root:max position: 10532
INFO:root:target_namespace: hypertools.hypertools<folder>._shared<folder>.helpers<file>.group_by_category<func>
INFO:root:****************************************

data 137:   0%|          | 0/512 [00:00<?, ?it/s]
data 137:   2%|▏         | 10/512 [00:44<37:03,  4.43s/it]
data 137:   4%|▍         | 20/512 [01:31<37:50,  4.62s/it]
data 137:   6%|▌         | 30/512 [02:20<38:08,  4.75s/it]
data 137:   8%|▊         | 40/512 [03:09<37:40,  4.79s/it]
data 137:   8%|▊         | 40/512 [03:59<47:09,  5.99s/it]
INFO:root:函数头: 
def group_by_category(vals):

INFO:root:目标函数体: 
    if any(isinstance(el, list) for el in vals):
        vals = list(itertools.chain(*vals))
    val_set = list(sorted(set(vals), key=list(vals).index))
    return [val_set.index(val) for val in vals]

INFO:root:生成结果: 
    if any(isinstance(i, list) for i in vals):
        vals = [item for sublist in vals for item in sublist]
    unique_vals = sorted(set(vals))
    return [unique_vals.index(i) for i in vals]




INFO:root:----------------------------------------
INFO:root:max length: 7694
INFO:root:max position: 10545
INFO:root:target_namespace: hypertools.hypertools<folder>._shared<folder>.helpers<file>.group_by_category<func>
INFO:root:****************************************

data 137:   0%|          | 0/512 [00:00<?, ?it/s]
data 137:   2%|▏         | 10/512 [00:43<36:28,  4.36s/it]
data 137:   4%|▍         | 20/512 [01:32<38:06,  4.65s/it]
data 137:   6%|▌         | 30/512 [02:22<38:38,  4.81s/it]
data 137:   8%|▊         | 40/512 [03:11<38:18,  4.87s/it]
data 137:   8%|▊         | 40/512 [03:30<41:22,  5.26s/it]
INFO:root:函数头: 
def group_by_category(vals):

INFO:root:目标函数体: 
    if any(isinstance(el, list) for el in vals):
        vals = list(itertools.chain(*vals))
    val_set = list(sorted(set(vals), key=list(vals).index))
    return [val_set.index(val) for val in vals]

INFO:root:生成结果: 
    if isinstance(vals, list):
        vals = [item for sublist in vals for item in sublist]
    unique_vals = sorted(set(vals))
    return [unique_vals.index(val) for val in vals]




INFO:root:----------------------------------------
INFO:root:max length: 7653
INFO:root:max position: 10734
INFO:root:target_namespace: hypertools.hypertools<folder>._shared<folder>.helpers<file>.group_by_category<func>
INFO:root:****************************************
INFO:root:--------data 138--------

data 138:   0%|          | 0/512 [00:00<?, ?it/s]
data 138:   2%|▏         | 10/512 [00:46<39:03,  4.67s/it]
data 138:   4%|▍         | 20/512 [01:35<39:11,  4.78s/it]
data 138:   6%|▌         | 30/512 [02:21<37:52,  4.71s/it]
data 138:   8%|▊         | 40/512 [03:09<37:14,  4.73s/it]
data 138:  10%|▉         | 50/512 [03:56<36:22,  4.72s/it]
data 138:  12%|█▏        | 60/512 [04:43<35:32,  4.72s/it]
data 138:  14%|█▎        | 70/512 [05:30<34:44,  4.72s/it]
data 138:  16%|█▌        | 80/512 [06:18<34:13,  4.75s/it]
data 138:  18%|█▊        | 90/512 [07:05<33:19,  4.74s/it]
data 138:  20%|█▉        | 100/512 [07:55<33:00,  4.81s/it]
data 138:  21%|██▏       | 110/512 [08:45<32:37,  4.87s/it]
data 138:  21%|██▏       | 110/512 [09:13<33:43,  5.03s/it]
INFO:root:函数头: 
def vals2colors(vals, cmap='GnBu',res=100):

INFO:root:目标函数体: 
    
    # flatten if list of lists
    if any(isinstance(el, list) for el in vals):
        vals = list(itertools.chain(*vals))

    # get palette from seaborn
    palette = np.array(sns.color_palette(cmap, res))
    ranks = np.digitize(vals, np.linspace(np.min(vals), np.max(vals)+1, res+1)) - 1
    return [tuple(i) for i in palette[ranks, :]]

INFO:root:生成结果: 
    import seaborn as sns
    import numpy as np
    
    # Check if vals is a list of lists and flatten it if necessary
    if any(isinstance(el, list) for el in vals):
        vals = list(itertools.chain(*vals))
    
    # Get the color palette from seaborn
    palette = sns.color_palette(cmap, res)
    
    # Map the input values to colors based on the color palette
    colors = [palette[int(val * (len(palette) - 1))] for val in vals]
    
    return colors


INFO:root:----------------------------------------
INFO:root:max length: 7476
INFO:root:max position: 10813
INFO:root:target_namespace: hypertools.hypertools<folder>._shared<folder>.helpers<file>.vals2colors<func>
INFO:root:****************************************

data 138:   0%|          | 0/512 [00:00<?, ?it/s]
data 138:   2%|▏         | 10/512 [00:43<36:25,  4.35s/it]
data 138:   4%|▍         | 20/512 [01:30<37:16,  4.55s/it]
data 138:   6%|▌         | 30/512 [02:18<37:31,  4.67s/it]
data 138:   8%|▊         | 40/512 [03:07<37:29,  4.77s/it]
data 138:  10%|▉         | 50/512 [03:56<36:55,  4.80s/it]
data 138:  12%|█▏        | 60/512 [04:43<36:01,  4.78s/it]
data 138:  14%|█▎        | 70/512 [05:32<35:30,  4.82s/it]
data 138:  16%|█▌        | 80/512 [06:20<34:43,  4.82s/it]
data 138:  18%|█▊        | 90/512 [07:09<33:57,  4.83s/it]
data 138:  20%|█▉        | 100/512 [07:55<32:47,  4.78s/it]
data 138:  20%|█▉        | 100/512 [08:18<34:15,  4.99s/it]
INFO:root:函数头: 
def vals2colors(vals, cmap='GnBu',res=100):

INFO:root:目标函数体: 
    
    # flatten if list of lists
    if any(isinstance(el, list) for el in vals):
        vals = list(itertools.chain(*vals))

    # get palette from seaborn
    palette = np.array(sns.color_palette(cmap, res))
    ranks = np.digitize(vals, np.linspace(np.min(vals), np.max(vals)+1, res+1)) - 1
    return [tuple(i) for i in palette[ranks, :]]

INFO:root:生成结果: 
    import seaborn as sns
    import numpy as np
    
    # If input is a list of lists, flatten it
    if any(isinstance(el, list) for el in vals):
        vals = list(itertools.chain(*vals))
    
    # Get color palette from seaborn
    palette = sns.color_palette(cmap, res)
    
    # Map values to colors
    colors = []
    for val in vals:
        colors.append(palette[int(val*(res-1))]
    
    return colors


INFO:root:----------------------------------------
INFO:root:max length: 7642
INFO:root:max position: 10827
INFO:root:target_namespace: hypertools.hypertools<folder>._shared<folder>.helpers<file>.vals2colors<func>
INFO:root:****************************************

data 138:   0%|          | 0/512 [00:00<?, ?it/s]
data 138:   2%|▏         | 10/512 [00:42<35:56,  4.30s/it]
data 138:   4%|▍         | 20/512 [01:35<39:38,  4.83s/it]
data 138:   6%|▌         | 30/512 [02:22<38:37,  4.81s/it]
data 138:   8%|▊         | 40/512 [03:12<38:17,  4.87s/it]
data 138:  10%|▉         | 50/512 [03:59<37:04,  4.82s/it]
data 138:  12%|█▏        | 60/512 [04:51<37:19,  4.95s/it]
data 138:  14%|█▎        | 70/512 [05:42<36:42,  4.98s/it]
data 138:  14%|█▎        | 70/512 [06:01<38:00,  5.16s/it]
INFO:root:函数头: 
def vals2colors(vals, cmap='GnBu',res=100):

INFO:root:目标函数体: 
    
    # flatten if list of lists
    if any(isinstance(el, list) for el in vals):
        vals = list(itertools.chain(*vals))

    # get palette from seaborn
    palette = np.array(sns.color_palette(cmap, res))
    ranks = np.digitize(vals, np.linspace(np.min(vals), np.max(vals)+1, res+1)) - 1
    return [tuple(i) for i in palette[ranks, :]]

INFO:root:生成结果: 
    if isinstance(vals, list) and any(isinstance(el, list) for el in vals):
        vals = list(itertools.chain(*vals))
    palette = sns.color_palette(cmap, res)
    return palette[np.round((np.array(vals) - np.min(vals))/(np.max(vals)-np.min(vals))*(res-1)).astype(int)]



INFO:root:----------------------------------------
INFO:root:max length: 8160
INFO:root:max position: 10945
INFO:root:target_namespace: hypertools.hypertools<folder>._shared<folder>.helpers<file>.vals2colors<func>
INFO:root:****************************************

data 138:   0%|          | 0/512 [00:00<?, ?it/s]
data 138:   2%|▏         | 10/512 [00:44<36:55,  4.41s/it]
data 138:   4%|▍         | 20/512 [01:33<38:35,  4.71s/it]
data 138:   6%|▌         | 30/512 [02:23<38:53,  4.84s/it]
data 138:   8%|▊         | 40/512 [03:12<38:17,  4.87s/it]
data 138:  10%|▉         | 50/512 [03:59<37:09,  4.83s/it]
data 138:  12%|█▏        | 60/512 [04:50<36:56,  4.90s/it]
data 138:  14%|█▎        | 70/512 [05:39<36:11,  4.91s/it]
data 138:  16%|█▌        | 80/512 [06:29<35:26,  4.92s/it]
data 138:  18%|█▊        | 90/512 [07:16<34:13,  4.87s/it]
data 138:  18%|█▊        | 90/512 [07:21<34:29,  4.90s/it]
INFO:root:函数头: 
def vals2colors(vals, cmap='GnBu',res=100):

INFO:root:目标函数体: 
    
    # flatten if list of lists
    if any(isinstance(el, list) for el in vals):
        vals = list(itertools.chain(*vals))

    # get palette from seaborn
    palette = np.array(sns.color_palette(cmap, res))
    ranks = np.digitize(vals, np.linspace(np.min(vals), np.max(vals)+1, res+1)) - 1
    return [tuple(i) for i in palette[ranks, :]]

INFO:root:生成结果: 
    import seaborn as sns
    import numpy as np

    if isinstance(vals, list) and any(isinstance(el, list) for el in vals):
        vals = list(itertools.chain(*vals))

    palette = sns.color_palette(cmap, res)
    return palette[np.round((np.array(vals) - np.min(vals)) / (np.max(vals) - np.min(vals)) * (res - 1)).astype(int)]




INFO:root:----------------------------------------
INFO:root:max length: 7686
INFO:root:max position: 10936
INFO:root:target_namespace: hypertools.hypertools<folder>._shared<folder>.helpers<file>.vals2colors<func>
INFO:root:****************************************

data 138:   0%|          | 0/512 [00:00<?, ?it/s]
data 138:   2%|▏         | 10/512 [00:41<34:39,  4.14s/it]
data 138:   4%|▍         | 20/512 [01:29<37:20,  4.55s/it]
data 138:   6%|▌         | 30/512 [02:16<37:03,  4.61s/it]
data 138:   8%|▊         | 40/512 [03:06<37:18,  4.74s/it]
data 138:  10%|▉         | 50/512 [03:55<37:04,  4.81s/it]
data 138:  12%|█▏        | 60/512 [04:45<36:43,  4.87s/it]
data 138:  12%|█▏        | 60/512 [05:10<38:56,  5.17s/it]
INFO:root:函数头: 
def vals2colors(vals, cmap='GnBu',res=100):

INFO:root:目标函数体: 
    
    # flatten if list of lists
    if any(isinstance(el, list) for el in vals):
        vals = list(itertools.chain(*vals))

    # get palette from seaborn
    palette = np.array(sns.color_palette(cmap, res))
    ranks = np.digitize(vals, np.linspace(np.min(vals), np.max(vals)+1, res+1)) - 1
    return [tuple(i) for i in palette[ranks, :]]

INFO:root:生成结果: 
    if any(isinstance(el, list) for el in vals):
        vals = list(itertools.chain(*vals))
    palette = sns.color_palette(cmap, res)
    return palette[np.round((np.array(vals) - np.min(vals))/(np.max(vals)-np.min(vals))*res).astype(int)]



INFO:root:----------------------------------------
INFO:root:max length: 7853
INFO:root:max position: 10809
INFO:root:target_namespace: hypertools.hypertools<folder>._shared<folder>.helpers<file>.vals2colors<func>
INFO:root:****************************************
INFO:root:--------data 139--------

data 139:   0%|          | 0/512 [00:00<?, ?it/s]
data 139:   2%|▏         | 10/512 [00:46<38:51,  4.65s/it]
data 139:   4%|▍         | 20/512 [01:35<39:13,  4.78s/it]
data 139:   6%|▌         | 30/512 [02:25<39:21,  4.90s/it]
data 139:   8%|▊         | 40/512 [03:13<38:14,  4.86s/it]
data 139:  10%|▉         | 50/512 [03:58<36:27,  4.74s/it]
data 139:  12%|█▏        | 60/512 [04:44<35:17,  4.68s/it]
data 139:  14%|█▎        | 70/512 [05:33<34:58,  4.75s/it]
data 139:  16%|█▌        | 80/512 [06:21<34:14,  4.76s/it]
data 139:  18%|█▊        | 90/512 [07:09<33:31,  4.77s/it]
data 139:  20%|█▉        | 100/512 [07:55<32:28,  4.73s/it]
data 139:  20%|█▉        | 100/512 [08:37<35:30,  5.17s/it]
INFO:root:函数头: 
def vals2bins(vals,res=100):

INFO:root:目标函数体: 
    
    # flatten if list of lists
    if any(isinstance(el, list) for el in vals):
        vals = list(itertools.chain(*vals))
    return list(np.digitize(vals, np.linspace(np.min(vals), np.max(vals)+1, res+1)) - 1)

INFO:root:生成结果: 
    # Flatten the list if it is a list of lists
    if any(isinstance(el, list) for el in vals):
        vals = list(itertools.chain(*vals))
    # Get the range of the values
    range_vals = np.max(vals) - np.min(vals)
    # Calculate the width of each bin
    bin_width = range_vals / res
    # Calculate the bins
    bins = np.arange(np.min(vals), np.max(vals) + bin_width, bin_width)
    return bins




INFO:root:----------------------------------------
INFO:root:max length: 8204
INFO:root:max position: 10664
INFO:root:target_namespace: hypertools.hypertools<folder>._shared<folder>.helpers<file>.vals2bins<func>
INFO:root:****************************************

data 139:   0%|          | 0/512 [00:00<?, ?it/s]
data 139:   2%|▏         | 10/512 [00:42<35:20,  4.22s/it]
data 139:   4%|▍         | 20/512 [01:32<38:25,  4.68s/it]
data 139:   6%|▌         | 30/512 [02:21<38:33,  4.80s/it]
data 139:   8%|▊         | 40/512 [03:06<36:54,  4.69s/it]
data 139:  10%|▉         | 50/512 [03:53<36:02,  4.68s/it]
data 139:  12%|█▏        | 60/512 [04:42<35:46,  4.75s/it]
data 139:  14%|█▎        | 70/512 [05:28<34:35,  4.69s/it]
data 139:  16%|█▌        | 80/512 [06:14<33:40,  4.68s/it]
data 139:  18%|█▊        | 90/512 [07:02<33:03,  4.70s/it]
data 139:  20%|█▉        | 100/512 [07:48<32:03,  4.67s/it]
data 139:  21%|██▏       | 110/512 [08:34<31:17,  4.67s/it]
data 139:  23%|██▎       | 120/512 [09:22<30:36,  4.69s/it]
data 139:  23%|██▎       | 120/512 [09:26<30:51,  4.72s/it]
INFO:root:函数头: 
def vals2bins(vals,res=100):

INFO:root:目标函数体: 
    
    # flatten if list of lists
    if any(isinstance(el, list) for el in vals):
        vals = list(itertools.chain(*vals))
    return list(np.digitize(vals, np.linspace(np.min(vals), np.max(vals)+1, res+1)) - 1)

INFO:root:生成结果: 
    # flatten if list of lists
    if any(isinstance(el, list) for el in vals):
        vals = list(itertools.chain(*vals))
    # get unique values and sort them
    unique_vals = sorted(list(set(vals)))
    # calculate the bin width
    bin_width = (unique_vals[-1] - unique_vals[0]) / res
    # create bins
    bins = np.arange(unique_vals[0], unique_vals[-1] + bin_width, bin_width)
    # map values to bins
    return np.searchsorted(b bins, vals)




INFO:root:----------------------------------------
INFO:root:max length: 7773
INFO:root:max position: 10690
INFO:root:target_namespace: hypertools.hypertools<folder>._shared<folder>.helpers<file>.vals2bins<func>
INFO:root:****************************************

data 139:   0%|          | 0/512 [00:00<?, ?it/s]
data 139:   2%|▏         | 10/512 [00:43<36:46,  4.40s/it]
data 139:   4%|▍         | 20/512 [01:31<37:56,  4.63s/it]
data 139:   6%|▌         | 30/512 [02:16<36:37,  4.56s/it]
data 139:   8%|▊         | 40/512 [03:05<36:43,  4.67s/it]
data 139:  10%|▉         | 50/512 [03:52<36:17,  4.71s/it]
data 139:  10%|▉         | 50/512 [04:31<41:44,  5.42s/it]
INFO:root:函数头: 
def vals2bins(vals,res=100):

INFO:root:目标函数体: 
    
    # flatten if list of lists
    if any(isinstance(el, list) for el in vals):
        vals = list(itertools.chain(*vals))
    return list(np.digitize(vals, np.linspace(np.min(vals), np.max(vals)+1, res+1)) - 1)

INFO:root:生成结果: 
    if any(isinstance(el, list) for el in vals):
        vals = list(itertools.chain(*vals))
    ranks = np.digitize(vals, np.linspace(np.min(vals), np.max(vals)+1, res+1)) - 1
    return ranks




INFO:root:----------------------------------------
INFO:root:max length: 7840
INFO:root:max position: 10939
INFO:root:target_namespace: hypertools.hypertools<folder>._shared<folder>.helpers<file>.vals2bins<func>
INFO:root:****************************************

data 139:   0%|          | 0/512 [00:00<?, ?it/s]
data 139:   2%|▏         | 10/512 [00:44<37:06,  4.44s/it]
data 139:   4%|▍         | 20/512 [01:31<37:55,  4.63s/it]
data 139:   6%|▌         | 30/512 [02:16<36:33,  4.55s/it]
data 139:   8%|▊         | 40/512 [03:04<36:26,  4.63s/it]
data 139:   8%|▊         | 40/512 [03:18<39:02,  4.96s/it]
INFO:root:函数头: 
def vals2bins(vals,res=100):

INFO:root:目标函数体: 
    
    # flatten if list of lists
    if any(isinstance(el, list) for el in vals):
        vals = list(itertools.chain(*vals))
    return list(np.digitize(vals, np.linspace(np.min(vals), np.max(vals)+1, res+1)) - 1)

INFO:root:生成结果: 
    if any(isinstance(el, list) for el in vals):
        vals = list(itertools.chain(*vals))
    return np.linspace(np.min(vals), np.max(vals)+1, res+1)




INFO:root:----------------------------------------
INFO:root:max length: 8015
INFO:root:max position: 10475
INFO:root:target_namespace: hypertools.hypertools<folder>._shared<folder>.helpers<file>.vals2bins<func>
INFO:root:****************************************

data 139:   0%|          | 0/512 [00:00<?, ?it/s]
data 139:   2%|▏         | 10/512 [00:44<37:01,  4.43s/it]
data 139:   4%|▍         | 20/512 [01:33<38:53,  4.74s/it]
data 139:   6%|▌         | 30/512 [02:20<37:39,  4.69s/it]
data 139:   8%|▊         | 40/512 [03:07<37:04,  4.71s/it]
data 139:   8%|▊         | 40/512 [03:22<39:54,  5.07s/it]
INFO:root:函数头: 
def vals2bins(vals,res=100):

INFO:root:目标函数体: 
    
    # flatten if list of lists
    if any(isinstance(el, list) for el in vals):
        vals = list(itertools.chain(*vals))
    return list(np.digitize(vals, np.linspace(np.min(vals), np.max(vals)+1, res+1)) - 1)

INFO:root:生成结果: 
    if any(isinstance(el, list) for el in vals):
        vals = list(itertools.chain(*vals))
    return np.linspace(np.min(vals), np.max(vals)+1, res+1)




INFO:root:----------------------------------------
INFO:root:max length: 7776
INFO:root:max position: 10731
INFO:root:target_namespace: hypertools.hypertools<folder>._shared<folder>.helpers<file>.vals2bins<func>
INFO:root:****************************************
INFO:root:--------data 140--------

data 140:   0%|          | 0/512 [00:00<?, ?it/s]
data 140:   2%|▏         | 10/512 [00:44<36:57,  4.42s/it]
data 140:   2%|▏         | 10/512 [01:15<1:03:32,  7.59s/it]
INFO:root:函数头: 
def interp_array(arr,interp_val=10):

INFO:root:目标函数体: 
    x=np.arange(0, len(arr), 1)
    xx=np.arange(0, len(arr)-1, 1/interp_val)
    q=pchip(x,arr)
    return q(xx)

INFO:root:生成结果: 
    return pchip(np.arange(len(arr)), arr).interp(interp_val)




INFO:root:----------------------------------------
INFO:root:max length: 7339
INFO:root:max position: 10223
INFO:root:target_namespace: hypertools.hypertools<folder>._shared<folder>.helpers<file>.interp_array<func>
INFO:root:****************************************

data 140:   0%|          | 0/512 [00:00<?, ?it/s]
data 140:   2%|▏         | 10/512 [00:41<34:46,  4.16s/it]
data 140:   4%|▍         | 20/512 [01:28<36:54,  4.50s/it]
data 140:   6%|▌         | 30/512 [02:17<37:20,  4.65s/it]
data 140:   8%|▊         | 40/512 [03:03<36:31,  4.64s/it]
data 140:  10%|▉         | 50/512 [03:50<35:45,  4.64s/it]
data 140:  12%|█▏        | 60/512 [04:37<35:14,  4.68s/it]
data 140:  14%|█▎        | 70/512 [05:23<34:16,  4.65s/it]
data 140:  16%|█▌        | 80/512 [06:11<33:43,  4.69s/it]
data 140:  18%|█▊        | 90/512 [06:59<33:15,  4.73s/it]
data 140:  20%|█▉        | 100/512 [07:46<32:29,  4.73s/it]
data 140:  21%|██▏       | 110/512 [08:31<31:09,  4.65s/it]
data 140:  23%|██▎       | 120/512 [09:14<29:49,  4.56s/it]
data 140:  25%|██▌       | 130/512 [10:00<28:56,  4.55s/it]
data 140:  27%|██▋       | 140/512 [10:49<28:54,  4.66s/it]
data 140:  27%|██▋       | 140/512 [11:22<30:13,  4.88s/it]
INFO:root:函数头: 
def interp_array(arr,interp_val=10):

INFO:root:目标函数体: 
    x=np.arange(0, len(arr), 1)
    xx=np.arange(0, len(arr)-1, 1/interp_val)
    q=pchip(x,arr)
    return q(xx)

INFO:root:生成结果: 
    # Check if the input array is a numpy array
    if not isinstance(arr, np.ndarray):
        raise TypeError("Input array must be a numpy array.")
    
    # Check if the interpolation value is an integer
    if not isinstance(interp_val, int):
        raise TypeError("Interpolation value must be an integer.")
    
    # Check if the interpolation value is positive
    if interp_val <= 0:
        raise ValueError("Interpolation value must be positive.")
    
    # Perform piecewise cubic Hermite interpolation
    interp_func = pchip(np.arange(len(arr)), arr)
    interp_array = interp_func(np.linspace(0, len(arr)-1, interp_val))
    
    return interp_array




INFO:root:----------------------------------------
INFO:root:max length: 8681
INFO:root:max position: 10790
INFO:root:target_namespace: hypertools.hypertools<folder>._shared<folder>.helpers<file>.interp_array<func>
INFO:root:****************************************

data 140:   0%|          | 0/512 [00:00<?, ?it/s]
data 140:   2%|▏         | 10/512 [00:39<33:08,  3.96s/it]
data 140:   4%|▍         | 20/512 [01:21<33:47,  4.12s/it]
data 140:   6%|▌         | 30/512 [02:06<34:24,  4.28s/it]
data 140:   8%|▊         | 40/512 [02:52<34:31,  4.39s/it]
data 140:  10%|▉         | 50/512 [03:39<34:48,  4.52s/it]
data 140:  12%|█▏        | 60/512 [04:27<34:41,  4.61s/it]
data 140:  12%|█▏        | 60/512 [05:15<39:34,  5.25s/it]
INFO:root:函数头: 
def interp_array(arr,interp_val=10):

INFO:root:目标函数体: 
    x=np.arange(0, len(arr), 1)
    xx=np.arange(0, len(arr)-1, 1/interp_val)
    q=pchip(x,arr)
    return q(xx)

INFO:root:生成结果: 
    # Create a PchipInterpolator object
    interpolator = pchip(np.arange(len(arr)), arr)

    # Generate new points for interpolation
    new_points = np.linspace(0, len(arr)-1, interp_val)

    # Interpolate the array
    interpolated_array = interpolator(new_points)

    return interpolated_array




INFO:root:----------------------------------------
INFO:root:max length: 8335
INFO:root:max position: 10877
INFO:root:target_namespace: hypertools.hypertools<folder>._shared<folder>.helpers<file>.interp_array<func>
INFO:root:****************************************

data 140:   0%|          | 0/512 [00:00<?, ?it/s]
data 140:   2%|▏         | 10/512 [00:41<34:34,  4.13s/it]
data 140:   4%|▍         | 20/512 [01:27<36:25,  4.44s/it]
data 140:   6%|▌         | 30/512 [02:14<36:25,  4.53s/it]
data 140:   6%|▌         | 30/512 [02:28<39:44,  4.95s/it]
INFO:root:函数头: 
def interp_array(arr,interp_val=10):

INFO:root:目标函数体: 
    x=np.arange(0, len(arr), 1)
    xx=np.arange(0, len(arr)-1, 1/interp_val)
    q=pchip(x,arr)
    return q(xx)

INFO:root:生成结果: 
    interp_arr = pchip(np.arange(len(arr)), arr)(np.linspace(0, len(arr)-1, interp_val))
    return interp_arr


INFO:root:----------------------------------------
INFO:root:max length: 7597
INFO:root:max position: 10373
INFO:root:target_namespace: hypertools.hypertools<folder>._shared<folder>.helpers<file>.interp_array<func>
INFO:root:****************************************

data 140:   0%|          | 0/512 [00:00<?, ?it/s]
data 140:   2%|▏         | 10/512 [00:41<34:38,  4.14s/it]
data 140:   4%|▍         | 20/512 [01:29<37:04,  4.52s/it]
data 140:   6%|▌         | 30/512 [02:17<37:22,  4.65s/it]
data 140:   8%|▊         | 40/512 [03:03<36:29,  4.64s/it]
data 140:  10%|▉         | 50/512 [03:48<35:20,  4.59s/it]
data 140:  12%|█▏        | 60/512 [04:34<34:28,  4.58s/it]
data 140:  14%|█▎        | 70/512 [05:18<33:20,  4.53s/it]
data 140:  16%|█▌        | 80/512 [06:01<32:08,  4.46s/it]
data 140:  18%|█▊        | 90/512 [06:46<31:25,  4.47s/it]
data 140:  20%|█▉        | 100/512 [07:31<30:40,  4.47s/it]
data 140:  21%|██▏       | 110/512 [08:20<30:57,  4.62s/it]
data 140:  21%|██▏       | 110/512 [08:48<32:11,  4.80s/it]
INFO:root:函数头: 
def interp_array(arr,interp_val=10):

INFO:root:目标函数体: 
    x=np.arange(0, len(arr), 1)
    xx=np.arange(0, len(arr)-1, 1/interp_val)
    q=pchip(x,arr)
    return q(xx)

INFO:root:生成结果: 
    # Check if the input array is valid
    if not isinstance(arr, np.ndarray):
        raise ValueError("Input array must be a numpy array.")
    
    # Check if the interpolation value is valid
    if not isinstance(interp_val, int):
        raise ValueError("Interpolation value must be an integer.")
    
    # Perform piecewise cubic Hermite interpolation using scipy
    interp_func = pchip(np.arange(len(arr)), arr)
    interp_arr = interp_func(np.linspace(0, len(arr)-1, interp_val))
    
    return interp_arr




INFO:root:----------------------------------------
INFO:root:max length: 7892
INFO:root:max position: 10670
INFO:root:target_namespace: hypertools.hypertools<folder>._shared<folder>.helpers<file>.interp_array<func>
INFO:root:****************************************
INFO:root:--------data 141--------

data 141:   0%|          | 0/512 [00:00<?, ?it/s]
data 141:   2%|▏         | 10/512 [00:50<41:56,  5.01s/it]
data 141:   4%|▍         | 20/512 [01:40<41:14,  5.03s/it]
data 141:   6%|▌         | 30/512 [02:31<40:34,  5.05s/it]
data 141:   8%|▊         | 40/512 [03:20<39:16,  4.99s/it]
data 141:  10%|▉         | 50/512 [04:10<38:23,  4.99s/it]
data 141:  10%|▉         | 50/512 [04:58<45:57,  5.97s/it]
INFO:root:函数头: 
def parse_args(x,args):

INFO:root:目标函数体: 
    args_list = []
    for i,item in enumerate(x):
        tmp = []
        for ii, arg in enumerate(args):
            if isinstance(arg, (tuple, list)):
                if len(arg) == len(x):
                    tmp.append(arg[i])
                else:
                    print('Error: arguments must be a list of the same length as x')
                    sys.exit(1)
            else:
                tmp.append(arg)
        args_list.append(tuple(tmp))
    return args_list

INFO:root:生成结果: 
    if len(args) != len(x):
        print("Error: Length of args must be the same as length of x")
        exit()
    result = []
    for i in range(len(x)):
        result.append(tuple([x[i]] + list(args[i])))
    return result




INFO:root:----------------------------------------
INFO:root:max length: 7981
INFO:root:max position: 10960
INFO:root:target_namespace: hypertools.hypertools<folder>._shared<folder>.helpers<file>.parse_args<func>
INFO:root:****************************************

data 141:   0%|          | 0/512 [00:00<?, ?it/s]
data 141:   2%|▏         | 10/512 [00:48<40:51,  4.88s/it]
data 141:   4%|▍         | 20/512 [01:36<39:42,  4.84s/it]
data 141:   6%|▌         | 30/512 [02:25<38:58,  4.85s/it]
data 141:   8%|▊         | 40/512 [03:14<38:12,  4.86s/it]
data 141:  10%|▉         | 50/512 [04:03<37:28,  4.87s/it]
data 141:  12%|█▏        | 60/512 [04:54<37:22,  4.96s/it]
data 141:  14%|█▎        | 70/512 [05:45<36:45,  4.99s/it]
data 141:  16%|█▌        | 80/512 [06:34<35:46,  4.97s/it]
data 141:  18%|█▊        | 90/512 [07:21<34:30,  4.91s/it]
data 141:  20%|█▉        | 100/512 [08:12<33:57,  4.95s/it]
data 141:  21%|██▏       | 110/512 [08:59<32:34,  4.86s/it]
data 141:  21%|██▏       | 110/512 [09:18<34:02,  5.08s/it]
INFO:root:函数头: 
def parse_args(x,args):

INFO:root:目标函数体: 
    args_list = []
    for i,item in enumerate(x):
        tmp = []
        for ii, arg in enumerate(args):
            if isinstance(arg, (tuple, list)):
                if len(arg) == len(x):
                    tmp.append(arg[i])
                else:
                    print('Error: arguments must be a list of the same length as x')
                    sys.exit(1)
            else:
                tmp.append(arg)
        args_list.append(tuple(tmp))
    return args_list

INFO:root:生成结果: 
    # Check if args is a list or tuple
    if not isinstance(args, (list, tuple)):
        raise TypeError("args must be a list or tuple")
    
    # Check if args has the same length as x
    if len(args) != len(x):
        raise ValueError("args must have the same length as x")
    
    # Create a list of tuples by combining elements of x and args
    result = []
    for i in range(len(x)):
        result.append((x[i], args[i]))
    
    return result




INFO:root:----------------------------------------
INFO:root:max length: 8379
INFO:root:max position: 10864
INFO:root:target_namespace: hypertools.hypertools<folder>._shared<folder>.helpers<file>.parse_args<func>
INFO:root:****************************************

data 141:   0%|          | 0/512 [00:00<?, ?it/s]
data 141:   2%|▏         | 10/512 [00:45<38:01,  4.55s/it]
data 141:   4%|▍         | 20/512 [01:35<39:34,  4.83s/it]
data 141:   6%|▌         | 30/512 [02:23<38:25,  4.78s/it]
data 141:   6%|▌         | 30/512 [02:57<47:31,  5.92s/it]
INFO:root:函数头: 
def parse_args(x,args):

INFO:root:目标函数体: 
    args_list = []
    for i,item in enumerate(x):
        tmp = []
        for ii, arg in enumerate(args):
            if isinstance(arg, (tuple, list)):
                if len(arg) == len(x):
                    tmp.append(arg[i])
                else:
                    print('Error: arguments must be a list of the same length as x')
                    sys.exit(1)
            else:
                tmp.append(arg)
        args_list.append(tuple(tmp))
    return args_list

INFO:root:生成结果: 
    if len(args) != len(x):
        print("Error: Length of args must be the same as length of x")
        exit()
    return list(zip(x,args))




INFO:root:----------------------------------------
INFO:root:max length: 7715
INFO:root:max position: 10785
INFO:root:target_namespace: hypertools.hypertools<folder>._shared<folder>.helpers<file>.parse_args<func>
INFO:root:****************************************

data 141:   0%|          | 0/512 [00:00<?, ?it/s]
data 141:   2%|▏         | 10/512 [00:46<38:55,  4.65s/it]
data 141:   4%|▍         | 20/512 [01:35<39:29,  4.82s/it]
data 141:   6%|▌         | 30/512 [02:24<38:57,  4.85s/it]
data 141:   8%|▊         | 40/512 [03:14<38:37,  4.91s/it]
data 141:  10%|▉         | 50/512 [04:04<38:03,  4.94s/it]
data 141:  12%|█▏        | 60/512 [04:56<37:51,  5.03s/it]
data 141:  14%|█▎        | 70/512 [05:45<36:40,  4.98s/it]
data 141:  16%|█▌        | 80/512 [06:36<36:12,  5.03s/it]
data 141:  18%|█▊        | 90/512 [07:26<35:09,  5.00s/it]
data 141:  20%|█▉        | 100/512 [08:14<34:04,  4.96s/it]
data 141:  21%|██▏       | 110/512 [09:03<33:00,  4.93s/it]
data 141:  21%|██▏       | 110/512 [09:24<34:22,  5.13s/it]
INFO:root:函数头: 
def parse_args(x,args):

INFO:root:目标函数体: 
    args_list = []
    for i,item in enumerate(x):
        tmp = []
        for ii, arg in enumerate(args):
            if isinstance(arg, (tuple, list)):
                if len(arg) == len(x):
                    tmp.append(arg[i])
                else:
                    print('Error: arguments must be a list of the same length as x')
                    sys.exit(1)
            else:
                tmp.append(arg)
        args_list.append(tuple(tmp))
    return args_list

INFO:root:生成结果: 
    # Check if args is a list or tuple
    if not isinstance(args, (list, tuple)):
        raise ValueError("args must be a list or tuple")
    
    # Check if args has the same length as x
    if len(args) != len(x):
        raise ValueError("args must have the same length as x")
    
    # Create a list of tuples by combining elements of x and args
    result = []
    for i in range(len(x)):
        result.append((x[i], args[i]))
    
    return result


INFO:root:----------------------------------------
INFO:root:max length: 8166
INFO:root:max position: 10619
INFO:root:target_namespace: hypertools.hypertools<folder>._shared<folder>.helpers<file>.parse_args<func>
INFO:root:****************************************

data 141:   0%|          | 0/512 [00:00<?, ?it/s]
data 141:   2%|▏         | 10/512 [00:46<38:33,  4.61s/it]
data 141:   4%|▍         | 20/512 [01:37<40:09,  4.90s/it]
data 141:   6%|▌         | 30/512 [02:27<39:56,  4.97s/it]
data 141:   8%|▊         | 40/512 [03:17<39:12,  4.98s/it]
data 141:  10%|▉         | 50/512 [04:07<38:20,  4.98s/it]
data 141:  12%|█▏        | 60/512 [04:55<37:09,  4.93s/it]
data 141:  14%|█▎        | 70/512 [05:44<36:09,  4.91s/it]
data 141:  16%|█▌        | 80/512 [06:34<35:39,  4.95s/it]
data 141:  16%|█▌        | 80/512 [07:09<38:36,  5.36s/it]
INFO:root:函数头: 
def parse_args(x,args):

INFO:root:目标函数体: 
    args_list = []
    for i,item in enumerate(x):
        tmp = []
        for ii, arg in enumerate(args):
            if isinstance(arg, (tuple, list)):
                if len(arg) == len(x):
                    tmp.append(arg[i])
                else:
                    print('Error: arguments must be a list of the same length as x')
                    sys.exit(1)
            else:
                tmp.append(arg)
        args_list.append(tuple(tmp))
    return args_list

INFO:root:生成结果: 
    result = []
    for i in range(len(x)):
        if isinstance(args[i], list) or isinstance(args[i], tuple):
            if len(args[i]) != len(x):
                print("Error: Length of args must be the same as x")
                exit()
            result.append(tuple([x[i]] + list(args[i])))
        else:
            result.append((x[i], args[i]))
    return result




INFO:root:----------------------------------------
INFO:root:max length: 8057
INFO:root:max position: 11185
INFO:root:target_namespace: hypertools.hypertools<folder>._shared<folder>.helpers<file>.parse_args<func>
INFO:root:****************************************
INFO:root:--------data 142--------

data 142:   0%|          | 0/512 [00:00<?, ?it/s]
data 142:   2%|▏         | 10/512 [00:47<40:03,  4.79s/it]
data 142:   4%|▍         | 20/512 [01:37<39:55,  4.87s/it]
data 142:   6%|▌         | 30/512 [02:27<39:50,  4.96s/it]
data 142:   8%|▊         | 40/512 [03:20<39:58,  5.08s/it]
data 142:   8%|▊         | 40/512 [03:41<43:32,  5.54s/it]
INFO:root:函数头: 
def parse_kwargs(x, kwargs):

INFO:root:目标函数体: 
    kwargs_list = []
    for i,item in enumerate(x):
        tmp = {}
        for kwarg in kwargs:
            if isinstance(kwargs[kwarg], (tuple, list)):
                if len(kwargs[kwarg]) == len(x):
                    tmp[kwarg]=kwargs[kwarg][i]
                else:
                    tmp[kwarg] = None
            else:
                tmp[kwarg]=kwargs[kwarg]
        kwargs_list.append(tmp)
    return kwargs_list

INFO:root:生成结果: 
    args_list = []
    for item in x:
        tmp = {}
        for key, arg in kwargs.items():
            tmp[key] = arg
        args_list.append(tmp)
    return args_list




INFO:root:----------------------------------------
INFO:root:max length: 7404
INFO:root:max position: 11020
INFO:root:target_namespace: hypertools.hypertools<folder>._shared<folder>.helpers<file>.parse_kwargs<func>
INFO:root:****************************************

data 142:   0%|          | 0/512 [00:00<?, ?it/s]
data 142:   2%|▏         | 10/512 [01:43<1:26:42, 10.36s/it]
data 142:   4%|▍         | 20/512 [02:34<59:36,  7.27s/it]  
data 142:   6%|▌         | 30/512 [03:27<51:02,  6.35s/it]
data 142:   8%|▊         | 40/512 [04:18<46:13,  5.88s/it]
data 142:   8%|▊         | 40/512 [04:39<54:57,  6.99s/it]
INFO:root:函数头: 
def parse_kwargs(x, kwargs):

INFO:root:目标函数体: 
    kwargs_list = []
    for i,item in enumerate(x):
        tmp = {}
        for kwarg in kwargs:
            if isinstance(kwargs[kwarg], (tuple, list)):
                if len(kwargs[kwarg]) == len(x):
                    tmp[kwarg]=kwargs[kwarg][i]
                else:
                    tmp[kwarg] = None
            else:
                tmp[kwarg]=kwargs[kwarg]
        kwargs_list.append(tmp)
    return kwargs_list

INFO:root:生成结果: 
    args_list = []
    for item in x:
        tmp = {}
        for key, value in kwargs.items():
            tmp[key] = value
        args_list.append(tmp)
    return args_list




INFO:root:----------------------------------------
INFO:root:max length: 7417
INFO:root:max position: 11414
INFO:root:target_namespace: hypertools.hypertools<folder>._shared<folder>.helpers<file>.parse_kwargs<func>
INFO:root:****************************************

data 142:   0%|          | 0/512 [00:00<?, ?it/s]
data 142:   2%|▏         | 10/512 [00:44<37:03,  4.43s/it]
data 142:   4%|▍         | 20/512 [01:32<38:18,  4.67s/it]
data 142:   6%|▌         | 30/512 [02:23<39:10,  4.88s/it]
data 142:   8%|▊         | 40/512 [03:13<38:28,  4.89s/it]
data 142:   8%|▊         | 40/512 [03:32<41:48,  5.32s/it]
INFO:root:函数头: 
def parse_kwargs(x, kwargs):

INFO:root:目标函数体: 
    kwargs_list = []
    for i,item in enumerate(x):
        tmp = {}
        for kwarg in kwargs:
            if isinstance(kwargs[kwarg], (tuple, list)):
                if len(kwargs[kwarg]) == len(x):
                    tmp[kwarg]=kwargs[kwarg][i]
                else:
                    tmp[kwarg] = None
            else:
                tmp[kwarg]=kwargs[kwarg]
        kwargs_list.append(tmp)
    return kwargs_list

INFO:root:生成结果: 
    args_list = []
    for item in x:
        tmp = {}
        for key, value in kwargs.items():
            tmp[key] = value
        args_list.append(tmp)
    return args_list




INFO:root:----------------------------------------
INFO:root:max length: 7334
INFO:root:max position: 10867
INFO:root:target_namespace: hypertools.hypertools<folder>._shared<folder>.helpers<file>.parse_kwargs<func>
INFO:root:****************************************

data 142:   0%|          | 0/512 [00:00<?, ?it/s]
data 142:   2%|▏         | 10/512 [00:43<36:29,  4.36s/it]
data 142:   4%|▍         | 20/512 [01:32<38:31,  4.70s/it]
data 142:   6%|▌         | 30/512 [02:23<39:01,  4.86s/it]
data 142:   8%|▊         | 40/512 [03:13<38:49,  4.94s/it]
data 142:   8%|▊         | 40/512 [03:34<42:09,  5.36s/it]
INFO:root:函数头: 
def parse_kwargs(x, kwargs):

INFO:root:目标函数体: 
    kwargs_list = []
    for i,item in enumerate(x):
        tmp = {}
        for kwarg in kwargs:
            if isinstance(kwargs[kwarg], (tuple, list)):
                if len(kwargs[kwarg]) == len(x):
                    tmp[kwarg]=kwargs[kwarg][i]
                else:
                    tmp[kwarg] = None
            else:
                tmp[kwarg]=kwargs[kwarg]
        kwargs_list.append(tmp)
    return kwargs_list

INFO:root:生成结果: 
    args_list = []
    for item in x:
        tmp = {}
        for key, value in kwargs.items():
            tmp[key] = value
        args_list.append(tmp)
    return args_list




INFO:root:----------------------------------------
INFO:root:max length: 8162
INFO:root:max position: 11158
INFO:root:target_namespace: hypertools.hypertools<folder>._shared<folder>.helpers<file>.parse_kwargs<func>
INFO:root:****************************************

data 142:   0%|          | 0/512 [00:00<?, ?it/s]
data 142:   2%|▏         | 10/512 [00:45<38:00,  4.54s/it]
data 142:   4%|▍         | 20/512 [01:37<40:19,  4.92s/it]
data 142:   6%|▌         | 30/512 [02:26<39:28,  4.91s/it]
data 142:   8%|▊         | 40/512 [03:17<39:10,  4.98s/it]
data 142:   8%|▊         | 40/512 [03:35<42:26,  5.39s/it]
INFO:root:函数头: 
def parse_kwargs(x, kwargs):

INFO:root:目标函数体: 
    kwargs_list = []
    for i,item in enumerate(x):
        tmp = {}
        for kwarg in kwargs:
            if isinstance(kwargs[kwarg], (tuple, list)):
                if len(kwargs[kwarg]) == len(x):
                    tmp[kwarg]=kwargs[kwarg][i]
                else:
                    tmp[kwarg] = None
            else:
                tmp[kwarg]=kwargs[kwarg]
        kwargs_list.append(tmp)
    return kwargs_list

INFO:root:生成结果: 
    args_list = []
    for item in x:
        tmp = {}
        for key, value in kwargs.items():
            tmp[key] = value
        args_list.append(tmp)
    return args_list




INFO:root:----------------------------------------
INFO:root:max length: 7944
INFO:root:max position: 10892
INFO:root:target_namespace: hypertools.hypertools<folder>._shared<folder>.helpers<file>.parse_kwargs<func>
INFO:root:****************************************
INFO:root:--------data 143--------

data 143:   0%|          | 0/512 [00:00<?, ?it/s]
data 143:   2%|▏         | 10/512 [00:05<04:49,  1.73it/s]
data 143:   4%|▍         | 20/512 [00:10<04:23,  1.87it/s]
data 143:   6%|▌         | 30/512 [00:15<04:12,  1.91it/s]
data 143:   8%|▊         | 40/512 [00:21<04:04,  1.93it/s]
data 143:  10%|▉         | 50/512 [00:26<03:57,  1.94it/s]
data 143:  12%|█▏        | 60/512 [00:31<03:52,  1.94it/s]
data 143:  14%|█▎        | 70/512 [00:36<03:46,  1.95it/s]
data 143:  16%|█▌        | 80/512 [00:41<03:42,  1.94it/s]
data 143:  18%|█▊        | 90/512 [00:46<03:37,  1.94it/s]
data 143:  20%|█▉        | 100/512 [00:51<03:30,  1.96it/s]
data 143:  21%|██▏       | 110/512 [00:56<03:24,  1.96it/s]
data 143:  21%|██▏       | 110/512 [00:59<03:38,  1.84it/s]
INFO:root:函数头: 
def _get_default_display_mode(environ):

INFO:root:目标函数体: 
    TERM = environ.get('TERM', '').lower()
    # FIXME: COLORTERM may not be accepted by sshd
    COLORTERM = environ.get('COLORTERM', '').lower()
    if 'truecolor' in TERM or 'truecolor' in COLORTERM:
        return 'truecolor'
    elif '256' in TERM or '256' in COLORTERM:
        return '256fgbg'
    return 'nocolor'

INFO:root:生成结果: 
    term = environ.get('TERM')
    colorterm = environ.get('COLORTERM')

    if term and 'truecolor' in term.lower():
        return 'truecolor'

    if term and '256' in term.lower():
        return '256fgbg'

    if colorterm and 'truecolor' in colorterm.lower():
        return 'truecolor'

    if colorterm and '256' in colorterm.lower():
        return '256fgbg'

    return 'nocolor'




INFO:root:----------------------------------------
INFO:root:max length: 2555
INFO:root:max position: 2555
INFO:root:target_namespace: gif-for-cli.gif_for_cli<folder>.utils<file>._get_default_display_mode<func>
INFO:root:****************************************

data 143:   0%|          | 0/512 [00:00<?, ?it/s]
data 143:   2%|▏         | 10/512 [00:04<04:02,  2.07it/s]
data 143:   4%|▍         | 20/512 [00:10<04:08,  1.98it/s]
data 143:   6%|▌         | 30/512 [00:15<04:08,  1.94it/s]
data 143:   8%|▊         | 40/512 [00:20<04:05,  1.92it/s]
data 143:  10%|▉         | 50/512 [00:25<04:00,  1.92it/s]
data 143:  12%|█▏        | 60/512 [00:31<03:57,  1.91it/s]
data 143:  14%|█▎        | 70/512 [00:36<03:52,  1.90it/s]
data 143:  16%|█▌        | 80/512 [00:41<03:48,  1.89it/s]
data 143:  16%|█▌        | 80/512 [00:46<04:13,  1.70it/s]
INFO:root:函数头: 
def _get_default_display_mode(environ):

INFO:root:目标函数体: 
    TERM = environ.get('TERM', '').lower()
    # FIXME: COLORTERM may not be accepted by sshd
    COLORTERM = environ.get('COLORTERM', '').lower()
    if 'truecolor' in TERM or 'truecolor' in COLORTERM:
        return 'truecolor'
    elif '256' in TERM or '256' in COLORTERM:
        return '256fgbg'
    return 'nocolor'

INFO:root:生成结果: 
    term = environ.get('TERM', '').lower()
    colorterm = environ.get('COLORTERM', '').lower()

    if 'truecolor' in term or 'truecolor' in colorterm:
        return 'truecolor'
    elif '256' in term or '256' in colorterm:
        return '256fgbg'
    else:
        return 'nocolor'




INFO:root:----------------------------------------
INFO:root:max length: 2529
INFO:root:max position: 2529
INFO:root:target_namespace: gif-for-cli.gif_for_cli<folder>.utils<file>._get_default_display_mode<func>
INFO:root:****************************************

data 143:   0%|          | 0/512 [00:00<?, ?it/s]
data 143:   2%|▏         | 10/512 [00:04<04:01,  2.08it/s]
data 143:   4%|▍         | 20/512 [00:10<04:09,  1.97it/s]
data 143:   6%|▌         | 30/512 [00:15<04:07,  1.95it/s]
data 143:   8%|▊         | 40/512 [00:20<04:05,  1.93it/s]
data 143:  10%|▉         | 50/512 [00:25<03:58,  1.93it/s]
data 143:  12%|█▏        | 60/512 [00:30<03:55,  1.92it/s]
data 143:  14%|█▎        | 70/512 [00:36<03:50,  1.91it/s]
data 143:  16%|█▌        | 80/512 [00:41<03:45,  1.91it/s]
data 143:  16%|█▌        | 80/512 [00:46<04:12,  1.71it/s]
INFO:root:函数头: 
def _get_default_display_mode(environ):

INFO:root:目标函数体: 
    TERM = environ.get('TERM', '').lower()
    # FIXME: COLORTERM may not be accepted by sshd
    COLORTERM = environ.get('COLORTERM', '').lower()
    if 'truecolor' in TERM or 'truecolor' in COLORTERM:
        return 'truecolor'
    elif '256' in TERM or '256' in COLORTERM:
        return '256fgbg'
    return 'nocolor'

INFO:root:生成结果: 
    term = environ.get('TERM', '').lower()
    colorterm = environ.get('COLORTTERM', '').lower()

    if 'truecolor' in term or 'truecolor' in colorterm:
        return 'truecolor'
    elif '256' in term or '256' in colorterm:
        return '256fgbg'
    else:
        return 'nocolor'




INFO:root:----------------------------------------
INFO:root:max length: 2529
INFO:root:max position: 2529
INFO:root:target_namespace: gif-for-cli.gif_for_cli<folder>.utils<file>._get_default_display_mode<func>
INFO:root:****************************************

data 143:   0%|          | 0/512 [00:00<?, ?it/s]
data 143:   2%|▏         | 10/512 [00:04<04:03,  2.06it/s]
data 143:   4%|▍         | 20/512 [00:10<04:09,  1.97it/s]
data 143:   6%|▌         | 30/512 [00:15<04:07,  1.95it/s]
data 143:   8%|▊         | 40/512 [00:20<04:03,  1.94it/s]
data 143:  10%|▉         | 50/512 [00:25<04:00,  1.92it/s]
data 143:  12%|█▏        | 60/512 [00:31<03:56,  1.91it/s]
data 143:  14%|█▎        | 70/512 [00:36<03:52,  1.90it/s]
data 143:  16%|█▌        | 80/512 [00:41<03:49,  1.88it/s]
data 143:  16%|█▌        | 80/512 [00:44<04:02,  1.78it/s]
INFO:root:函数头: 
def _get_default_display_mode(environ):

INFO:root:目标函数体: 
    TERM = environ.get('TERM', '').lower()
    # FIXME: COLORTERM may not be accepted by sshd
    COLORTERM = environ.get('COLORTERM', '').lower()
    if 'truecolor' in TERM or 'truecolor' in COLORTERM:
        return 'truecolor'
    elif '256' in TERM or '256' in COLORTERM:
        return '256fgbg'
    return 'nocolor'

INFO:root:生成结果: 
    term = environ.get('TERM', '')
    colorterm = environ.get('COLORTERM', '')

    if 'truecolor' in term or 'truecolor' in colorterm:
        return 'truecolor'
    elif '256' in term or '256' in colorterm:
        return '256fgbg'
    else:
        return 'nocolor'




INFO:root:----------------------------------------
INFO:root:max length: 2525
INFO:root:max position: 2525
INFO:root:target_namespace: gif-for-cli.gif_for_cli<folder>.utils<file>._get_default_display_mode<func>
INFO:root:****************************************

data 143:   0%|          | 0/512 [00:00<?, ?it/s]
data 143:   2%|▏         | 10/512 [00:04<03:49,  2.19it/s]
data 143:   4%|▍         | 20/512 [00:09<03:55,  2.09it/s]
data 143:   6%|▌         | 30/512 [00:14<03:56,  2.04it/s]
data 143:   8%|▊         | 40/512 [00:19<03:55,  2.00it/s]
data 143:  10%|▉         | 50/512 [00:24<03:52,  1.99it/s]
data 143:  12%|█▏        | 60/512 [00:30<03:51,  1.95it/s]
data 143:  14%|█▎        | 70/512 [00:35<03:48,  1.94it/s]
data 143:  16%|█▌        | 80/512 [00:40<03:44,  1.93it/s]
data 143:  16%|█▌        | 80/512 [00:45<04:07,  1.74it/s]
INFO:root:函数头: 
def _get_default_display_mode(environ):

INFO:root:目标函数体: 
    TERM = environ.get('TERM', '').lower()
    # FIXME: COLORTERM may not be accepted by sshd
    COLORTERM = environ.get('COLORTERM', '').lower()
    if 'truecolor' in TERM or 'truecolor' in COLORTERM:
        return 'truecolor'
    elif '256' in TERM or '256' in COLORTERM:
        return '256fgbg'
    return 'nocolor'

INFO:root:生成结果: 
    term = environ.get('TERM', '').lower()
    colorterm = environ.get('COLORTERM', '').lower()

    if 'truecolor' in term or 'truecolor' in colorterm:
        return 'truecolor'
    elif '256' in term or '256' in colorterm:
        return '256fgbg'
    else:
        return 'nocolor'




INFO:root:----------------------------------------
INFO:root:max length: 2529
INFO:root:max position: 2529
INFO:root:target_namespace: gif-for-cli.gif_for_cli<folder>.utils<file>._get_default_display_mode<func>
INFO:root:****************************************
INFO:root:已生成143条结果
INFO:root:--------data 144--------

data 144:   0%|          | 0/512 [00:00<?, ?it/s]
data 144:   2%|▏         | 10/512 [00:05<04:53,  1.71it/s]
data 144:   4%|▍         | 20/512 [00:11<04:30,  1.82it/s]
data 144:   6%|▌         | 30/512 [00:16<04:20,  1.85it/s]
data 144:   8%|▊         | 40/512 [00:21<04:12,  1.87it/s]
data 144:   8%|▊         | 40/512 [00:25<04:58,  1.58it/s]
INFO:root:函数头: 
def _pool_type(val):

INFO:root:目标函数体: 
    if val is None:
        return val
    val = int(val)
    if val <= 0:
        raise argparse.ArgumentTypeError('Minimum cpu_pool_size is 1')
    return val

INFO:root:生成结果: 
    try:
        val = int(val)
    except ValueError:
        raise Exception('Invalid pool size')

    if val <= 0:
        raise Exception('Pool size must be greater than 0')

    return val




INFO:root:----------------------------------------
INFO:root:max length: 2547
INFO:root:max position: 2547
INFO:root:target_namespace: gif-for-cli.gif_for_cli<folder>.utils<file>._pool_type<func>
INFO:root:****************************************

data 144:   0%|          | 0/512 [00:00<?, ?it/s]
data 144:   2%|▏         | 10/512 [00:04<03:44,  2.23it/s]
data 144:   4%|▍         | 20/512 [00:09<04:00,  2.05it/s]
data 144:   6%|▌         | 30/512 [00:14<04:03,  1.98it/s]
data 144:   8%|▊         | 40/512 [00:20<04:03,  1.94it/s]
data 144:   8%|▊         | 40/512 [00:22<04:28,  1.76it/s]
INFO:root:函数头: 
def _pool_type(val):

INFO:root:目标函数体: 
    if val is None:
        return val
    val = int(val)
    if val <= 0:
        raise argparse.ArgumentTypeError('Minimum cpu_pool_size is 1')
    return val

INFO:root:生成结果: 
    try:
        val = int(val)
        if val <= 0:
            raise ValueError('Pool size must be greater than 0')
        return val
    except ValueError as e:
        raise e




INFO:root:----------------------------------------
INFO:root:max length: 2543
INFO:root:max position: 2543
INFO:root:target_namespace: gif-for-cli.gif_for_cli<folder>.utils<file>._pool_type<func>
INFO:root:****************************************

data 144:   0%|          | 0/512 [00:00<?, ?it/s]
data 144:   2%|▏         | 10/512 [00:04<03:52,  2.16it/s]
data 144:   4%|▍         | 20/512 [00:09<04:05,  2.01it/s]
data 144:   6%|▌         | 30/512 [00:15<04:06,  1.96it/s]
data 144:   8%|▊         | 40/512 [00:20<04:04,  1.93it/s]
data 144:   8%|▊         | 40/512 [00:22<04:30,  1.74it/s]
INFO:root:函数头: 
def _pool_type(val):

INFO:root:目标函数体: 
    if val is None:
        return val
    val = int(val)
    if val <= 0:
        raise argparse.ArgumentTypeError('Minimum cpu_pool_size is 1')
    return val

INFO:root:生成结果: 
    try:
        val = int(val)
        if val <= 0:
            raise Exception('Pool size must be greater than 0')
        return val
    except Exception as e:
        raise e




INFO:root:----------------------------------------
INFO:root:max length: 2543
INFO:root:max position: 2543
INFO:root:target_namespace: gif-for-cli.gif_for_cli<folder>.utils<file>._pool_type<func>
INFO:root:****************************************

data 144:   0%|          | 0/512 [00:00<?, ?it/s]
data 144:   2%|▏         | 10/512 [00:04<03:45,  2.23it/s]
data 144:   4%|▍         | 20/512 [00:09<04:01,  2.04it/s]
data 144:   6%|▌         | 30/512 [00:14<04:02,  1.99it/s]
data 144:   8%|▊         | 40/512 [00:20<03:59,  1.97it/s]
data 144:   8%|▊         | 40/512 [00:23<04:38,  1.70it/s]
INFO:root:函数头: 
def _pool_type(val):

INFO:root:目标函数体: 
    if val is None:
        return val
    val = int(val)
    if val <= 0:
        raise argparse.ArgumentTypeError('Minimum cpu_pool_size is 1')
    return val

INFO:root:生成结果: 
    try:
        val = int(val)
    except ValueError:
        raise Exception('Invalid pool type')

    if val <= 0:
        raise Exception('Pool type must be greater than 0')

    return val




INFO:root:----------------------------------------
INFO:root:max length: 2547
INFO:root:max position: 2547
INFO:root:target_namespace: gif-for-cli.gif_for_cli<folder>.utils<file>._pool_type<func>
INFO:root:****************************************

data 144:   0%|          | 0/512 [00:00<?, ?it/s]
data 144:   2%|▏         | 10/512 [00:04<03:52,  2.16it/s]
data 144:   4%|▍         | 20/512 [00:10<04:12,  1.95it/s]
data 144:   6%|▌         | 30/512 [00:15<04:16,  1.88it/s]
data 144:   8%|▊         | 40/512 [00:21<04:13,  1.86it/s]
data 144:  10%|▉         | 50/512 [00:26<04:06,  1.87it/s]
data 144:  10%|▉         | 50/512 [00:26<04:08,  1.86it/s]
INFO:root:函数头: 
def _pool_type(val):

INFO:root:目标函数体: 
    if val is None:
        return val
    val = int(val)
    if val <= 0:
        raise argparse.ArgumentTypeError('Minimum cpu_pool_size is 1')
    return val

INFO:root:生成结果: 
    try:
        val = int(val)
        if val <= 0:
            raise Exception('Pool size must be greater than 0.')
        return val
    except ValueError:
        raise Exception('Pool size must be a integer.')




INFO:root:----------------------------------------
INFO:root:max length: 2551
INFO:root:max position: 2551
INFO:root:target_namespace: gif-for-cli.gif_for_cli<folder>.utils<file>._pool_type<func>
INFO:root:****************************************
INFO:root:--------data 145--------

data 145:   0%|          | 0/512 [00:00<?, ?it/s]
data 145:   2%|▏         | 10/512 [00:04<03:29,  2.39it/s]
data 145:   4%|▍         | 20/512 [00:07<03:12,  2.55it/s]
data 145:   6%|▌         | 30/512 [00:11<03:06,  2.58it/s]
data 145:   8%|▊         | 40/512 [00:15<03:00,  2.61it/s]
data 145:  10%|▉         | 50/512 [00:19<02:55,  2.63it/s]
data 145:  12%|█▏        | 60/512 [00:23<02:52,  2.62it/s]
data 145:  14%|█▎        | 70/512 [00:26<02:48,  2.62it/s]
data 145:  16%|█▌        | 80/512 [00:30<02:41,  2.67it/s]
data 145:  18%|█▊        | 90/512 [00:34<02:35,  2.71it/s]
data 145:  20%|█▉        | 100/512 [00:37<02:30,  2.74it/s]
data 145:  21%|██▏       | 110/512 [00:41<02:26,  2.75it/s]
data 145:  23%|██▎       | 120/512 [00:44<02:21,  2.77it/s]
data 145:  25%|██▌       | 130/512 [00:48<02:15,  2.81it/s]
data 145:  27%|██▋       | 140/512 [00:51<02:11,  2.82it/s]
data 145:  29%|██▉       | 150/512 [00:55<02:09,  2.81it/s]
data 145:  31%|███▏      | 160/512 [00:59<02:06,  2.78it/s]
data 145:  33%|███▎      | 170/512 [01:02<02:04,  2.75it/s]
data 145:  35%|███▌      | 180/512 [01:06<02:01,  2.74it/s]
data 145:  37%|███▋      | 190/512 [01:10<01:57,  2.73it/s]
data 145:  39%|███▉      | 200/512 [01:13<01:54,  2.72it/s]
data 145:  39%|███▉      | 200/512 [01:14<01:55,  2.69it/s]
INFO:root:函数头: 
def get_avg_for_em(px, x, y, cell_height, cell_width):

INFO:root:目标函数体: 
    pixels = [
        px[sx, sy]
        for sy in range(y, y + cell_height)
        for sx in range(x, x + cell_width)
    ]
    return [round(n) for n in map(mean, zip(*pixels))]

INFO:root:生成结果: 
    avg = [0] * 3  # Initialize average as [0, 0, 0] for RGB values
    pixel_count = cell_height * cell_width  # Calculate total number of pixels in the area
    for i in range(cell_height):
        for j in range(cell_width):
            avg[0] += px[y+i][x+j][0]  # Add red component of pixel to average
            avg[1] += px[y+i][x+j][1]  # Add green component of pixel to average
            avg[2] += px[y+i][x+j][2]  # Add blue component of pixel to average
    avg[0] /= pixel_count  # Divide average red component by total pixel count
    avg[1] /= pixel_count  # Divide average green component by total pixel count
    avg[2] /= pixel_count  # Divide average blue component by total pixel count
    return avg




INFO:root:----------------------------------------
INFO:root:max length: 1960
INFO:root:max position: 1960
INFO:root:target_namespace: gif-for-cli.gif_for_cli<folder>.generate<folder>.utils<file>.get_avg_for_em<func>
INFO:root:****************************************

data 145:   0%|          | 0/512 [00:00<?, ?it/s]
data 145:   2%|▏         | 10/512 [00:03<02:49,  2.97it/s]
data 145:   4%|▍         | 20/512 [00:06<02:49,  2.90it/s]
data 145:   6%|▌         | 30/512 [00:10<02:53,  2.78it/s]
data 145:   8%|▊         | 40/512 [00:14<02:50,  2.77it/s]
data 145:  10%|▉         | 50/512 [00:17<02:46,  2.78it/s]
data 145:  12%|█▏        | 60/512 [00:21<02:43,  2.76it/s]
data 145:  14%|█▎        | 70/512 [00:25<02:40,  2.75it/s]
data 145:  16%|█▌        | 80/512 [00:28<02:36,  2.76it/s]
data 145:  18%|█▊        | 90/512 [00:32<02:30,  2.80it/s]
data 145:  20%|█▉        | 100/512 [00:35<02:26,  2.81it/s]
data 145:  21%|██▏       | 110/512 [00:39<02:22,  2.81it/s]
data 145:  23%|██▎       | 120/512 [00:42<02:18,  2.82it/s]
data 145:  25%|██▌       | 130/512 [00:46<02:15,  2.81it/s]
data 145:  27%|██▋       | 140/512 [00:49<02:12,  2.81it/s]
data 145:  29%|██▉       | 150/512 [00:53<02:09,  2.79it/s]
data 145:  31%|███▏      | 160/512 [00:57<02:06,  2.78it/s]
data 145:  31%|███▏      | 160/512 [00:57<02:07,  2.76it/s]
INFO:root:函数头: 
def get_avg_for_em(px, x, y, cell_height, cell_width):

INFO:root:目标函数体: 
    pixels = [
        px[sx, sy]
        for sy in range(y, y + cell_height)
        for sx in range(x, x + cell_width)
    ]
    return [round(n) for n in map(mean, zip(*pixels))]

INFO:root:生成结果: 
    avg = [0] * 3  # Initialize average list with zeros
    for i in range(cell_height):
        for j in range(cell_width):
            avg[0] += px[y + i][x + j][0]  # Red
            avg[1] += px[y + i][x + j][1]  # Green
            avg[2] += px[y + i][x + j][2]  # Blue
    avg[0] /= cell_height * cell_width  # Divide by total number of pixels
    avg[1] /= cell_height * cell_width  # Divide by total number of pixels
    avg[2] /= cell_height * cell_width  # Divide by total number of pixels
    return avg


INFO:root:----------------------------------------
INFO:root:max length: 1936
INFO:root:max position: 1936
INFO:root:target_namespace: gif-for-cli.gif_for_cli<folder>.generate<folder>.utils<file>.get_avg_for_em<func>
INFO:root:****************************************

data 145:   0%|          | 0/512 [00:00<?, ?it/s]
data 145:   2%|▏         | 10/512 [00:03<02:51,  2.92it/s]
data 145:   4%|▍         | 20/512 [00:07<02:54,  2.82it/s]
data 145:   6%|▌         | 30/512 [00:10<02:55,  2.74it/s]
data 145:   8%|▊         | 40/512 [00:14<02:54,  2.71it/s]
data 145:  10%|▉         | 50/512 [00:18<02:51,  2.69it/s]
data 145:  12%|█▏        | 60/512 [00:22<02:50,  2.65it/s]
data 145:  14%|█▎        | 70/512 [00:25<02:44,  2.68it/s]
data 145:  16%|█▌        | 80/512 [00:29<02:39,  2.71it/s]
data 145:  18%|█▊        | 90/512 [00:33<02:33,  2.75it/s]
data 145:  20%|█▉        | 100/512 [00:36<02:28,  2.78it/s]
data 145:  21%|██▏       | 110/512 [00:40<02:23,  2.79it/s]
data 145:  23%|██▎       | 120/512 [00:43<02:19,  2.80it/s]
data 145:  25%|██▌       | 130/512 [00:47<02:15,  2.82it/s]
data 145:  27%|██▋       | 140/512 [00:50<02:11,  2.82it/s]
data 145:  29%|██▉       | 150/512 [00:54<02:09,  2.80it/s]
data 145:  31%|███▏      | 160/512 [00:57<02:05,  2.80it/s]
data 145:  33%|███▎      | 170/512 [01:01<02:03,  2.78it/s]
data 145:  33%|███▎      | 170/512 [01:04<02:10,  2.62it/s]
INFO:root:函数头: 
def get_avg_for_em(px, x, y, cell_height, cell_width):

INFO:root:目标函数体: 
    pixels = [
        px[sx, sy]
        for sy in range(y, y + cell_height)
        for sx in range(x, x + cell_width)
    ]
    return [round(n) for n in map(mean, zip(*pixels))]

INFO:root:生成结果: 
    avg = [0] * 3  # Initialize average list with zeros
    pixel_count = cell_height * cell_width  # Calculate total number of pixels in the area

    for i in range(cell_height):
        for j in range(cell_width):
            avg[0] += px[y + i][x + j][0]  # Sum red channel values
            avg[1] += px[y + i][x + j][1]  # Sum green channel values
            avg[2] += px[y + i][x + j][2]  # Sum blue channel values

    avg[0] //= pixel_count  # Calculate average red channel value
    avg[1] //= pixel_count  # Calculate average green channel value
    avg[2] //= pixel_count  # Calculate average blue channel value

    return avg


INFO:root:----------------------------------------
INFO:root:max length: 1961
INFO:root:max position: 1961
INFO:root:target_namespace: gif-for-cli.gif_for_cli<folder>.generate<folder>.utils<file>.get_avg_for_em<func>
INFO:root:****************************************

data 145:   0%|          | 0/512 [00:00<?, ?it/s]
data 145:   2%|▏         | 10/512 [00:03<02:47,  2.99it/s]
data 145:   4%|▍         | 20/512 [00:06<02:53,  2.84it/s]
data 145:   6%|▌         | 30/512 [00:10<02:53,  2.77it/s]
data 145:   8%|▊         | 40/512 [00:14<02:52,  2.74it/s]
data 145:  10%|▉         | 50/512 [00:18<02:49,  2.73it/s]
data 145:  12%|█▏        | 60/512 [00:22<02:50,  2.65it/s]
data 145:  14%|█▎        | 70/512 [00:25<02:45,  2.66it/s]
data 145:  16%|█▌        | 80/512 [00:29<02:41,  2.68it/s]
data 145:  18%|█▊        | 90/512 [00:32<02:33,  2.75it/s]
data 145:  20%|█▉        | 100/512 [00:36<02:27,  2.79it/s]
data 145:  21%|██▏       | 110/512 [00:39<02:23,  2.79it/s]
data 145:  23%|██▎       | 120/512 [00:43<02:19,  2.81it/s]
data 145:  25%|██▌       | 130/512 [00:47<02:15,  2.81it/s]
data 145:  27%|██▋       | 140/512 [00:50<02:11,  2.82it/s]
data 145:  29%|██▉       | 150/512 [00:54<02:09,  2.79it/s]
data 145:  31%|███▏      | 160/512 [00:57<02:06,  2.78it/s]
data 145:  31%|███▏      | 160/512 [00:59<02:11,  2.68it/s]
INFO:root:函数头: 
def get_avg_for_em(px, x, y, cell_height, cell_width):

INFO:root:目标函数体: 
    pixels = [
        px[sx, sy]
        for sy in range(y, y + cell_height)
        for sx in range(x, x + cell_width)
    ]
    return [round(n) for n in map(mean, zip(*pixels))]

INFO:root:生成结果: 
    avg = [0] * 3  # Initialize average list with zeros
    pixel_count = cell_height * cell_width  # Calculate total number of pixels in the area
    for i in range(cell_height):
        for j in range(cell_width):
            pixel_index = (y + i) * px.shape[1] + x + j  # Calculate pixel index
            avg[0] += px[pixel_index][0]  # Sum red channel
            avg[1] += px[pixel_index][1]  # Sum green channel
            avg[2] += px[pixel_index][2]  # Sum blue channel
    avg = [int(avg[i] / pixel_count) for i in range(3)]  # Calculate average
    return avg


INFO:root:----------------------------------------
INFO:root:max length: 1936
INFO:root:max position: 1936
INFO:root:target_namespace: gif-for-cli.gif_for_cli<folder>.generate<folder>.utils<file>.get_avg_for_em<func>
INFO:root:****************************************

data 145:   0%|          | 0/512 [00:00<?, ?it/s]
data 145:   2%|▏         | 10/512 [00:03<02:48,  2.97it/s]
data 145:   4%|▍         | 20/512 [00:07<02:54,  2.81it/s]
data 145:   6%|▌         | 30/512 [00:10<02:54,  2.76it/s]
data 145:   8%|▊         | 40/512 [00:14<02:52,  2.73it/s]
data 145:  10%|▉         | 50/512 [00:18<02:49,  2.73it/s]
data 145:  12%|█▏        | 60/512 [00:22<02:50,  2.65it/s]
data 145:  14%|█▎        | 70/512 [00:25<02:44,  2.68it/s]
data 145:  16%|█▌        | 80/512 [00:29<02:39,  2.72it/s]
data 145:  18%|█▊        | 90/512 [00:32<02:32,  2.77it/s]
data 145:  20%|█▉        | 100/512 [00:36<02:27,  2.79it/s]
data 145:  21%|██▏       | 110/512 [00:39<02:23,  2.81it/s]
data 145:  23%|██▎       | 120/512 [00:43<02:18,  2.82it/s]
data 145:  25%|██▌       | 130/512 [00:46<02:15,  2.83it/s]
data 145:  27%|██▋       | 140/512 [00:50<02:11,  2.83it/s]
data 145:  29%|██▉       | 150/512 [00:53<02:08,  2.82it/s]
data 145:  31%|███▏      | 160/512 [00:57<02:06,  2.79it/s]
data 145:  33%|███▎      | 170/512 [01:01<02:02,  2.78it/s]
data 145:  33%|███▎      | 170/512 [01:04<02:09,  2.63it/s]
INFO:root:函数头: 
def get_avg_for_em(px, x, y, cell_height, cell_width):

INFO:root:目标函数体: 
    pixels = [
        px[sx, sy]
        for sy in range(y, y + cell_height)
        for sx in range(x, x + cell_width)
    ]
    return [round(n) for n in map(mean, zip(*pixels))]

INFO:root:生成结果: 
    avg = [0] * 3  # Initialize average list with zeros
    pixel_count = cell_height * cell_width  # Calculate total number of pixels in the area
    for i in range(cell_height):
        for j in range(cell_width):
            avg[0] += px[x + i][y + j][0]  # Sum red channel values
            avg[1] += px[x + i][y + j][1]  # Sum green channel values
            avg[2] += px[x + i][y + j][2]  # Sum blue channel values
    avg[0] //= pixel_count  # Calculate average red channel value
    avg[1] //= pixel_count  # Calculate average green channel value
    avg[2] //= pixel_count  # Calculate average blue channel value
    return avg




INFO:root:----------------------------------------
INFO:root:max length: 1961
INFO:root:max position: 1961
INFO:root:target_namespace: gif-for-cli.gif_for_cli<folder>.generate<folder>.utils<file>.get_avg_for_em<func>
INFO:root:****************************************
INFO:root:--------data 146--------

data 146:   0%|          | 0/512 [00:00<?, ?it/s]
data 146:   2%|▏         | 10/512 [00:04<03:53,  2.15it/s]
data 146:   4%|▍         | 20/512 [00:08<03:18,  2.47it/s]
data 146:   6%|▌         | 30/512 [00:11<03:07,  2.58it/s]
data 146:   8%|▊         | 40/512 [00:15<02:58,  2.64it/s]
data 146:  10%|▉         | 50/512 [00:19<02:54,  2.64it/s]
data 146:  12%|█▏        | 60/512 [00:23<02:50,  2.65it/s]
data 146:  14%|█▎        | 70/512 [00:26<02:47,  2.64it/s]
data 146:  16%|█▌        | 80/512 [00:30<02:44,  2.63it/s]
data 146:  18%|█▊        | 90/512 [00:34<02:42,  2.60it/s]
data 146:  20%|█▉        | 100/512 [00:38<02:37,  2.61it/s]
data 146:  21%|██▏       | 110/512 [00:42<02:34,  2.59it/s]
data 146:  23%|██▎       | 120/512 [00:46<02:31,  2.58it/s]
data 146:  25%|██▌       | 130/512 [00:50<02:28,  2.58it/s]
data 146:  27%|██▋       | 140/512 [00:54<02:24,  2.57it/s]
data 146:  29%|██▉       | 150/512 [00:58<02:20,  2.57it/s]
data 146:  31%|███▏      | 160/512 [01:02<02:18,  2.54it/s]
data 146:  33%|███▎      | 170/512 [01:05<02:14,  2.55it/s]
data 146:  35%|███▌      | 180/512 [01:09<02:10,  2.54it/s]
data 146:  35%|███▌      | 180/512 [01:11<02:12,  2.51it/s]
INFO:root:函数头: 
def process_input_source(input_source, api_key):

INFO:root:目标函数体: 
    if input_source.strip().startswith('https://tenor.com/view/'):
        gif_id = input_source.rsplit('-', 1)[-1]
        if gif_id.isdigit():
            input_source = gif_id
        else:
            raise Exception('Bad GIF URL.')

    is_url = input_source.startswith(('http://', 'https://'))

    if not os.path.exists(input_source) and not is_url:
        # get from Tenor GIF API
        params = {'key': api_key}
        if input_source.isdigit():
            endpoint = 'gifs'
            params.update({'ids': input_source})
        elif input_source == '':
            endpoint = 'trending'
            params.update({'limit': 1})
        else:
            endpoint = 'search'
            params.update({'limit': 1, 'q': input_source})

        resp = requests.get(
            'https://api.tenor.com/v1/{}'.format(endpoint),
            params=params
        )

        try:
            resp_json = resp.json()
        except JSONDecodeError:
            raise Exception('A server error occurred.')

        if 'error' in resp_json:
            raise Exception('An error occurred: {}'.format(resp_json['error']))

        results = resp_json.get('results')

        if not results:
            raise Exception('Could not find GIF.')

        input_source = results[0]['media'][0]['mp4']['url']
    return input_source

INFO:root:生成结果: 
    if input_source.startswith("https://tenor.com/view/"):
        # If the input source is a Tenor GIF URL, extract the GIF ID and use it to get the GIF URL.
        gif_id = input_source.split("/")[-1]
        return f"https://tenor.com/g.gif?id={gif_id}"
    else:
        # If the input source is not a URL, send a request to the Tenor GIF API to get the GIF URL based on the input source.
        response = requests.get(
            f"https://api.tenor.com/v1/search?q={input_source}&key={api_key}&limit=1"
        )
        try:
            data = response.json()
            gif_url = data["results"][0]["media"][0]["gif"]["url"]
            return gif_url
        except JSONDecodeError:
            raise ValueError("Invalid response from Tenor API")




INFO:root:----------------------------------------
INFO:root:max length: 2076
INFO:root:max position: 2076
INFO:root:target_namespace: gif-for-cli.gif_for_cli<folder>.generate<folder>.utils<file>.process_input_source<func>
INFO:root:****************************************

data 146:   0%|          | 0/512 [00:00<?, ?it/s]
data 146:   2%|▏         | 10/512 [00:03<03:05,  2.71it/s]
data 146:   4%|▍         | 20/512 [00:07<03:03,  2.68it/s]
data 146:   6%|▌         | 30/512 [00:11<02:59,  2.69it/s]
data 146:   8%|▊         | 40/512 [00:14<02:55,  2.68it/s]
data 146:  10%|▉         | 50/512 [00:18<02:53,  2.66it/s]
data 146:  12%|█▏        | 60/512 [00:22<02:50,  2.65it/s]
data 146:  14%|█▎        | 70/512 [00:26<02:48,  2.63it/s]
data 146:  16%|█▌        | 80/512 [00:30<02:45,  2.61it/s]
data 146:  18%|█▊        | 90/512 [00:34<02:41,  2.61it/s]
data 146:  20%|█▉        | 100/512 [00:38<02:39,  2.59it/s]
data 146:  21%|██▏       | 110/512 [00:41<02:36,  2.57it/s]
data 146:  23%|██▎       | 120/512 [00:45<02:33,  2.55it/s]
data 146:  25%|██▌       | 130/512 [00:49<02:30,  2.54it/s]
data 146:  27%|██▋       | 140/512 [00:53<02:26,  2.54it/s]
data 146:  29%|██▉       | 150/512 [00:57<02:22,  2.54it/s]
data 146:  31%|███▏      | 160/512 [01:01<02:21,  2.50it/s]
data 146:  33%|███▎      | 170/512 [01:06<02:17,  2.48it/s]
data 146:  35%|███▌      | 180/512 [01:10<02:14,  2.47it/s]
data 146:  37%|███▋      | 190/512 [01:14<02:09,  2.48it/s]
data 146:  39%|███▉      | 200/512 [01:18<02:05,  2.49it/s]
data 146:  39%|███▉      | 200/512 [01:21<02:07,  2.45it/s]
INFO:root:函数头: 
def process_input_source(input_source, api_key):

INFO:root:目标函数体: 
    if input_source.strip().startswith('https://tenor.com/view/'):
        gif_id = input_source.rsplit('-', 1)[-1]
        if gif_id.isdigit():
            input_source = gif_id
        else:
            raise Exception('Bad GIF URL.')

    is_url = input_source.startswith(('http://', 'https://'))

    if not os.path.exists(input_source) and not is_url:
        # get from Tenor GIF API
        params = {'key': api_key}
        if input_source.isdigit():
            endpoint = 'gifs'
            params.update({'ids': input_source})
        elif input_source == '':
            endpoint = 'trending'
            params.update({'limit': 1})
        else:
            endpoint = 'search'
            params.update({'limit': 1, 'q': input_source})

        resp = requests.get(
            'https://api.tenor.com/v1/{}'.format(endpoint),
            params=params
        )

        try:
            resp_json = resp.json()
        except JSONDecodeError:
            raise Exception('A server error occurred.')

        if 'error' in resp_json:
            raise Exception('An error occurred: {}'.format(resp_json['error']))

        results = resp_json.get('results')

        if not results:
            raise Exception('Could not find GIF.')

        input_source = results[0]['media'][0]['mp4']['url']
    return input_source

INFO:root:生成结果: 
    if input_source.startswith("https://tenor.com/view/"):
        # If the input source is a Tenor GIF URL, extract the GIF ID and use it to get the GIF URL.
        gif_id = input_source.split('/')[-1]
        url = f"https://tenor.com/gifview/{gif_id}"
    else:
        # If the input source is not a URL, send a request to the Tenor GIF API to get the GIF URL based on the input source.
        try:
            response = requests.get(
                f"https://api.tenor.com/v1/search?q={input_source}&key={api_key}&limit=1"
            )
            response.raise_for_status()
            gif_url = response.json()['results'][0]['media'][0]['gif']['url']
        except JSONDecodeError:
            raise ValueError("Invalid JSON response from Tenor API")
        except requests.RequestException as e:
            raise ValueError(f"Error fetching GIF from Tenor API: {e}")

    return gif_url


INFO:root:----------------------------------------
INFO:root:max length: 2100
INFO:root:max position: 2100
INFO:root:target_namespace: gif-for-cli.gif_for_cli<folder>.generate<folder>.utils<file>.process_input_source<func>
INFO:root:****************************************

data 146:   0%|          | 0/512 [00:00<?, ?it/s]
data 146:   2%|▏         | 10/512 [00:03<03:06,  2.68it/s]
data 146:   4%|▍         | 20/512 [00:07<03:04,  2.67it/s]
data 146:   6%|▌         | 30/512 [00:11<03:02,  2.64it/s]
data 146:   8%|▊         | 40/512 [00:15<02:59,  2.63it/s]
data 146:  10%|▉         | 50/512 [00:19<02:57,  2.60it/s]
data 146:  12%|█▏        | 60/512 [00:22<02:53,  2.60it/s]
data 146:  14%|█▎        | 70/512 [00:26<02:51,  2.58it/s]
data 146:  16%|█▌        | 80/512 [00:30<02:47,  2.58it/s]
data 146:  18%|█▊        | 90/512 [00:34<02:44,  2.56it/s]
data 146:  20%|█▉        | 100/512 [00:38<02:40,  2.57it/s]
data 146:  21%|██▏       | 110/512 [00:42<02:35,  2.58it/s]
data 146:  23%|██▎       | 120/512 [00:46<02:32,  2.57it/s]
data 146:  25%|██▌       | 130/512 [00:50<02:28,  2.58it/s]
data 146:  27%|██▋       | 140/512 [00:54<02:24,  2.58it/s]
data 146:  29%|██▉       | 150/512 [00:57<02:20,  2.57it/s]
data 146:  31%|███▏      | 160/512 [01:02<02:18,  2.54it/s]
data 146:  33%|███▎      | 170/512 [01:06<02:15,  2.52it/s]
data 146:  35%|███▌      | 180/512 [01:10<02:12,  2.51it/s]
data 146:  35%|███▌      | 180/512 [03:12<05:55,  1.07s/it]
INFO:root:函数头: 
def process_input_source(input_source, api_key):

INFO:root:目标函数体: 
    if input_source.strip().startswith('https://tenor.com/view/'):
        gif_id = input_source.rsplit('-', 1)[-1]
        if gif_id.isdigit():
            input_source = gif_id
        else:
            raise Exception('Bad GIF URL.')

    is_url = input_source.startswith(('http://', 'https://'))

    if not os.path.exists(input_source) and not is_url:
        # get from Tenor GIF API
        params = {'key': api_key}
        if input_source.isdigit():
            endpoint = 'gifs'
            params.update({'ids': input_source})
        elif input_source == '':
            endpoint = 'trending'
            params.update({'limit': 1})
        else:
            endpoint = 'search'
            params.update({'limit': 1, 'q': input_source})

        resp = requests.get(
            'https://api.tenor.com/v1/{}'.format(endpoint),
            params=params
        )

        try:
            resp_json = resp.json()
        except JSONDecodeError:
            raise Exception('A server error occurred.')

        if 'error' in resp_json:
            raise Exception('An error occurred: {}'.format(resp_json['error']))

        results = resp_json.get('results')

        if not results:
            raise Exception('Could not find GIF.')

        input_source = results[0]['media'][0]['mp4']['url']
    return input_source

INFO:root:生成结果: 
    if input_source.startswith("https://tenor.com/view/"):
        # If the input source is a Tenor GIF URL, extract the GIF ID and use it to get the GIF URL.
        gif_id = input_source.split("/")[-1]
        return f"https://tenor.com/gifview/{gif_id}"
    else:
        # If the input source is not a URL, send a request to the Tenor GIF API to get the GIF URL based on the input source.
        response = requests.get(
            f"https://api.tenor.com/v1/search?q={input_source}&key={api_key}&limit=1"
        )
        try:
            data = response.json()
            gif_url = data['results'][0]['media'][0]['gif']['url']
            return gif_url
        except JSONDecodeError:
            raise Exception("Failed to decode JSON response from Tenor API")




INFO:root:----------------------------------------
INFO:root:max length: 2077
INFO:root:max position: 2077
INFO:root:target_namespace: gif-for-cli.gif_for_cli<folder>.generate<folder>.utils<file>.process_input_source<func>
INFO:root:****************************************

data 146:   0%|          | 0/512 [00:00<?, ?it/s]
data 146:   2%|▏         | 10/512 [00:03<03:04,  2.73it/s]
data 146:   4%|▍         | 20/512 [00:07<03:02,  2.70it/s]
data 146:   6%|▌         | 30/512 [00:11<02:59,  2.68it/s]
data 146:   8%|▊         | 40/512 [00:14<02:54,  2.70it/s]
data 146:  10%|▉         | 50/512 [00:18<02:52,  2.67it/s]
data 146:  12%|█▏        | 60/512 [00:22<02:49,  2.67it/s]
data 146:  14%|█▎        | 70/512 [00:26<02:45,  2.67it/s]
data 146:  16%|█▌        | 80/512 [00:29<02:40,  2.69it/s]
data 146:  18%|█▊        | 90/512 [00:33<02:36,  2.69it/s]
data 146:  20%|█▉        | 100/512 [00:37<02:33,  2.69it/s]
data 146:  21%|██▏       | 110/512 [00:40<02:28,  2.71it/s]
data 146:  23%|██▎       | 120/512 [00:44<02:25,  2.69it/s]
data 146:  25%|██▌       | 130/512 [00:48<02:23,  2.66it/s]
data 146:  27%|██▋       | 140/512 [00:52<02:20,  2.64it/s]
data 146:  29%|██▉       | 150/512 [00:56<02:18,  2.62it/s]
data 146:  31%|███▏      | 160/512 [01:00<02:15,  2.60it/s]
data 146:  33%|███▎      | 170/512 [01:04<02:12,  2.57it/s]
data 146:  35%|███▌      | 180/512 [01:08<02:09,  2.57it/s]
data 146:  37%|███▋      | 190/512 [01:11<02:05,  2.56it/s]
data 146:  39%|███▉      | 200/512 [01:15<02:01,  2.57it/s]
data 146:  41%|████      | 210/512 [01:19<01:57,  2.56it/s]
data 146:  41%|████      | 210/512 [01:22<01:58,  2.55it/s]
INFO:root:函数头: 
def process_input_source(input_source, api_key):

INFO:root:目标函数体: 
    if input_source.strip().startswith('https://tenor.com/view/'):
        gif_id = input_source.rsplit('-', 1)[-1]
        if gif_id.isdigit():
            input_source = gif_id
        else:
            raise Exception('Bad GIF URL.')

    is_url = input_source.startswith(('http://', 'https://'))

    if not os.path.exists(input_source) and not is_url:
        # get from Tenor GIF API
        params = {'key': api_key}
        if input_source.isdigit():
            endpoint = 'gifs'
            params.update({'ids': input_source})
        elif input_source == '':
            endpoint = 'trending'
            params.update({'limit': 1})
        else:
            endpoint = 'search'
            params.update({'limit': 1, 'q': input_source})

        resp = requests.get(
            'https://api.tenor.com/v1/{}'.format(endpoint),
            params=params
        )

        try:
            resp_json = resp.json()
        except JSONDecodeError:
            raise Exception('A server error occurred.')

        if 'error' in resp_json:
            raise Exception('An error occurred: {}'.format(resp_json['error']))

        results = resp_json.get('results')

        if not results:
            raise Exception('Could not find GIF.')

        input_source = results[0]['media'][0]['mp4']['url']
    return input_source

INFO:root:生成结果: 
    if input_source.startswith("https://tenor.com/view/"):
        # If the input source is a Tenor GIF URL, extract the GIF ID and use it to get the GIF URL.
        gif_id = input_source.split('/')[-1]
        return f"https://tenor.com/view/{gif_id}-animated.gif"
    else:
        # If the input source is not a URL, send a request to the Tenor GIF API to get the GIF URL based on the input source.
        response = requests.get(
            f"https://api.tenor.com/v2/search?q={input_source}&key={api_key}&limit=1"
        )
        try:
            response.raise_for_status()
            data = response.json()
            gif_url = data['results'][0]['media'][0]['gif']['url']
            return gif_url
        except JSONDecodeError:
            raise Exception("Failed to decode JSON response from Tenor API")
        except Exception as e:
            raise Exception(f"Failed to get GIF URL from Tenor API: {e}")


INFO:root:----------------------------------------
INFO:root:max length: 2108
INFO:root:max position: 2108
INFO:root:target_namespace: gif-for-cli.gif_for_cli<folder>.generate<folder>.utils<file>.process_input_source<func>
INFO:root:****************************************

data 146:   0%|          | 0/512 [00:00<?, ?it/s]
data 146:   2%|▏         | 10/512 [01:03<53:26,  6.39s/it]
data 146:   4%|▍         | 20/512 [01:07<23:21,  2.85s/it]
data 146:   6%|▌         | 30/512 [01:11<13:50,  1.72s/it]
data 146:   8%|▊         | 40/512 [01:15<09:23,  1.19s/it]
data 146:  10%|▉         | 50/512 [01:19<06:57,  1.11it/s]
data 146:  12%|█▏        | 60/512 [01:23<05:29,  1.37it/s]
data 146:  14%|█▎        | 70/512 [01:27<04:34,  1.61it/s]
data 146:  16%|█▌        | 80/512 [01:30<03:55,  1.83it/s]
data 146:  18%|█▊        | 90/512 [01:34<03:30,  2.00it/s]
data 146:  20%|█▉        | 100/512 [02:38<15:57,  2.32s/it]
data 146:  21%|██▏       | 110/512 [02:43<11:38,  1.74s/it]
data 146:  23%|██▎       | 120/512 [02:47<08:41,  1.33s/it]
data 146:  25%|██▌       | 130/512 [03:51<18:15,  2.87s/it]
data 146:  27%|██▋       | 140/512 [03:55<13:10,  2.12s/it]
data 146:  29%|██▉       | 150/512 [03:59<09:40,  1.60s/it]
data 146:  31%|███▏      | 160/512 [04:03<07:17,  1.24s/it]
data 146:  33%|███▎      | 170/512 [04:07<05:39,  1.01it/s]
data 146:  35%|███▌      | 180/512 [04:11<04:29,  1.23it/s]
data 146:  37%|███▋      | 190/512 [04:15<03:42,  1.45it/s]
data 146:  39%|███▉      | 200/512 [04:19<03:08,  1.66it/s]
data 146:  41%|████      | 210/512 [04:23<02:43,  1.84it/s]
data 146:  43%|████▎     | 220/512 [04:27<02:26,  2.00it/s]
data 146:  43%|████▎     | 220/512 [04:28<05:56,  1.22s/it]
INFO:root:函数头: 
def process_input_source(input_source, api_key):

INFO:root:目标函数体: 
    if input_source.strip().startswith('https://tenor.com/view/'):
        gif_id = input_source.rsplit('-', 1)[-1]
        if gif_id.isdigit():
            input_source = gif_id
        else:
            raise Exception('Bad GIF URL.')

    is_url = input_source.startswith(('http://', 'https://'))

    if not os.path.exists(input_source) and not is_url:
        # get from Tenor GIF API
        params = {'key': api_key}
        if input_source.isdigit():
            endpoint = 'gifs'
            params.update({'ids': input_source})
        elif input_source == '':
            endpoint = 'trending'
            params.update({'limit': 1})
        else:
            endpoint = 'search'
            params.update({'limit': 1, 'q': input_source})

        resp = requests.get(
            'https://api.tenor.com/v1/{}'.format(endpoint),
            params=params
        )

        try:
            resp_json = resp.json()
        except JSONDecodeError:
            raise Exception('A server error occurred.')

        if 'error' in resp_json:
            raise Exception('An error occurred: {}'.format(resp_json['error']))

        results = resp_json.get('results')

        if not results:
            raise Exception('Could not find GIF.')

        input_source = results[0]['media'][0]['mp4']['url']
    return input_source

INFO:root:生成结果: 
    if input_source.startswith("https://tenor.com/view/"):
        # If the input source is a Tenor GIF URL, extract the GIF ID and use it to get the GIF URL.
        gif_id = input_source.split('/')[-1]
        url = f"https://tenor.com/gifview/{gif_id}"
    else:
        # If the input source is not a URL, send a request to the Tenor GIF API to get the GIF URL based on the input source.
        try:
            response = requests.get(
                f"https://api.tenor.com/v1/search?q={input_source}&key={api_key}&limit=1&locale=en&archived=False&gif_type= animated"
            )
            response.raise_for_status()
            data = response.json()
            url = data['results'][0]['media'][0]['gif']['url']
        except JSONDecodeError:
            raise Exception("Invalid JSON response from Tenor API")
        except requests.exceptions.RequestException as e:
            raise Exception(f"Error accessing Tenor API: {e}")
    return url


INFO:root:----------------------------------------
INFO:root:max length: 2115
INFO:root:max position: 2115
INFO:root:target_namespace: gif-for-cli.gif_for_cli<folder>.generate<folder>.utils<file>.process_input_source<func>
INFO:root:****************************************
INFO:root:--------data 147--------

data 147:   0%|          | 0/512 [00:00<?, ?it/s]
data 147:   2%|▏         | 10/512 [03:45<3:09:01, 22.59s/it]
data 147:   4%|▍         | 20/512 [04:34<1:39:48, 12.17s/it]
data 147:   6%|▌         | 30/512 [06:21<1:32:15, 11.49s/it]
data 147:   8%|▊         | 40/512 [07:07<1:09:02,  8.78s/it]
data 147:  10%|▉         | 50/512 [15:56<3:10:00, 24.68s/it]
data 147:  12%|█▏        | 60/512 [16:46<2:15:32, 17.99s/it]
data 147:  14%|█▎        | 70/512 [17:31<1:40:09, 13.60s/it]
data 147:  16%|█▌        | 80/512 [18:20<1:17:51, 10.81s/it]
data 147:  18%|█▊        | 90/512 [19:10<1:03:13,  8.99s/it]
data 147:  20%|█▉        | 100/512 [20:59<1:05:45,  9.58s/it]
data 147:  21%|██▏       | 110/512 [21:48<54:43,  8.17s/it]  
data 147:  23%|██▎       | 120/512 [22:36<46:30,  7.12s/it]
data 147:  25%|██▌       | 130/512 [23:23<40:40,  6.39s/it]
data 147:  27%|██▋       | 140/512 [24:10<36:32,  5.89s/it]
data 147:  29%|██▉       | 150/512 [29:01<1:17:44, 12.89s/it]
data 147:  31%|███▏      | 160/512 [29:52<1:01:45, 10.53s/it]
data 147:  31%|███▏      | 160/512 [30:01<1:06:02, 11.26s/it]
INFO:root:函数头: 
def reshape_data(x, hue, labels):

INFO:root:目标函数体: 
    categories = list(sorted(set(hue), key=list(hue).index))
    x_stacked = np.vstack(x)
    x_reshaped = [[] for _ in categories]
    labels_reshaped = [[] for _ in categories]
    if labels is None:
        labels = [None]*len(hue)
    for idx, (point, label) in enumerate(zip(hue, labels)):
        x_reshaped[categories.index(point)].append(x_stacked[idx])
        labels_reshaped[categories.index(point)].append(labels[idx])
    return [np.vstack(i) for i in x_reshaped], labels_reshaped

INFO:root:生成结果: 
    # Flatten the input data if it's a list of lists
    if isinstance(x[0], list):
        x = list(itertools.chain.from_iterable(x))
    # Get unique categories in the hue
    unique_hues = np.unique(hue)
    # Initialize lists to store reshaped data and labels
    reshaped_data = []
    reshaped_labels = []
    # Loop through unique categories and reshape data and labels
    for hue_val in unique_hues:
        # Get indices of rows with current hue value
        idx = np.where(hue == hue_val)[0]
        # Append reshaped data and labels to lists
        reshaped_data.append(x[idx])
        reshaped_labels.append(labels[idx])
    return reshaped_data, reshaped_labels




INFO:root:----------------------------------------
INFO:root:max length: 8283
INFO:root:max position: 11203
INFO:root:target_namespace: hypertools.hypertools<folder>._shared<folder>.helpers<file>.reshape_data<func>
INFO:root:****************************************

data 147:   0%|          | 0/512 [00:00<?, ?it/s]
data 147:   2%|▏         | 10/512 [00:43<36:17,  4.34s/it]
data 147:   4%|▍         | 20/512 [01:32<38:28,  4.69s/it]
data 147:   6%|▌         | 30/512 [02:20<38:05,  4.74s/it]
data 147:   8%|▊         | 40/512 [07:08<1:51:54, 14.22s/it]
data 147:  10%|▉         | 50/512 [08:54<1:39:29, 12.92s/it]
data 147:  12%|█▏        | 60/512 [09:44<1:16:58, 10.22s/it]
data 147:  14%|█▎        | 70/512 [10:29<1:01:33,  8.36s/it]
data 147:  16%|█▌        | 80/512 [11:17<52:03,  7.23s/it]  
data 147:  18%|█▊        | 90/512 [14:05<1:11:57, 10.23s/it]
data 147:  20%|█▉        | 100/512 [19:56<2:02:49, 17.89s/it]
data 147:  21%|██▏       | 110/512 [26:45<2:47:08, 24.95s/it]
data 147:  23%|██▎       | 120/512 [27:32<2:02:45, 18.79s/it]
data 147:  25%|██▌       | 130/512 [29:23<1:44:47, 16.46s/it]
data 147:  27%|██▋       | 140/512 [30:10<1:19:59, 12.90s/it]
data 147:  29%|██▉       | 150/512 [30:57<1:02:58, 10.44s/it]
data 147:  31%|███▏      | 160/512 [31:44<50:57,  8.69s/it]  
data 147:  33%|███▎      | 170/512 [32:29<42:20,  7.43s/it]
data 147:  35%|███▌      | 180/512 [34:16<46:32,  8.41s/it]
data 147:  37%|███▋      | 190/512 [35:04<39:18,  7.32s/it]
data 147:  39%|███▉      | 200/512 [35:52<34:11,  6.58s/it]
data 147:  41%|████      | 210/512 [36:39<30:19,  6.02s/it]
data 147:  43%|████▎     | 220/512 [37:27<27:26,  5.64s/it]
data 147:  45%|████▍     | 230/512 [38:13<25:09,  5.35s/it]
data 147:  47%|████▋     | 240/512 [39:01<23:24,  5.16s/it]
data 147:  49%|████▉     | 250/512 [39:44<21:30,  4.93s/it]
data 147:  51%|█████     | 260/512 [40:34<20:45,  4.94s/it]
data 147:  53%|█████▎    | 270/512 [41:19<19:25,  4.82s/it]
data 147:  55%|█████▍    | 280/512 [42:05<18:16,  4.73s/it]
data 147:  57%|█████▋    | 290/512 [42:54<17:44,  4.79s/it]
data 147:  59%|█████▊    | 300/512 [43:43<17:00,  4.82s/it]
data 147:  61%|██████    | 310/512 [44:30<16:07,  4.79s/it]
data 147:  62%|██████▎   | 320/512 [45:16<15:06,  4.72s/it]
data 147:  64%|██████▍   | 330/512 [46:05<14:30,  4.78s/it]
data 147:  66%|██████▋   | 340/512 [46:55<13:53,  4.84s/it]
data 147:  68%|██████▊   | 350/512 [47:44<13:10,  4.88s/it]
data 147:  70%|███████   | 360/512 [48:30<12:08,  4.80s/it]
data 147:  72%|███████▏  | 370/512 [49:17<11:13,  4.74s/it]
data 147:  74%|███████▍  | 380/512 [50:06<10:35,  4.81s/it]
data 147:  76%|███████▌  | 390/512 [50:57<09:57,  4.90s/it]
data 147:  78%|███████▊  | 400/512 [51:50<09:19,  5.00s/it]
data 147:  80%|████████  | 410/512 [52:38<08:26,  4.96s/it]
data 147:  82%|████████▏ | 420/512 [53:28<07:35,  4.96s/it]
data 147:  84%|████████▍ | 430/512 [54:15<06:40,  4.89s/it]
data 147:  86%|████████▌ | 440/512 [56:04<08:00,  6.68s/it]
data 147:  88%|████████▊ | 450/512 [56:54<06:23,  6.18s/it]
data 147:  90%|████████▉ | 460/512 [57:45<05:05,  5.88s/it]
data 147:  92%|█████████▏| 470/512 [58:34<03:54,  5.57s/it]
data 147:  94%|█████████▍| 480/512 [59:23<02:52,  5.38s/it]
data 147:  96%|█████████▌| 490/512 [1:00:13<01:55,  5.27s/it]
data 147:  98%|█████████▊| 500/512 [1:01:03<01:02,  5.17s/it]
data 147: 100%|█████████▉| 510/512 [1:01:53<00:10,  5.14s/it]
data 147: 100%|█████████▉| 510/512 [1:02:07<00:14,  7.31s/it]
INFO:root:函数头: 
def reshape_data(x, hue, labels):

INFO:root:目标函数体: 
    categories = list(sorted(set(hue), key=list(hue).index))
    x_stacked = np.vstack(x)
    x_reshaped = [[] for _ in categories]
    labels_reshaped = [[] for _ in categories]
    if labels is None:
        labels = [None]*len(hue)
    for idx, (point, label) in enumerate(zip(hue, labels)):
        x_reshaped[categories.index(point)].append(x_stacked[idx])
        labels_reshaped[categories.index(point)].append(labels[idx])
    return [np.vstack(i) for i in x_reshaped], labels_reshaped

INFO:root:生成结果: 
    # Check if the input data is a list of lists
    if isinstance(x, list):
        x = np.array(x)
    # Check if the input data is a numpy array
    if not isinstance(x, np.ndarray):
        raise ValueError("Input data must be a list of lists or a numpy array")
    # Check if the input data has more than one dimension
    if x.ndim != 2:
        raise ValueError("Input data must be a two-dimensional numpy array")
    # Check if the input data has the same number of rows as the number of labels
    if len(x) != len(labels):
        raise ValueError("Number of rows in input data must be equal to number of labels")
    # Check if the input data has the same number of columns as the number of categories in the hue
    if x.shape[1] != len(hue):
        raise ValueError("Number of columns in input data must be equal to number of categories in hue")
    # Check if the input data has unique categories in the hue
    unique_hue = np.unique(hue)
    if len(unique_hue) != len(hue):
        raise ValueError("Categories in hue must be unique")
    # Check if the input data has unique labels
    unique_labels = np.unique(labels)
    if len(unique_labels) != len(labels):
        raise ValueError("Labels must be unique")
    # Check if the input data has no NaN values
    if np.isnan(x).any():
        raise ValueError("Input data must not contain NaN values")
    # Check if the input data has no infinite values
    if np.isinf(x).any():
        raise ValueError("Input data must not contain infinite values")
    # Check if the input data has no zero values
    if np.zeros_like(x).any():
        raise ValueError("Input data must not contain zero values")
    # Check if the input data has no negative values
    if np.min(x) < 0:
        raise ValueError("Input data must not contain negative values")
    # Check if the input data has no positive values
    if np.max(x) > 0:
        raise ValueError("Input data must not contain positive values")
    # Check if the input data has no zero values
    if np.zeros_like(x).any():
        raise ValueError("Input data must not contain zero values")
    # Check if the input data has no negative values
    if np.min(x) < 0:
        raise ValueError("Input data

INFO:root:----------------------------------------
INFO:root:max length: 9027
INFO:root:max position: 11434
INFO:root:target_namespace: hypertools.hypertools<folder>._shared<folder>.helpers<file>.reshape_data<func>
INFO:root:****************************************

data 147:   0%|          | 0/512 [00:00<?, ?it/s]
data 147:   2%|▏         | 10/512 [00:43<36:32,  4.37s/it]
data 147:   4%|▍         | 20/512 [01:33<38:38,  4.71s/it]
data 147:   6%|▌         | 30/512 [02:22<38:42,  4.82s/it]
data 147:   8%|▊         | 40/512 [03:10<37:43,  4.80s/it]
data 147:  10%|▉         | 50/512 [03:54<35:52,  4.66s/it]
data 147:  12%|█▏        | 60/512 [04:41<35:11,  4.67s/it]
data 147:  14%|█▎        | 70/512 [05:31<35:10,  4.78s/it]
data 147:  16%|█▌        | 80/512 [06:17<34:00,  4.72s/it]
data 147:  18%|█▊        | 90/512 [07:06<33:42,  4.79s/it]
data 147:  20%|█▉        | 100/512 [07:53<32:38,  4.75s/it]
data 147:  21%|██▏       | 110/512 [09:41<44:15,  6.61s/it]
data 147:  23%|██▎       | 120/512 [10:27<39:14,  6.01s/it]
data 147:  25%|██▌       | 130/512 [11:18<36:22,  5.71s/it]
data 147:  27%|██▋       | 140/512 [12:05<33:29,  5.40s/it]
data 147:  29%|██▉       | 150/512 [12:52<31:18,  5.19s/it]
data 147:  31%|███▏      | 160/512 [13:39<29:37,  5.05s/it]
data 147:  33%|███▎      | 170/512 [14:25<28:01,  4.92s/it]
data 147:  35%|███▌      | 180/512 [15:17<27:42,  5.01s/it]
data 147:  37%|███▋      | 190/512 [16:07<26:50,  5.00s/it]
data 147:  39%|███▉      | 200/512 [16:57<26:02,  5.01s/it]
data 147:  41%|████      | 210/512 [17:44<24:44,  4.92s/it]
data 147:  43%|████▎     | 220/512 [18:30<23:30,  4.83s/it]
data 147:  45%|████▍     | 230/512 [19:15<22:10,  4.72s/it]
data 147:  47%|████▋     | 240/512 [20:00<21:03,  4.64s/it]
data 147:  49%|████▉     | 250/512 [32:48<1:54:53, 26.31s/it]
data 147:  51%|█████     | 260/512 [58:38<4:32:37, 64.91s/it]
data 147:  53%|█████▎    | 270/512 [59:24<3:08:49, 46.81s/it]
data 147:  55%|█████▍    | 280/512 [1:00:08<2:11:50, 34.10s/it]
data 147:  57%|█████▋    | 290/512 [1:00:53<1:33:18, 25.22s/it]
data 147:  59%|█████▊    | 300/512 [1:01:40<1:07:21, 19.06s/it]
data 147:  61%|██████    | 310/512 [1:02:26<49:31, 14.71s/it]  
data 147:  62%|██████▎   | 320/512 [1:03:14<37:37, 11.76s/it]
data 147:  64%|██████▍   | 330/512 [1:04:04<29:30,  9.73s/it]
data 147:  66%|██████▋   | 340/512 [1:04:55<23:52,  8.33s/it]
data 147:  68%|██████▊   | 350/512 [1:05:43<19:38,  7.27s/it]
data 147:  70%|███████   | 360/512 [1:06:31<16:33,  6.53s/it]
data 147:  72%|███████▏  | 370/512 [1:07:20<14:17,  6.04s/it]
data 147:  74%|███████▍  | 380/512 [1:08:08<12:27,  5.66s/it]
data 147:  76%|███████▌  | 390/512 [1:08:57<11:02,  5.43s/it]
data 147:  78%|███████▊  | 400/512 [1:09:44<09:44,  5.22s/it]
data 147:  80%|████████  | 410/512 [1:11:31<11:40,  6.87s/it]
data 147:  82%|████████▏ | 420/512 [1:12:20<09:35,  6.26s/it]
data 147:  84%|████████▍ | 430/512 [1:13:08<07:59,  5.85s/it]
data 147:  86%|████████▌ | 440/512 [1:13:58<06:41,  5.57s/it]
data 147:  88%|████████▊ | 450/512 [1:14:48<05:34,  5.40s/it]
data 147:  90%|████████▉ | 460/512 [1:15:37<04:33,  5.26s/it]
data 147:  92%|█████████▏| 470/512 [1:16:24<03:33,  5.08s/it]
data 147:  94%|█████████▍| 480/512 [1:17:15<02:43,  5.10s/it]
data 147:  96%|█████████▌| 490/512 [1:18:03<01:50,  5.00s/it]
data 147:  98%|█████████▊| 500/512 [1:29:10<04:42, 23.52s/it]
data 147: 100%|█████████▉| 510/512 [1:53:07<01:59, 59.59s/it]
data 147: 100%|█████████▉| 510/512 [1:53:22<00:26, 13.34s/it]
INFO:root:函数头: 
def reshape_data(x, hue, labels):

INFO:root:目标函数体: 
    categories = list(sorted(set(hue), key=list(hue).index))
    x_stacked = np.vstack(x)
    x_reshaped = [[] for _ in categories]
    labels_reshaped = [[] for _ in categories]
    if labels is None:
        labels = [None]*len(hue)
    for idx, (point, label) in enumerate(zip(hue, labels)):
        x_reshaped[categories.index(point)].append(x_stacked[idx])
        labels_reshaped[categories.index(point)].append(labels[idx])
    return [np.vstack(i) for i in x_reshaped], labels_reshaped

INFO:root:生成结果: 
    # Check if the input data is a list of lists
    if isinstance(x, list):
        # Check if the input data is a list of lists of lists
        if len(x[0]) > 0 and isinstance(x[0][0], list):
            # Check if the input data is a list of lists of lists of lists
            if len(x[0][0][0]) > 0 and isinstance(x[0][0][0], list):
                raise ValueError("Input data must be a list of lists of lists of lists")
            else:
                # Check if the input data is a list of lists of lists of floats
                if all(isinstance(i, list) for i in x[0][0]):
                    raise ValueError("Input data must be a list of lists of lists of floats")
                else:
                    # Check if the input data is a list of lists of floats
                    if all(isinstance(i, float) for i in x[0]):
                        raise ValueError("Input data must be a list of lists of floats")
                    else:
                        raise ValueError("Input data must be a list of lists of floats")
            # Check if the input data is a list of lists of floats
            if all(isinstance(i, float) for i in x[0]):
                raise ValueError("Input data must be a list of lists of floats")
            else:
                raise ValueError("Input data must be a list of lists of floats")
        else:
            # Check if the input data is a list of lists of floats
            if all(isinstance(i, list) for i in x[0]):
                raise ValueError("Input data must be a list of lists of floats")
            else:
                raise ValueError("Input data must be a list of lists of floats")
        # Check if the input data is a list of lists of floats
        if all(isinstance(i, float) for i in x[0]):
            raise ValueError("Input data must be a list of lists of floats")
        else:
            raise ValueError("Input data must be a list of lists of floats")
        # Check if the input data is a list of lists of floats
        if all(isinstance(i, float) for i in x[0]):
            raise ValueError("Input data must be a list of lists of floats")
        else:
            raise ValueError("Input data must be a list of lists of floats")
        # Check if the input data is a list of lists of floats
        if all(isinstance(i, float

INFO:root:----------------------------------------
INFO:root:max length: 9163
INFO:root:max position: 11302
INFO:root:target_namespace: hypertools.hypertools<folder>._shared<folder>.helpers<file>.reshape_data<func>
INFO:root:****************************************

data 147:   0%|          | 0/512 [00:00<?, ?it/s]
data 147:   2%|▏         | 10/512 [00:41<34:20,  4.11s/it]
data 147:   4%|▍         | 20/512 [02:27<1:05:04,  7.94s/it]
data 147:   6%|▌         | 30/512 [06:15<1:58:21, 14.73s/it]
data 147:   8%|▊         | 40/512 [07:02<1:24:53, 10.79s/it]
data 147:  10%|▉         | 50/512 [07:50<1:06:25,  8.63s/it]
data 147:  12%|█▏        | 60/512 [09:39<1:10:49,  9.40s/it]
data 147:  14%|█▎        | 70/512 [10:26<57:55,  7.86s/it]  
data 147:  16%|█▌        | 80/512 [16:14<1:58:18, 16.43s/it]
data 147:  18%|█▊        | 90/512 [19:01<1:56:13, 16.52s/it]
data 147:  20%|█▉        | 100/512 [20:50<1:41:23, 14.77s/it]
data 147:  21%|██▏       | 110/512 [21:38<1:18:33, 11.73s/it]
data 147:  23%|██▎       | 120/512 [23:26<1:14:49, 11.45s/it]
data 147:  25%|██▌       | 130/512 [46:16<5:14:56, 49.47s/it]
data 147:  27%|██▋       | 140/512 [47:01<3:42:36, 35.90s/it]
data 147:  29%|██▉       | 150/512 [47:48<2:39:53, 26.50s/it]
data 147:  31%|███▏      | 160/512 [48:37<1:57:10, 19.97s/it]
data 147:  33%|███▎      | 170/512 [50:25<1:38:08, 17.22s/it]
data 147:  35%|███▌      | 180/512 [52:12<1:24:29, 15.27s/it]
data 147:  37%|███▋      | 190/512 [1:12:03<4:09:21, 46.46s/it]
data 147:  39%|███▉      | 200/512 [1:12:55<2:57:09, 34.07s/it]
data 147:  41%|████      | 210/512 [1:13:44<2:07:23, 25.31s/it]
data 147:  43%|████▎     | 220/512 [1:14:29<1:32:45, 19.06s/it]
data 147:  43%|████▎     | 220/512 [1:14:52<1:39:23, 20.42s/it]
INFO:root:函数头: 
def reshape_data(x, hue, labels):

INFO:root:目标函数体: 
    categories = list(sorted(set(hue), key=list(hue).index))
    x_stacked = np.vstack(x)
    x_reshaped = [[] for _ in categories]
    labels_reshaped = [[] for _ in categories]
    if labels is None:
        labels = [None]*len(hue)
    for idx, (point, label) in enumerate(zip(hue, labels)):
        x_reshaped[categories.index(point)].append(x_stacked[idx])
        labels_reshaped[categories.index(point)].append(labels[idx])
    return [np.vstack(i) for i in x_reshaped], labels_reshaped

INFO:root:生成结果: 
    unique_hues = np.unique(hue)
    unique_labels = np.unique(labels) if labels is not None else None

    # Check if there are any unique hues or labels
    if len(unique_hues) == 0 or (unique_labels is not None and len(unique_labels) == 0):
        raise ValueError("No unique hues or labels found")

    # Create a list to store the reshaped data and labels
    reshaped_data = []
    reshaped_labels = [] if labels is not None else []

    # Loop through each unique hue and create a list of data points for that hue
    for hue_val in unique_hues:
        hue_indices = np.where(hue == hue_val)[0]
        reshaped_data.append(x[hue_indices])

    # Loop through each unique label and create a list of labels for that label
    if labels is not None:
        for label_val in unique_labels:
            label_indices = np.where(labels == label_val)[0]
            reshaped_labels.append(labels[label_indices])

    return reshaped_data, reshaped_labels


INFO:root:----------------------------------------
INFO:root:max length: 8930
INFO:root:max position: 11697
INFO:root:target_namespace: hypertools.hypertools<folder>._shared<folder>.helpers<file>.reshape_data<func>
INFO:root:****************************************

data 147:   0%|          | 0/512 [00:00<?, ?it/s]
data 147:   2%|▏         | 10/512 [00:43<36:13,  4.33s/it]
data 147:   4%|▍         | 20/512 [01:30<37:19,  4.55s/it]
data 147:   6%|▌         | 30/512 [02:15<36:32,  4.55s/it]
data 147:   8%|▊         | 40/512 [03:04<36:49,  4.68s/it]
data 147:  10%|▉         | 50/512 [03:57<37:38,  4.89s/it]
data 147:  12%|█▏        | 60/512 [04:46<36:50,  4.89s/it]
data 147:  14%|█▎        | 70/512 [05:32<35:22,  4.80s/it]
data 147:  16%|█▌        | 80/512 [06:20<34:34,  4.80s/it]
data 147:  18%|█▊        | 90/512 [20:11<3:25:59, 29.29s/it]
data 147:  20%|█▉        | 100/512 [22:03<2:42:45, 23.70s/it]
data 147:  21%|██▏       | 110/512 [24:08<2:15:44, 20.26s/it]
data 147:  23%|██▎       | 120/512 [25:16<1:45:37, 16.17s/it]
data 147:  25%|██▌       | 130/512 [27:22<1:36:02, 15.08s/it]
data 147:  27%|██▋       | 140/512 [28:29<1:17:54, 12.57s/it]
data 147:  29%|██▉       | 150/512 [29:36<1:05:10, 10.80s/it]
data 147:  31%|███▏      | 160/512 [31:41<1:06:19, 11.30s/it]
data 147:  33%|███▎      | 170/512 [32:44<55:55,  9.81s/it]  
data 147:  33%|███▎      | 170/512 [32:53<1:06:09, 11.61s/it]
Traceback (most recent call last):
  File "/home/qikahh/projects/Structured_Code_Context/test_hierarchical_model.py", line 271, in <module>
    with tqdm(total=hierarchical_model.max_length, desc="data {}".format(idx)) as pbar:
                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/qikahh/projects/Structured_Code_Context/utils/hierarchical_model.py", line 903, in generate_step
    hidden_states = inputs_embeds.to(self.device)
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/qikahh/miniconda3/lib/python3.11/site-packages/torch/nn/modules/module.py", line 1532, in _wrapped_call_impl
    return self._call_impl(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/qikahh/miniconda3/lib/python3.11/site-packages/torch/nn/modules/module.py", line 1541, in _call_impl
    return forward_call(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/qikahh/miniconda3/lib/python3.11/site-packages/transformers/models/qwen2/modeling_qwen2.py", line 629, in forward
    hidden_states, self_attn_weights, present_key_value = self.self_attn(
                                                          ^^^^^^^^^^^^^^^
  File "/home/qikahh/miniconda3/lib/python3.11/site-packages/torch/nn/modules/module.py", line 1532, in _wrapped_call_impl
    return self._call_impl(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/qikahh/miniconda3/lib/python3.11/site-packages/torch/nn/modules/module.py", line 1541, in _call_impl
    return forward_call(*args, **kwargs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/qikahh/miniconda3/lib/python3.11/site-packages/transformers/models/qwen2/modeling_qwen2.py", line 317, in forward
    value_states = repeat_kv(value_states, self.num_key_value_groups)
                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/qikahh/miniconda3/lib/python3.11/site-packages/transformers/models/qwen2/modeling_qwen2.py", line 236, in repeat_kv
    return hidden_states.reshape(batch, num_key_value_heads * n_rep, slen, head_dim)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
torch.cuda.OutOfMemoryError: CUDA out of memory. Tried to allocate 32.00 MiB. GPU 
